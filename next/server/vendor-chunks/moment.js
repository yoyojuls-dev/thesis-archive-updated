"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/moment";
exports.ids = ["vendor-chunks/moment"];
exports.modules = {

/***/ "(rsc)/./node_modules/moment/moment.js":
/*!***************************************!*\
  !*** ./node_modules/moment/moment.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n//! moment.js\n//! version : 2.29.4\n//! authors : Tim Wood, Iskren Chernev, Moment.js contributors\n//! license : MIT\n//! momentjs.com\n\n;\n(function(global, factory) {\n     true ? module.exports = factory() : 0;\n})(void 0, function() {\n    \"use strict\";\n    var hookCallback;\n    function hooks() {\n        return hookCallback.apply(null, arguments);\n    }\n    // This is done to register the method called with moment()\n    // without creating circular dependencies.\n    function setHookCallback(callback) {\n        hookCallback = callback;\n    }\n    function isArray(input) {\n        return input instanceof Array || Object.prototype.toString.call(input) === \"[object Array]\";\n    }\n    function isObject(input) {\n        // IE8 will treat undefined and null as object if it wasn't for\n        // input != null\n        return input != null && Object.prototype.toString.call(input) === \"[object Object]\";\n    }\n    function hasOwnProp(a, b) {\n        return Object.prototype.hasOwnProperty.call(a, b);\n    }\n    function isObjectEmpty(obj) {\n        if (Object.getOwnPropertyNames) {\n            return Object.getOwnPropertyNames(obj).length === 0;\n        } else {\n            var k;\n            for(k in obj){\n                if (hasOwnProp(obj, k)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    function isUndefined(input) {\n        return input === void 0;\n    }\n    function isNumber(input) {\n        return typeof input === \"number\" || Object.prototype.toString.call(input) === \"[object Number]\";\n    }\n    function isDate(input) {\n        return input instanceof Date || Object.prototype.toString.call(input) === \"[object Date]\";\n    }\n    function map(arr, fn) {\n        var res = [], i, arrLen = arr.length;\n        for(i = 0; i < arrLen; ++i){\n            res.push(fn(arr[i], i));\n        }\n        return res;\n    }\n    function extend(a, b) {\n        for(var i in b){\n            if (hasOwnProp(b, i)) {\n                a[i] = b[i];\n            }\n        }\n        if (hasOwnProp(b, \"toString\")) {\n            a.toString = b.toString;\n        }\n        if (hasOwnProp(b, \"valueOf\")) {\n            a.valueOf = b.valueOf;\n        }\n        return a;\n    }\n    function createUTC(input, format, locale, strict) {\n        return createLocalOrUTC(input, format, locale, strict, true).utc();\n    }\n    function defaultParsingFlags() {\n        // We need to deep clone this object.\n        return {\n            empty: false,\n            unusedTokens: [],\n            unusedInput: [],\n            overflow: -2,\n            charsLeftOver: 0,\n            nullInput: false,\n            invalidEra: null,\n            invalidMonth: null,\n            invalidFormat: false,\n            userInvalidated: false,\n            iso: false,\n            parsedDateParts: [],\n            era: null,\n            meridiem: null,\n            rfc2822: false,\n            weekdayMismatch: false\n        };\n    }\n    function getParsingFlags(m) {\n        if (m._pf == null) {\n            m._pf = defaultParsingFlags();\n        }\n        return m._pf;\n    }\n    var some;\n    if (Array.prototype.some) {\n        some = Array.prototype.some;\n    } else {\n        some = function(fun) {\n            var t = Object(this), len = t.length >>> 0, i;\n            for(i = 0; i < len; i++){\n                if (i in t && fun.call(this, t[i], i, t)) {\n                    return true;\n                }\n            }\n            return false;\n        };\n    }\n    function isValid(m) {\n        if (m._isValid == null) {\n            var flags = getParsingFlags(m), parsedParts = some.call(flags.parsedDateParts, function(i) {\n                return i != null;\n            }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);\n            if (m._strict) {\n                isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;\n            }\n            if (Object.isFrozen == null || !Object.isFrozen(m)) {\n                m._isValid = isNowValid;\n            } else {\n                return isNowValid;\n            }\n        }\n        return m._isValid;\n    }\n    function createInvalid(flags) {\n        var m = createUTC(NaN);\n        if (flags != null) {\n            extend(getParsingFlags(m), flags);\n        } else {\n            getParsingFlags(m).userInvalidated = true;\n        }\n        return m;\n    }\n    // Plugins that add properties should also add the key here (null value),\n    // so we can properly clone ourselves.\n    var momentProperties = hooks.momentProperties = [], updateInProgress = false;\n    function copyConfig(to, from) {\n        var i, prop, val, momentPropertiesLen = momentProperties.length;\n        if (!isUndefined(from._isAMomentObject)) {\n            to._isAMomentObject = from._isAMomentObject;\n        }\n        if (!isUndefined(from._i)) {\n            to._i = from._i;\n        }\n        if (!isUndefined(from._f)) {\n            to._f = from._f;\n        }\n        if (!isUndefined(from._l)) {\n            to._l = from._l;\n        }\n        if (!isUndefined(from._strict)) {\n            to._strict = from._strict;\n        }\n        if (!isUndefined(from._tzm)) {\n            to._tzm = from._tzm;\n        }\n        if (!isUndefined(from._isUTC)) {\n            to._isUTC = from._isUTC;\n        }\n        if (!isUndefined(from._offset)) {\n            to._offset = from._offset;\n        }\n        if (!isUndefined(from._pf)) {\n            to._pf = getParsingFlags(from);\n        }\n        if (!isUndefined(from._locale)) {\n            to._locale = from._locale;\n        }\n        if (momentPropertiesLen > 0) {\n            for(i = 0; i < momentPropertiesLen; i++){\n                prop = momentProperties[i];\n                val = from[prop];\n                if (!isUndefined(val)) {\n                    to[prop] = val;\n                }\n            }\n        }\n        return to;\n    }\n    // Moment prototype object\n    function Moment(config) {\n        copyConfig(this, config);\n        this._d = new Date(config._d != null ? config._d.getTime() : NaN);\n        if (!this.isValid()) {\n            this._d = new Date(NaN);\n        }\n        // Prevent infinite loop in case updateOffset creates new moment\n        // objects.\n        if (updateInProgress === false) {\n            updateInProgress = true;\n            hooks.updateOffset(this);\n            updateInProgress = false;\n        }\n    }\n    function isMoment(obj) {\n        return obj instanceof Moment || obj != null && obj._isAMomentObject != null;\n    }\n    function warn(msg) {\n        if (hooks.suppressDeprecationWarnings === false && typeof console !== \"undefined\" && console.warn) {\n            console.warn(\"Deprecation warning: \" + msg);\n        }\n    }\n    function deprecate(msg, fn) {\n        var firstTime = true;\n        return extend(function() {\n            if (hooks.deprecationHandler != null) {\n                hooks.deprecationHandler(null, msg);\n            }\n            if (firstTime) {\n                var args = [], arg, i, key, argLen = arguments.length;\n                for(i = 0; i < argLen; i++){\n                    arg = \"\";\n                    if (typeof arguments[i] === \"object\") {\n                        arg += \"\\n[\" + i + \"] \";\n                        for(key in arguments[0]){\n                            if (hasOwnProp(arguments[0], key)) {\n                                arg += key + \": \" + arguments[0][key] + \", \";\n                            }\n                        }\n                        arg = arg.slice(0, -2); // Remove trailing comma and space\n                    } else {\n                        arg = arguments[i];\n                    }\n                    args.push(arg);\n                }\n                warn(msg + \"\\nArguments: \" + Array.prototype.slice.call(args).join(\"\") + \"\\n\" + new Error().stack);\n                firstTime = false;\n            }\n            return fn.apply(this, arguments);\n        }, fn);\n    }\n    var deprecations = {};\n    function deprecateSimple(name, msg) {\n        if (hooks.deprecationHandler != null) {\n            hooks.deprecationHandler(name, msg);\n        }\n        if (!deprecations[name]) {\n            warn(msg);\n            deprecations[name] = true;\n        }\n    }\n    hooks.suppressDeprecationWarnings = false;\n    hooks.deprecationHandler = null;\n    function isFunction(input) {\n        return typeof Function !== \"undefined\" && input instanceof Function || Object.prototype.toString.call(input) === \"[object Function]\";\n    }\n    function set(config) {\n        var prop, i;\n        for(i in config){\n            if (hasOwnProp(config, i)) {\n                prop = config[i];\n                if (isFunction(prop)) {\n                    this[i] = prop;\n                } else {\n                    this[\"_\" + i] = prop;\n                }\n            }\n        }\n        this._config = config;\n        // Lenient ordinal parsing accepts just a number in addition to\n        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.\n        // TODO: Remove \"ordinalParse\" fallback in next major release.\n        this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + \"|\" + /\\d{1,2}/.source);\n    }\n    function mergeConfigs(parentConfig, childConfig) {\n        var res = extend({}, parentConfig), prop;\n        for(prop in childConfig){\n            if (hasOwnProp(childConfig, prop)) {\n                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {\n                    res[prop] = {};\n                    extend(res[prop], parentConfig[prop]);\n                    extend(res[prop], childConfig[prop]);\n                } else if (childConfig[prop] != null) {\n                    res[prop] = childConfig[prop];\n                } else {\n                    delete res[prop];\n                }\n            }\n        }\n        for(prop in parentConfig){\n            if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {\n                // make sure changes to properties don't modify parent config\n                res[prop] = extend({}, res[prop]);\n            }\n        }\n        return res;\n    }\n    function Locale(config) {\n        if (config != null) {\n            this.set(config);\n        }\n    }\n    var keys;\n    if (Object.keys) {\n        keys = Object.keys;\n    } else {\n        keys = function(obj) {\n            var i, res = [];\n            for(i in obj){\n                if (hasOwnProp(obj, i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        };\n    }\n    var defaultCalendar = {\n        sameDay: \"[Today at] LT\",\n        nextDay: \"[Tomorrow at] LT\",\n        nextWeek: \"dddd [at] LT\",\n        lastDay: \"[Yesterday at] LT\",\n        lastWeek: \"[Last] dddd [at] LT\",\n        sameElse: \"L\"\n    };\n    function calendar(key, mom, now) {\n        var output = this._calendar[key] || this._calendar[\"sameElse\"];\n        return isFunction(output) ? output.call(mom, now) : output;\n    }\n    function zeroFill(number, targetLength, forceSign) {\n        var absNumber = \"\" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign = number >= 0;\n        return (sign ? forceSign ? \"+\" : \"\" : \"-\") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;\n    }\n    var formattingTokens = /(\\[[^\\[]*\\])|(\\\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};\n    // token:    'M'\n    // padded:   ['MM', 2]\n    // ordinal:  'Mo'\n    // callback: function () { this.month() + 1 }\n    function addFormatToken(token, padded, ordinal, callback) {\n        var func = callback;\n        if (typeof callback === \"string\") {\n            func = function() {\n                return this[callback]();\n            };\n        }\n        if (token) {\n            formatTokenFunctions[token] = func;\n        }\n        if (padded) {\n            formatTokenFunctions[padded[0]] = function() {\n                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);\n            };\n        }\n        if (ordinal) {\n            formatTokenFunctions[ordinal] = function() {\n                return this.localeData().ordinal(func.apply(this, arguments), token);\n            };\n        }\n    }\n    function removeFormattingTokens(input) {\n        if (input.match(/\\[[\\s\\S]/)) {\n            return input.replace(/^\\[|\\]$/g, \"\");\n        }\n        return input.replace(/\\\\/g, \"\");\n    }\n    function makeFormatFunction(format) {\n        var array = format.match(formattingTokens), i, length;\n        for(i = 0, length = array.length; i < length; i++){\n            if (formatTokenFunctions[array[i]]) {\n                array[i] = formatTokenFunctions[array[i]];\n            } else {\n                array[i] = removeFormattingTokens(array[i]);\n            }\n        }\n        return function(mom) {\n            var output = \"\", i;\n            for(i = 0; i < length; i++){\n                output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];\n            }\n            return output;\n        };\n    }\n    // format date using native date object\n    function formatMoment(m, format) {\n        if (!m.isValid()) {\n            return m.localeData().invalidDate();\n        }\n        format = expandFormat(format, m.localeData());\n        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);\n        return formatFunctions[format](m);\n    }\n    function expandFormat(format, locale) {\n        var i = 5;\n        function replaceLongDateFormatTokens(input) {\n            return locale.longDateFormat(input) || input;\n        }\n        localFormattingTokens.lastIndex = 0;\n        while(i >= 0 && localFormattingTokens.test(format)){\n            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);\n            localFormattingTokens.lastIndex = 0;\n            i -= 1;\n        }\n        return format;\n    }\n    var defaultLongDateFormat = {\n        LTS: \"h:mm:ss A\",\n        LT: \"h:mm A\",\n        L: \"MM/DD/YYYY\",\n        LL: \"MMMM D, YYYY\",\n        LLL: \"MMMM D, YYYY h:mm A\",\n        LLLL: \"dddd, MMMM D, YYYY h:mm A\"\n    };\n    function longDateFormat(key) {\n        var format = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];\n        if (format || !formatUpper) {\n            return format;\n        }\n        this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {\n            if (tok === \"MMMM\" || tok === \"MM\" || tok === \"DD\" || tok === \"dddd\") {\n                return tok.slice(1);\n            }\n            return tok;\n        }).join(\"\");\n        return this._longDateFormat[key];\n    }\n    var defaultInvalidDate = \"Invalid date\";\n    function invalidDate() {\n        return this._invalidDate;\n    }\n    var defaultOrdinal = \"%d\", defaultDayOfMonthOrdinalParse = /\\d{1,2}/;\n    function ordinal(number) {\n        return this._ordinal.replace(\"%d\", number);\n    }\n    var defaultRelativeTime = {\n        future: \"in %s\",\n        past: \"%s ago\",\n        s: \"a few seconds\",\n        ss: \"%d seconds\",\n        m: \"a minute\",\n        mm: \"%d minutes\",\n        h: \"an hour\",\n        hh: \"%d hours\",\n        d: \"a day\",\n        dd: \"%d days\",\n        w: \"a week\",\n        ww: \"%d weeks\",\n        M: \"a month\",\n        MM: \"%d months\",\n        y: \"a year\",\n        yy: \"%d years\"\n    };\n    function relativeTime(number, withoutSuffix, string, isFuture) {\n        var output = this._relativeTime[string];\n        return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);\n    }\n    function pastFuture(diff, output) {\n        var format = this._relativeTime[diff > 0 ? \"future\" : \"past\"];\n        return isFunction(format) ? format(output) : format.replace(/%s/i, output);\n    }\n    var aliases = {};\n    function addUnitAlias(unit, shorthand) {\n        var lowerCase = unit.toLowerCase();\n        aliases[lowerCase] = aliases[lowerCase + \"s\"] = aliases[shorthand] = unit;\n    }\n    function normalizeUnits(units) {\n        return typeof units === \"string\" ? aliases[units] || aliases[units.toLowerCase()] : undefined;\n    }\n    function normalizeObjectUnits(inputObject) {\n        var normalizedInput = {}, normalizedProp, prop;\n        for(prop in inputObject){\n            if (hasOwnProp(inputObject, prop)) {\n                normalizedProp = normalizeUnits(prop);\n                if (normalizedProp) {\n                    normalizedInput[normalizedProp] = inputObject[prop];\n                }\n            }\n        }\n        return normalizedInput;\n    }\n    var priorities = {};\n    function addUnitPriority(unit, priority) {\n        priorities[unit] = priority;\n    }\n    function getPrioritizedUnits(unitsObj) {\n        var units = [], u;\n        for(u in unitsObj){\n            if (hasOwnProp(unitsObj, u)) {\n                units.push({\n                    unit: u,\n                    priority: priorities[u]\n                });\n            }\n        }\n        units.sort(function(a, b) {\n            return a.priority - b.priority;\n        });\n        return units;\n    }\n    function isLeapYear(year) {\n        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;\n    }\n    function absFloor(number) {\n        if (number < 0) {\n            // -0 -> 0\n            return Math.ceil(number) || 0;\n        } else {\n            return Math.floor(number);\n        }\n    }\n    function toInt(argumentForCoercion) {\n        var coercedNumber = +argumentForCoercion, value = 0;\n        if (coercedNumber !== 0 && isFinite(coercedNumber)) {\n            value = absFloor(coercedNumber);\n        }\n        return value;\n    }\n    function makeGetSet(unit, keepTime) {\n        return function(value) {\n            if (value != null) {\n                set$1(this, unit, value);\n                hooks.updateOffset(this, keepTime);\n                return this;\n            } else {\n                return get(this, unit);\n            }\n        };\n    }\n    function get(mom, unit) {\n        return mom.isValid() ? mom._d[\"get\" + (mom._isUTC ? \"UTC\" : \"\") + unit]() : NaN;\n    }\n    function set$1(mom, unit, value) {\n        if (mom.isValid() && !isNaN(value)) {\n            if (unit === \"FullYear\" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {\n                value = toInt(value);\n                mom._d[\"set\" + (mom._isUTC ? \"UTC\" : \"\") + unit](value, mom.month(), daysInMonth(value, mom.month()));\n            } else {\n                mom._d[\"set\" + (mom._isUTC ? \"UTC\" : \"\") + unit](value);\n            }\n        }\n    }\n    // MOMENTS\n    function stringGet(units) {\n        units = normalizeUnits(units);\n        if (isFunction(this[units])) {\n            return this[units]();\n        }\n        return this;\n    }\n    function stringSet(units, value) {\n        if (typeof units === \"object\") {\n            units = normalizeObjectUnits(units);\n            var prioritized = getPrioritizedUnits(units), i, prioritizedLen = prioritized.length;\n            for(i = 0; i < prioritizedLen; i++){\n                this[prioritized[i].unit](units[prioritized[i].unit]);\n            }\n        } else {\n            units = normalizeUnits(units);\n            if (isFunction(this[units])) {\n                return this[units](value);\n            }\n        }\n        return this;\n    }\n    var match1 = /\\d/, match2 = /\\d\\d/, match3 = /\\d{3}/, match4 = /\\d{4}/, match6 = /[+-]?\\d{6}/, match1to2 = /\\d\\d?/, match3to4 = /\\d\\d\\d\\d?/, match5to6 = /\\d\\d\\d\\d\\d\\d?/, match1to3 = /\\d{1,3}/, match1to4 = /\\d{1,4}/, match1to6 = /[+-]?\\d{1,6}/, matchUnsigned = /\\d+/, matchSigned = /[+-]?\\d+/, matchOffset = /Z|[+-]\\d\\d:?\\d\\d/gi, matchShortOffset = /Z|[+-]\\d\\d(?::?\\d\\d)?/gi, matchTimestamp = /[+-]?\\d+(\\.\\d{1,3})?/, // any word (or two) characters or numbers including two/three word month in arabic.\n    // includes scottish gaelic two word and hyphenated months\n    matchWord = /[0-9]{0,256}['a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFF07\\uFF10-\\uFFEF]{1,256}|[\\u0600-\\u06FF\\/]{1,256}(\\s*?[\\u0600-\\u06FF]{1,256}){1,2}/i, regexes;\n    regexes = {};\n    function addRegexToken(token, regex, strictRegex) {\n        regexes[token] = isFunction(regex) ? regex : function(isStrict, localeData) {\n            return isStrict && strictRegex ? strictRegex : regex;\n        };\n    }\n    function getParseRegexForToken(token, config) {\n        if (!hasOwnProp(regexes, token)) {\n            return new RegExp(unescapeFormat(token));\n        }\n        return regexes[token](config._strict, config._locale);\n    }\n    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\n    function unescapeFormat(s) {\n        return regexEscape(s.replace(\"\\\\\", \"\").replace(/\\\\(\\[)|\\\\(\\])|\\[([^\\]\\[]*)\\]|\\\\(.)/g, function(matched, p1, p2, p3, p4) {\n            return p1 || p2 || p3 || p4;\n        }));\n    }\n    function regexEscape(s) {\n        return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n    }\n    var tokens = {};\n    function addParseToken(token, callback) {\n        var i, func = callback, tokenLen;\n        if (typeof token === \"string\") {\n            token = [\n                token\n            ];\n        }\n        if (isNumber(callback)) {\n            func = function(input, array) {\n                array[callback] = toInt(input);\n            };\n        }\n        tokenLen = token.length;\n        for(i = 0; i < tokenLen; i++){\n            tokens[token[i]] = func;\n        }\n    }\n    function addWeekParseToken(token, callback) {\n        addParseToken(token, function(input, array, config, token) {\n            config._w = config._w || {};\n            callback(input, config._w, config, token);\n        });\n    }\n    function addTimeToArrayFromToken(token, input, config) {\n        if (input != null && hasOwnProp(tokens, token)) {\n            tokens[token](input, config._a, config, token);\n        }\n    }\n    var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;\n    function mod(n, x) {\n        return (n % x + x) % x;\n    }\n    var indexOf;\n    if (Array.prototype.indexOf) {\n        indexOf = Array.prototype.indexOf;\n    } else {\n        indexOf = function(o) {\n            // I know\n            var i;\n            for(i = 0; i < this.length; ++i){\n                if (this[i] === o) {\n                    return i;\n                }\n            }\n            return -1;\n        };\n    }\n    function daysInMonth(year, month) {\n        if (isNaN(year) || isNaN(month)) {\n            return NaN;\n        }\n        var modMonth = mod(month, 12);\n        year += (month - modMonth) / 12;\n        return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;\n    }\n    // FORMATTING\n    addFormatToken(\"M\", [\n        \"MM\",\n        2\n    ], \"Mo\", function() {\n        return this.month() + 1;\n    });\n    addFormatToken(\"MMM\", 0, 0, function(format) {\n        return this.localeData().monthsShort(this, format);\n    });\n    addFormatToken(\"MMMM\", 0, 0, function(format) {\n        return this.localeData().months(this, format);\n    });\n    // ALIASES\n    addUnitAlias(\"month\", \"M\");\n    // PRIORITY\n    addUnitPriority(\"month\", 8);\n    // PARSING\n    addRegexToken(\"M\", match1to2);\n    addRegexToken(\"MM\", match1to2, match2);\n    addRegexToken(\"MMM\", function(isStrict, locale) {\n        return locale.monthsShortRegex(isStrict);\n    });\n    addRegexToken(\"MMMM\", function(isStrict, locale) {\n        return locale.monthsRegex(isStrict);\n    });\n    addParseToken([\n        \"M\",\n        \"MM\"\n    ], function(input, array) {\n        array[MONTH] = toInt(input) - 1;\n    });\n    addParseToken([\n        \"MMM\",\n        \"MMMM\"\n    ], function(input, array, config, token) {\n        var month = config._locale.monthsParse(input, token, config._strict);\n        // if we didn't find a month name, mark the date as invalid.\n        if (month != null) {\n            array[MONTH] = month;\n        } else {\n            getParsingFlags(config).invalidMonth = input;\n        }\n    });\n    // LOCALES\n    var defaultLocaleMonths = \"January_February_March_April_May_June_July_August_September_October_November_December\".split(\"_\"), defaultLocaleMonthsShort = \"Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec\".split(\"_\"), MONTHS_IN_FORMAT = /D[oD]?(\\[[^\\[\\]]*\\]|\\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;\n    function localeMonths(m, format) {\n        if (!m) {\n            return isArray(this._months) ? this._months : this._months[\"standalone\"];\n        }\n        return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? \"format\" : \"standalone\"][m.month()];\n    }\n    function localeMonthsShort(m, format) {\n        if (!m) {\n            return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort[\"standalone\"];\n        }\n        return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? \"format\" : \"standalone\"][m.month()];\n    }\n    function handleStrictParse(monthName, format, strict) {\n        var i, ii, mom, llc = monthName.toLocaleLowerCase();\n        if (!this._monthsParse) {\n            // this is not used\n            this._monthsParse = [];\n            this._longMonthsParse = [];\n            this._shortMonthsParse = [];\n            for(i = 0; i < 12; ++i){\n                mom = createUTC([\n                    2000,\n                    i\n                ]);\n                this._shortMonthsParse[i] = this.monthsShort(mom, \"\").toLocaleLowerCase();\n                this._longMonthsParse[i] = this.months(mom, \"\").toLocaleLowerCase();\n            }\n        }\n        if (strict) {\n            if (format === \"MMM\") {\n                ii = indexOf.call(this._shortMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._longMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        } else {\n            if (format === \"MMM\") {\n                ii = indexOf.call(this._shortMonthsParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._longMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._longMonthsParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._shortMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        }\n    }\n    function localeMonthsParse(monthName, format, strict) {\n        var i, mom, regex;\n        if (this._monthsParseExact) {\n            return handleStrictParse.call(this, monthName, format, strict);\n        }\n        if (!this._monthsParse) {\n            this._monthsParse = [];\n            this._longMonthsParse = [];\n            this._shortMonthsParse = [];\n        }\n        // TODO: add sorting\n        // Sorting makes sure if one month (or abbr) is a prefix of another\n        // see sorting in computeMonthsParse\n        for(i = 0; i < 12; i++){\n            // make the regex if we don't have it already\n            mom = createUTC([\n                2000,\n                i\n            ]);\n            if (strict && !this._longMonthsParse[i]) {\n                this._longMonthsParse[i] = new RegExp(\"^\" + this.months(mom, \"\").replace(\".\", \"\") + \"$\", \"i\");\n                this._shortMonthsParse[i] = new RegExp(\"^\" + this.monthsShort(mom, \"\").replace(\".\", \"\") + \"$\", \"i\");\n            }\n            if (!strict && !this._monthsParse[i]) {\n                regex = \"^\" + this.months(mom, \"\") + \"|^\" + this.monthsShort(mom, \"\");\n                this._monthsParse[i] = new RegExp(regex.replace(\".\", \"\"), \"i\");\n            }\n            // test the regex\n            if (strict && format === \"MMMM\" && this._longMonthsParse[i].test(monthName)) {\n                return i;\n            } else if (strict && format === \"MMM\" && this._shortMonthsParse[i].test(monthName)) {\n                return i;\n            } else if (!strict && this._monthsParse[i].test(monthName)) {\n                return i;\n            }\n        }\n    }\n    // MOMENTS\n    function setMonth(mom, value) {\n        var dayOfMonth;\n        if (!mom.isValid()) {\n            // No op\n            return mom;\n        }\n        if (typeof value === \"string\") {\n            if (/^\\d+$/.test(value)) {\n                value = toInt(value);\n            } else {\n                value = mom.localeData().monthsParse(value);\n                // TODO: Another silent failure?\n                if (!isNumber(value)) {\n                    return mom;\n                }\n            }\n        }\n        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));\n        mom._d[\"set\" + (mom._isUTC ? \"UTC\" : \"\") + \"Month\"](value, dayOfMonth);\n        return mom;\n    }\n    function getSetMonth(value) {\n        if (value != null) {\n            setMonth(this, value);\n            hooks.updateOffset(this, true);\n            return this;\n        } else {\n            return get(this, \"Month\");\n        }\n    }\n    function getDaysInMonth() {\n        return daysInMonth(this.year(), this.month());\n    }\n    function monthsShortRegex(isStrict) {\n        if (this._monthsParseExact) {\n            if (!hasOwnProp(this, \"_monthsRegex\")) {\n                computeMonthsParse.call(this);\n            }\n            if (isStrict) {\n                return this._monthsShortStrictRegex;\n            } else {\n                return this._monthsShortRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, \"_monthsShortRegex\")) {\n                this._monthsShortRegex = defaultMonthsShortRegex;\n            }\n            return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;\n        }\n    }\n    function monthsRegex(isStrict) {\n        if (this._monthsParseExact) {\n            if (!hasOwnProp(this, \"_monthsRegex\")) {\n                computeMonthsParse.call(this);\n            }\n            if (isStrict) {\n                return this._monthsStrictRegex;\n            } else {\n                return this._monthsRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, \"_monthsRegex\")) {\n                this._monthsRegex = defaultMonthsRegex;\n            }\n            return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;\n        }\n    }\n    function computeMonthsParse() {\n        function cmpLenRev(a, b) {\n            return b.length - a.length;\n        }\n        var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;\n        for(i = 0; i < 12; i++){\n            // make the regex if we don't have it already\n            mom = createUTC([\n                2000,\n                i\n            ]);\n            shortPieces.push(this.monthsShort(mom, \"\"));\n            longPieces.push(this.months(mom, \"\"));\n            mixedPieces.push(this.months(mom, \"\"));\n            mixedPieces.push(this.monthsShort(mom, \"\"));\n        }\n        // Sorting makes sure if one month (or abbr) is a prefix of another it\n        // will match the longer piece.\n        shortPieces.sort(cmpLenRev);\n        longPieces.sort(cmpLenRev);\n        mixedPieces.sort(cmpLenRev);\n        for(i = 0; i < 12; i++){\n            shortPieces[i] = regexEscape(shortPieces[i]);\n            longPieces[i] = regexEscape(longPieces[i]);\n        }\n        for(i = 0; i < 24; i++){\n            mixedPieces[i] = regexEscape(mixedPieces[i]);\n        }\n        this._monthsRegex = new RegExp(\"^(\" + mixedPieces.join(\"|\") + \")\", \"i\");\n        this._monthsShortRegex = this._monthsRegex;\n        this._monthsStrictRegex = new RegExp(\"^(\" + longPieces.join(\"|\") + \")\", \"i\");\n        this._monthsShortStrictRegex = new RegExp(\"^(\" + shortPieces.join(\"|\") + \")\", \"i\");\n    }\n    // FORMATTING\n    addFormatToken(\"Y\", 0, 0, function() {\n        var y = this.year();\n        return y <= 9999 ? zeroFill(y, 4) : \"+\" + y;\n    });\n    addFormatToken(0, [\n        \"YY\",\n        2\n    ], 0, function() {\n        return this.year() % 100;\n    });\n    addFormatToken(0, [\n        \"YYYY\",\n        4\n    ], 0, \"year\");\n    addFormatToken(0, [\n        \"YYYYY\",\n        5\n    ], 0, \"year\");\n    addFormatToken(0, [\n        \"YYYYYY\",\n        6,\n        true\n    ], 0, \"year\");\n    // ALIASES\n    addUnitAlias(\"year\", \"y\");\n    // PRIORITIES\n    addUnitPriority(\"year\", 1);\n    // PARSING\n    addRegexToken(\"Y\", matchSigned);\n    addRegexToken(\"YY\", match1to2, match2);\n    addRegexToken(\"YYYY\", match1to4, match4);\n    addRegexToken(\"YYYYY\", match1to6, match6);\n    addRegexToken(\"YYYYYY\", match1to6, match6);\n    addParseToken([\n        \"YYYYY\",\n        \"YYYYYY\"\n    ], YEAR);\n    addParseToken(\"YYYY\", function(input, array) {\n        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);\n    });\n    addParseToken(\"YY\", function(input, array) {\n        array[YEAR] = hooks.parseTwoDigitYear(input);\n    });\n    addParseToken(\"Y\", function(input, array) {\n        array[YEAR] = parseInt(input, 10);\n    });\n    // HELPERS\n    function daysInYear(year) {\n        return isLeapYear(year) ? 366 : 365;\n    }\n    // HOOKS\n    hooks.parseTwoDigitYear = function(input) {\n        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);\n    };\n    // MOMENTS\n    var getSetYear = makeGetSet(\"FullYear\", true);\n    function getIsLeapYear() {\n        return isLeapYear(this.year());\n    }\n    function createDate(y, m, d, h, M, s, ms) {\n        // can't just apply() to create a date:\n        // https://stackoverflow.com/q/181348\n        var date;\n        // the date constructor remaps years 0-99 to 1900-1999\n        if (y < 100 && y >= 0) {\n            // preserve leap years using a full 400 year cycle, then reset\n            date = new Date(y + 400, m, d, h, M, s, ms);\n            if (isFinite(date.getFullYear())) {\n                date.setFullYear(y);\n            }\n        } else {\n            date = new Date(y, m, d, h, M, s, ms);\n        }\n        return date;\n    }\n    function createUTCDate(y) {\n        var date, args;\n        // the Date.UTC function remaps years 0-99 to 1900-1999\n        if (y < 100 && y >= 0) {\n            args = Array.prototype.slice.call(arguments);\n            // preserve leap years using a full 400 year cycle, then reset\n            args[0] = y + 400;\n            date = new Date(Date.UTC.apply(null, args));\n            if (isFinite(date.getUTCFullYear())) {\n                date.setUTCFullYear(y);\n            }\n        } else {\n            date = new Date(Date.UTC.apply(null, arguments));\n        }\n        return date;\n    }\n    // start-of-first-week - start-of-year\n    function firstWeekOffset(year, dow, doy) {\n        var fwd = 7 + dow - doy, // first-week day local weekday -- which local weekday is fwd\n        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;\n        return -fwdlw + fwd - 1;\n    }\n    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday\n    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {\n        var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;\n        if (dayOfYear <= 0) {\n            resYear = year - 1;\n            resDayOfYear = daysInYear(resYear) + dayOfYear;\n        } else if (dayOfYear > daysInYear(year)) {\n            resYear = year + 1;\n            resDayOfYear = dayOfYear - daysInYear(year);\n        } else {\n            resYear = year;\n            resDayOfYear = dayOfYear;\n        }\n        return {\n            year: resYear,\n            dayOfYear: resDayOfYear\n        };\n    }\n    function weekOfYear(mom, dow, doy) {\n        var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;\n        if (week < 1) {\n            resYear = mom.year() - 1;\n            resWeek = week + weeksInYear(resYear, dow, doy);\n        } else if (week > weeksInYear(mom.year(), dow, doy)) {\n            resWeek = week - weeksInYear(mom.year(), dow, doy);\n            resYear = mom.year() + 1;\n        } else {\n            resYear = mom.year();\n            resWeek = week;\n        }\n        return {\n            week: resWeek,\n            year: resYear\n        };\n    }\n    function weeksInYear(year, dow, doy) {\n        var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);\n        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;\n    }\n    // FORMATTING\n    addFormatToken(\"w\", [\n        \"ww\",\n        2\n    ], \"wo\", \"week\");\n    addFormatToken(\"W\", [\n        \"WW\",\n        2\n    ], \"Wo\", \"isoWeek\");\n    // ALIASES\n    addUnitAlias(\"week\", \"w\");\n    addUnitAlias(\"isoWeek\", \"W\");\n    // PRIORITIES\n    addUnitPriority(\"week\", 5);\n    addUnitPriority(\"isoWeek\", 5);\n    // PARSING\n    addRegexToken(\"w\", match1to2);\n    addRegexToken(\"ww\", match1to2, match2);\n    addRegexToken(\"W\", match1to2);\n    addRegexToken(\"WW\", match1to2, match2);\n    addWeekParseToken([\n        \"w\",\n        \"ww\",\n        \"W\",\n        \"WW\"\n    ], function(input, week, config, token) {\n        week[token.substr(0, 1)] = toInt(input);\n    });\n    // HELPERS\n    // LOCALES\n    function localeWeek(mom) {\n        return weekOfYear(mom, this._week.dow, this._week.doy).week;\n    }\n    var defaultLocaleWeek = {\n        dow: 0,\n        doy: 6\n    };\n    function localeFirstDayOfWeek() {\n        return this._week.dow;\n    }\n    function localeFirstDayOfYear() {\n        return this._week.doy;\n    }\n    // MOMENTS\n    function getSetWeek(input) {\n        var week = this.localeData().week(this);\n        return input == null ? week : this.add((input - week) * 7, \"d\");\n    }\n    function getSetISOWeek(input) {\n        var week = weekOfYear(this, 1, 4).week;\n        return input == null ? week : this.add((input - week) * 7, \"d\");\n    }\n    // FORMATTING\n    addFormatToken(\"d\", 0, \"do\", \"day\");\n    addFormatToken(\"dd\", 0, 0, function(format) {\n        return this.localeData().weekdaysMin(this, format);\n    });\n    addFormatToken(\"ddd\", 0, 0, function(format) {\n        return this.localeData().weekdaysShort(this, format);\n    });\n    addFormatToken(\"dddd\", 0, 0, function(format) {\n        return this.localeData().weekdays(this, format);\n    });\n    addFormatToken(\"e\", 0, 0, \"weekday\");\n    addFormatToken(\"E\", 0, 0, \"isoWeekday\");\n    // ALIASES\n    addUnitAlias(\"day\", \"d\");\n    addUnitAlias(\"weekday\", \"e\");\n    addUnitAlias(\"isoWeekday\", \"E\");\n    // PRIORITY\n    addUnitPriority(\"day\", 11);\n    addUnitPriority(\"weekday\", 11);\n    addUnitPriority(\"isoWeekday\", 11);\n    // PARSING\n    addRegexToken(\"d\", match1to2);\n    addRegexToken(\"e\", match1to2);\n    addRegexToken(\"E\", match1to2);\n    addRegexToken(\"dd\", function(isStrict, locale) {\n        return locale.weekdaysMinRegex(isStrict);\n    });\n    addRegexToken(\"ddd\", function(isStrict, locale) {\n        return locale.weekdaysShortRegex(isStrict);\n    });\n    addRegexToken(\"dddd\", function(isStrict, locale) {\n        return locale.weekdaysRegex(isStrict);\n    });\n    addWeekParseToken([\n        \"dd\",\n        \"ddd\",\n        \"dddd\"\n    ], function(input, week, config, token) {\n        var weekday = config._locale.weekdaysParse(input, token, config._strict);\n        // if we didn't get a weekday name, mark the date as invalid\n        if (weekday != null) {\n            week.d = weekday;\n        } else {\n            getParsingFlags(config).invalidWeekday = input;\n        }\n    });\n    addWeekParseToken([\n        \"d\",\n        \"e\",\n        \"E\"\n    ], function(input, week, config, token) {\n        week[token] = toInt(input);\n    });\n    // HELPERS\n    function parseWeekday(input, locale) {\n        if (typeof input !== \"string\") {\n            return input;\n        }\n        if (!isNaN(input)) {\n            return parseInt(input, 10);\n        }\n        input = locale.weekdaysParse(input);\n        if (typeof input === \"number\") {\n            return input;\n        }\n        return null;\n    }\n    function parseIsoWeekday(input, locale) {\n        if (typeof input === \"string\") {\n            return locale.weekdaysParse(input) % 7 || 7;\n        }\n        return isNaN(input) ? null : input;\n    }\n    // LOCALES\n    function shiftWeekdays(ws, n) {\n        return ws.slice(n, 7).concat(ws.slice(0, n));\n    }\n    var defaultLocaleWeekdays = \"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday\".split(\"_\"), defaultLocaleWeekdaysShort = \"Sun_Mon_Tue_Wed_Thu_Fri_Sat\".split(\"_\"), defaultLocaleWeekdaysMin = \"Su_Mo_Tu_We_Th_Fr_Sa\".split(\"_\"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;\n    function localeWeekdays(m, format) {\n        var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format) ? \"format\" : \"standalone\"];\n        return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;\n    }\n    function localeWeekdaysShort(m) {\n        return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;\n    }\n    function localeWeekdaysMin(m) {\n        return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;\n    }\n    function handleStrictParse$1(weekdayName, format, strict) {\n        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();\n        if (!this._weekdaysParse) {\n            this._weekdaysParse = [];\n            this._shortWeekdaysParse = [];\n            this._minWeekdaysParse = [];\n            for(i = 0; i < 7; ++i){\n                mom = createUTC([\n                    2000,\n                    1\n                ]).day(i);\n                this._minWeekdaysParse[i] = this.weekdaysMin(mom, \"\").toLocaleLowerCase();\n                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, \"\").toLocaleLowerCase();\n                this._weekdaysParse[i] = this.weekdays(mom, \"\").toLocaleLowerCase();\n            }\n        }\n        if (strict) {\n            if (format === \"dddd\") {\n                ii = indexOf.call(this._weekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else if (format === \"ddd\") {\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        } else {\n            if (format === \"dddd\") {\n                ii = indexOf.call(this._weekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else if (format === \"ddd\") {\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._weekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._weekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        }\n    }\n    function localeWeekdaysParse(weekdayName, format, strict) {\n        var i, mom, regex;\n        if (this._weekdaysParseExact) {\n            return handleStrictParse$1.call(this, weekdayName, format, strict);\n        }\n        if (!this._weekdaysParse) {\n            this._weekdaysParse = [];\n            this._minWeekdaysParse = [];\n            this._shortWeekdaysParse = [];\n            this._fullWeekdaysParse = [];\n        }\n        for(i = 0; i < 7; i++){\n            // make the regex if we don't have it already\n            mom = createUTC([\n                2000,\n                1\n            ]).day(i);\n            if (strict && !this._fullWeekdaysParse[i]) {\n                this._fullWeekdaysParse[i] = new RegExp(\"^\" + this.weekdays(mom, \"\").replace(\".\", \"\\\\.?\") + \"$\", \"i\");\n                this._shortWeekdaysParse[i] = new RegExp(\"^\" + this.weekdaysShort(mom, \"\").replace(\".\", \"\\\\.?\") + \"$\", \"i\");\n                this._minWeekdaysParse[i] = new RegExp(\"^\" + this.weekdaysMin(mom, \"\").replace(\".\", \"\\\\.?\") + \"$\", \"i\");\n            }\n            if (!this._weekdaysParse[i]) {\n                regex = \"^\" + this.weekdays(mom, \"\") + \"|^\" + this.weekdaysShort(mom, \"\") + \"|^\" + this.weekdaysMin(mom, \"\");\n                this._weekdaysParse[i] = new RegExp(regex.replace(\".\", \"\"), \"i\");\n            }\n            // test the regex\n            if (strict && format === \"dddd\" && this._fullWeekdaysParse[i].test(weekdayName)) {\n                return i;\n            } else if (strict && format === \"ddd\" && this._shortWeekdaysParse[i].test(weekdayName)) {\n                return i;\n            } else if (strict && format === \"dd\" && this._minWeekdaysParse[i].test(weekdayName)) {\n                return i;\n            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {\n                return i;\n            }\n        }\n    }\n    // MOMENTS\n    function getSetDayOfWeek(input) {\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();\n        if (input != null) {\n            input = parseWeekday(input, this.localeData());\n            return this.add(input - day, \"d\");\n        } else {\n            return day;\n        }\n    }\n    function getSetLocaleDayOfWeek(input) {\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;\n        return input == null ? weekday : this.add(input - weekday, \"d\");\n    }\n    function getSetISODayOfWeek(input) {\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n        // behaves the same as moment#day except\n        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)\n        // as a setter, sunday should belong to the previous week.\n        if (input != null) {\n            var weekday = parseIsoWeekday(input, this.localeData());\n            return this.day(this.day() % 7 ? weekday : weekday - 7);\n        } else {\n            return this.day() || 7;\n        }\n    }\n    function weekdaysRegex(isStrict) {\n        if (this._weekdaysParseExact) {\n            if (!hasOwnProp(this, \"_weekdaysRegex\")) {\n                computeWeekdaysParse.call(this);\n            }\n            if (isStrict) {\n                return this._weekdaysStrictRegex;\n            } else {\n                return this._weekdaysRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, \"_weekdaysRegex\")) {\n                this._weekdaysRegex = defaultWeekdaysRegex;\n            }\n            return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;\n        }\n    }\n    function weekdaysShortRegex(isStrict) {\n        if (this._weekdaysParseExact) {\n            if (!hasOwnProp(this, \"_weekdaysRegex\")) {\n                computeWeekdaysParse.call(this);\n            }\n            if (isStrict) {\n                return this._weekdaysShortStrictRegex;\n            } else {\n                return this._weekdaysShortRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, \"_weekdaysShortRegex\")) {\n                this._weekdaysShortRegex = defaultWeekdaysShortRegex;\n            }\n            return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;\n        }\n    }\n    function weekdaysMinRegex(isStrict) {\n        if (this._weekdaysParseExact) {\n            if (!hasOwnProp(this, \"_weekdaysRegex\")) {\n                computeWeekdaysParse.call(this);\n            }\n            if (isStrict) {\n                return this._weekdaysMinStrictRegex;\n            } else {\n                return this._weekdaysMinRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, \"_weekdaysMinRegex\")) {\n                this._weekdaysMinRegex = defaultWeekdaysMinRegex;\n            }\n            return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;\n        }\n    }\n    function computeWeekdaysParse() {\n        function cmpLenRev(a, b) {\n            return b.length - a.length;\n        }\n        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;\n        for(i = 0; i < 7; i++){\n            // make the regex if we don't have it already\n            mom = createUTC([\n                2000,\n                1\n            ]).day(i);\n            minp = regexEscape(this.weekdaysMin(mom, \"\"));\n            shortp = regexEscape(this.weekdaysShort(mom, \"\"));\n            longp = regexEscape(this.weekdays(mom, \"\"));\n            minPieces.push(minp);\n            shortPieces.push(shortp);\n            longPieces.push(longp);\n            mixedPieces.push(minp);\n            mixedPieces.push(shortp);\n            mixedPieces.push(longp);\n        }\n        // Sorting makes sure if one weekday (or abbr) is a prefix of another it\n        // will match the longer piece.\n        minPieces.sort(cmpLenRev);\n        shortPieces.sort(cmpLenRev);\n        longPieces.sort(cmpLenRev);\n        mixedPieces.sort(cmpLenRev);\n        this._weekdaysRegex = new RegExp(\"^(\" + mixedPieces.join(\"|\") + \")\", \"i\");\n        this._weekdaysShortRegex = this._weekdaysRegex;\n        this._weekdaysMinRegex = this._weekdaysRegex;\n        this._weekdaysStrictRegex = new RegExp(\"^(\" + longPieces.join(\"|\") + \")\", \"i\");\n        this._weekdaysShortStrictRegex = new RegExp(\"^(\" + shortPieces.join(\"|\") + \")\", \"i\");\n        this._weekdaysMinStrictRegex = new RegExp(\"^(\" + minPieces.join(\"|\") + \")\", \"i\");\n    }\n    // FORMATTING\n    function hFormat() {\n        return this.hours() % 12 || 12;\n    }\n    function kFormat() {\n        return this.hours() || 24;\n    }\n    addFormatToken(\"H\", [\n        \"HH\",\n        2\n    ], 0, \"hour\");\n    addFormatToken(\"h\", [\n        \"hh\",\n        2\n    ], 0, hFormat);\n    addFormatToken(\"k\", [\n        \"kk\",\n        2\n    ], 0, kFormat);\n    addFormatToken(\"hmm\", 0, 0, function() {\n        return \"\" + hFormat.apply(this) + zeroFill(this.minutes(), 2);\n    });\n    addFormatToken(\"hmmss\", 0, 0, function() {\n        return \"\" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);\n    });\n    addFormatToken(\"Hmm\", 0, 0, function() {\n        return \"\" + this.hours() + zeroFill(this.minutes(), 2);\n    });\n    addFormatToken(\"Hmmss\", 0, 0, function() {\n        return \"\" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);\n    });\n    function meridiem(token, lowercase) {\n        addFormatToken(token, 0, 0, function() {\n            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);\n        });\n    }\n    meridiem(\"a\", true);\n    meridiem(\"A\", false);\n    // ALIASES\n    addUnitAlias(\"hour\", \"h\");\n    // PRIORITY\n    addUnitPriority(\"hour\", 13);\n    // PARSING\n    function matchMeridiem(isStrict, locale) {\n        return locale._meridiemParse;\n    }\n    addRegexToken(\"a\", matchMeridiem);\n    addRegexToken(\"A\", matchMeridiem);\n    addRegexToken(\"H\", match1to2);\n    addRegexToken(\"h\", match1to2);\n    addRegexToken(\"k\", match1to2);\n    addRegexToken(\"HH\", match1to2, match2);\n    addRegexToken(\"hh\", match1to2, match2);\n    addRegexToken(\"kk\", match1to2, match2);\n    addRegexToken(\"hmm\", match3to4);\n    addRegexToken(\"hmmss\", match5to6);\n    addRegexToken(\"Hmm\", match3to4);\n    addRegexToken(\"Hmmss\", match5to6);\n    addParseToken([\n        \"H\",\n        \"HH\"\n    ], HOUR);\n    addParseToken([\n        \"k\",\n        \"kk\"\n    ], function(input, array, config) {\n        var kInput = toInt(input);\n        array[HOUR] = kInput === 24 ? 0 : kInput;\n    });\n    addParseToken([\n        \"a\",\n        \"A\"\n    ], function(input, array, config) {\n        config._isPm = config._locale.isPM(input);\n        config._meridiem = input;\n    });\n    addParseToken([\n        \"h\",\n        \"hh\"\n    ], function(input, array, config) {\n        array[HOUR] = toInt(input);\n        getParsingFlags(config).bigHour = true;\n    });\n    addParseToken(\"hmm\", function(input, array, config) {\n        var pos = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos));\n        array[MINUTE] = toInt(input.substr(pos));\n        getParsingFlags(config).bigHour = true;\n    });\n    addParseToken(\"hmmss\", function(input, array, config) {\n        var pos1 = input.length - 4, pos2 = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos1));\n        array[MINUTE] = toInt(input.substr(pos1, 2));\n        array[SECOND] = toInt(input.substr(pos2));\n        getParsingFlags(config).bigHour = true;\n    });\n    addParseToken(\"Hmm\", function(input, array, config) {\n        var pos = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos));\n        array[MINUTE] = toInt(input.substr(pos));\n    });\n    addParseToken(\"Hmmss\", function(input, array, config) {\n        var pos1 = input.length - 4, pos2 = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos1));\n        array[MINUTE] = toInt(input.substr(pos1, 2));\n        array[SECOND] = toInt(input.substr(pos2));\n    });\n    // LOCALES\n    function localeIsPM(input) {\n        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays\n        // Using charAt should be more compatible.\n        return (input + \"\").toLowerCase().charAt(0) === \"p\";\n    }\n    var defaultLocaleMeridiemParse = /[ap]\\.?m?\\.?/i, // Setting the hour should keep the time, because the user explicitly\n    // specified which hour they want. So trying to maintain the same hour (in\n    // a new timezone) makes sense. Adding/subtracting hours does not follow\n    // this rule.\n    getSetHour = makeGetSet(\"Hours\", true);\n    function localeMeridiem(hours, minutes, isLower) {\n        if (hours > 11) {\n            return isLower ? \"pm\" : \"PM\";\n        } else {\n            return isLower ? \"am\" : \"AM\";\n        }\n    }\n    var baseConfig = {\n        calendar: defaultCalendar,\n        longDateFormat: defaultLongDateFormat,\n        invalidDate: defaultInvalidDate,\n        ordinal: defaultOrdinal,\n        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,\n        relativeTime: defaultRelativeTime,\n        months: defaultLocaleMonths,\n        monthsShort: defaultLocaleMonthsShort,\n        week: defaultLocaleWeek,\n        weekdays: defaultLocaleWeekdays,\n        weekdaysMin: defaultLocaleWeekdaysMin,\n        weekdaysShort: defaultLocaleWeekdaysShort,\n        meridiemParse: defaultLocaleMeridiemParse\n    };\n    // internal storage for locale config files\n    var locales = {}, localeFamilies = {}, globalLocale;\n    function commonPrefix(arr1, arr2) {\n        var i, minl = Math.min(arr1.length, arr2.length);\n        for(i = 0; i < minl; i += 1){\n            if (arr1[i] !== arr2[i]) {\n                return i;\n            }\n        }\n        return minl;\n    }\n    function normalizeLocale(key) {\n        return key ? key.toLowerCase().replace(\"_\", \"-\") : key;\n    }\n    // pick the locale from the array\n    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each\n    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root\n    function chooseLocale(names) {\n        var i = 0, j, next, locale, split;\n        while(i < names.length){\n            split = normalizeLocale(names[i]).split(\"-\");\n            j = split.length;\n            next = normalizeLocale(names[i + 1]);\n            next = next ? next.split(\"-\") : null;\n            while(j > 0){\n                locale = loadLocale(split.slice(0, j).join(\"-\"));\n                if (locale) {\n                    return locale;\n                }\n                if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {\n                    break;\n                }\n                j--;\n            }\n            i++;\n        }\n        return globalLocale;\n    }\n    function isLocaleNameSane(name) {\n        // Prevent names that look like filesystem paths, i.e contain '/' or '\\'\n        return name.match(\"^[^/\\\\\\\\]*$\") != null;\n    }\n    function loadLocale(name) {\n        var oldLocale = null, aliasedRequire;\n        // TODO: Find a better way to register and load all the locales in Node\n        if (locales[name] === undefined && \"object\" !== \"undefined\" && module && module.exports && isLocaleNameSane(name)) {\n            try {\n                oldLocale = globalLocale._abbr;\n                aliasedRequire = undefined;\n                Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'undefined'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n                getSetGlobalLocale(oldLocale);\n            } catch (e) {\n                // mark as not found to avoid repeating expensive file require call causing high CPU\n                // when trying to find en-US, en_US, en-us for every format call\n                locales[name] = null; // null means not found\n            }\n        }\n        return locales[name];\n    }\n    // This function will load locale and then set the global locale.  If\n    // no arguments are passed in, it will simply return the current global\n    // locale key.\n    function getSetGlobalLocale(key, values) {\n        var data;\n        if (key) {\n            if (isUndefined(values)) {\n                data = getLocale(key);\n            } else {\n                data = defineLocale(key, values);\n            }\n            if (data) {\n                // moment.duration._locale = moment._locale = data;\n                globalLocale = data;\n            } else {\n                if (typeof console !== \"undefined\" && console.warn) {\n                    //warn user if arguments are passed but the locale could not be set\n                    console.warn(\"Locale \" + key + \" not found. Did you forget to load it?\");\n                }\n            }\n        }\n        return globalLocale._abbr;\n    }\n    function defineLocale(name, config) {\n        if (config !== null) {\n            var locale, parentConfig = baseConfig;\n            config.abbr = name;\n            if (locales[name] != null) {\n                deprecateSimple(\"defineLocaleOverride\", \"use moment.updateLocale(localeName, config) to change \" + \"an existing locale. moment.defineLocale(localeName, \" + \"config) should only be used for creating a new locale \" + \"See http://momentjs.com/guides/#/warnings/define-locale/ for more info.\");\n                parentConfig = locales[name]._config;\n            } else if (config.parentLocale != null) {\n                if (locales[config.parentLocale] != null) {\n                    parentConfig = locales[config.parentLocale]._config;\n                } else {\n                    locale = loadLocale(config.parentLocale);\n                    if (locale != null) {\n                        parentConfig = locale._config;\n                    } else {\n                        if (!localeFamilies[config.parentLocale]) {\n                            localeFamilies[config.parentLocale] = [];\n                        }\n                        localeFamilies[config.parentLocale].push({\n                            name: name,\n                            config: config\n                        });\n                        return null;\n                    }\n                }\n            }\n            locales[name] = new Locale(mergeConfigs(parentConfig, config));\n            if (localeFamilies[name]) {\n                localeFamilies[name].forEach(function(x) {\n                    defineLocale(x.name, x.config);\n                });\n            }\n            // backwards compat for now: also set the locale\n            // make sure we set the locale AFTER all child locales have been\n            // created, so we won't end up with the child locale set.\n            getSetGlobalLocale(name);\n            return locales[name];\n        } else {\n            // useful for testing\n            delete locales[name];\n            return null;\n        }\n    }\n    function updateLocale(name, config) {\n        if (config != null) {\n            var locale, tmpLocale, parentConfig = baseConfig;\n            if (locales[name] != null && locales[name].parentLocale != null) {\n                // Update existing child locale in-place to avoid memory-leaks\n                locales[name].set(mergeConfigs(locales[name]._config, config));\n            } else {\n                // MERGE\n                tmpLocale = loadLocale(name);\n                if (tmpLocale != null) {\n                    parentConfig = tmpLocale._config;\n                }\n                config = mergeConfigs(parentConfig, config);\n                if (tmpLocale == null) {\n                    // updateLocale is called for creating a new locale\n                    // Set abbr so it will have a name (getters return\n                    // undefined otherwise).\n                    config.abbr = name;\n                }\n                locale = new Locale(config);\n                locale.parentLocale = locales[name];\n                locales[name] = locale;\n            }\n            // backwards compat for now: also set the locale\n            getSetGlobalLocale(name);\n        } else {\n            // pass null for config to unupdate, useful for tests\n            if (locales[name] != null) {\n                if (locales[name].parentLocale != null) {\n                    locales[name] = locales[name].parentLocale;\n                    if (name === getSetGlobalLocale()) {\n                        getSetGlobalLocale(name);\n                    }\n                } else if (locales[name] != null) {\n                    delete locales[name];\n                }\n            }\n        }\n        return locales[name];\n    }\n    // returns locale data\n    function getLocale(key) {\n        var locale;\n        if (key && key._locale && key._locale._abbr) {\n            key = key._locale._abbr;\n        }\n        if (!key) {\n            return globalLocale;\n        }\n        if (!isArray(key)) {\n            //short-circuit everything else\n            locale = loadLocale(key);\n            if (locale) {\n                return locale;\n            }\n            key = [\n                key\n            ];\n        }\n        return chooseLocale(key);\n    }\n    function listLocales() {\n        return keys(locales);\n    }\n    function checkOverflow(m) {\n        var overflow, a = m._a;\n        if (a && getParsingFlags(m).overflow === -2) {\n            overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;\n            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {\n                overflow = DATE;\n            }\n            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {\n                overflow = WEEK;\n            }\n            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {\n                overflow = WEEKDAY;\n            }\n            getParsingFlags(m).overflow = overflow;\n        }\n        return m;\n    }\n    // iso 8601 regex\n    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)\n    var extendedIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})-(?:\\d\\d-\\d\\d|W\\d\\d-\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?::\\d\\d(?::\\d\\d(?:[.,]\\d+)?)?)?)([+-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/, basicIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})(?:\\d\\d\\d\\d|W\\d\\d\\d|W\\d\\d|\\d\\d\\d|\\d\\d|))(?:(T| )(\\d\\d(?:\\d\\d(?:\\d\\d(?:[.,]\\d+)?)?)?)([+-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/, tzRegex = /Z|[+-]\\d\\d(?::?\\d\\d)?/, isoDates = [\n        [\n            \"YYYYYY-MM-DD\",\n            /[+-]\\d{6}-\\d\\d-\\d\\d/\n        ],\n        [\n            \"YYYY-MM-DD\",\n            /\\d{4}-\\d\\d-\\d\\d/\n        ],\n        [\n            \"GGGG-[W]WW-E\",\n            /\\d{4}-W\\d\\d-\\d/\n        ],\n        [\n            \"GGGG-[W]WW\",\n            /\\d{4}-W\\d\\d/,\n            false\n        ],\n        [\n            \"YYYY-DDD\",\n            /\\d{4}-\\d{3}/\n        ],\n        [\n            \"YYYY-MM\",\n            /\\d{4}-\\d\\d/,\n            false\n        ],\n        [\n            \"YYYYYYMMDD\",\n            /[+-]\\d{10}/\n        ],\n        [\n            \"YYYYMMDD\",\n            /\\d{8}/\n        ],\n        [\n            \"GGGG[W]WWE\",\n            /\\d{4}W\\d{3}/\n        ],\n        [\n            \"GGGG[W]WW\",\n            /\\d{4}W\\d{2}/,\n            false\n        ],\n        [\n            \"YYYYDDD\",\n            /\\d{7}/\n        ],\n        [\n            \"YYYYMM\",\n            /\\d{6}/,\n            false\n        ],\n        [\n            \"YYYY\",\n            /\\d{4}/,\n            false\n        ]\n    ], // iso time formats and regexes\n    isoTimes = [\n        [\n            \"HH:mm:ss.SSSS\",\n            /\\d\\d:\\d\\d:\\d\\d\\.\\d+/\n        ],\n        [\n            \"HH:mm:ss,SSSS\",\n            /\\d\\d:\\d\\d:\\d\\d,\\d+/\n        ],\n        [\n            \"HH:mm:ss\",\n            /\\d\\d:\\d\\d:\\d\\d/\n        ],\n        [\n            \"HH:mm\",\n            /\\d\\d:\\d\\d/\n        ],\n        [\n            \"HHmmss.SSSS\",\n            /\\d\\d\\d\\d\\d\\d\\.\\d+/\n        ],\n        [\n            \"HHmmss,SSSS\",\n            /\\d\\d\\d\\d\\d\\d,\\d+/\n        ],\n        [\n            \"HHmmss\",\n            /\\d\\d\\d\\d\\d\\d/\n        ],\n        [\n            \"HHmm\",\n            /\\d\\d\\d\\d/\n        ],\n        [\n            \"HH\",\n            /\\d\\d/\n        ]\n    ], aspNetJsonRegex = /^\\/?Date\\((-?\\d+)/i, // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3\n    rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\\s)?(\\d{1,2})\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s(\\d{2,4})\\s(\\d\\d):(\\d\\d)(?::(\\d\\d))?\\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\\d{4}))$/, obsOffsets = {\n        UT: 0,\n        GMT: 0,\n        EDT: -4 * 60,\n        EST: -5 * 60,\n        CDT: -5 * 60,\n        CST: -6 * 60,\n        MDT: -6 * 60,\n        MST: -7 * 60,\n        PDT: -7 * 60,\n        PST: -8 * 60\n    };\n    // date from iso format\n    function configFromISO(config) {\n        var i, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;\n        if (match) {\n            getParsingFlags(config).iso = true;\n            for(i = 0, l = isoDatesLen; i < l; i++){\n                if (isoDates[i][1].exec(match[1])) {\n                    dateFormat = isoDates[i][0];\n                    allowTime = isoDates[i][2] !== false;\n                    break;\n                }\n            }\n            if (dateFormat == null) {\n                config._isValid = false;\n                return;\n            }\n            if (match[3]) {\n                for(i = 0, l = isoTimesLen; i < l; i++){\n                    if (isoTimes[i][1].exec(match[3])) {\n                        // match[2] should be 'T' or space\n                        timeFormat = (match[2] || \" \") + isoTimes[i][0];\n                        break;\n                    }\n                }\n                if (timeFormat == null) {\n                    config._isValid = false;\n                    return;\n                }\n            }\n            if (!allowTime && timeFormat != null) {\n                config._isValid = false;\n                return;\n            }\n            if (match[4]) {\n                if (tzRegex.exec(match[4])) {\n                    tzFormat = \"Z\";\n                } else {\n                    config._isValid = false;\n                    return;\n                }\n            }\n            config._f = dateFormat + (timeFormat || \"\") + (tzFormat || \"\");\n            configFromStringAndFormat(config);\n        } else {\n            config._isValid = false;\n        }\n    }\n    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {\n        var result = [\n            untruncateYear(yearStr),\n            defaultLocaleMonthsShort.indexOf(monthStr),\n            parseInt(dayStr, 10),\n            parseInt(hourStr, 10),\n            parseInt(minuteStr, 10)\n        ];\n        if (secondStr) {\n            result.push(parseInt(secondStr, 10));\n        }\n        return result;\n    }\n    function untruncateYear(yearStr) {\n        var year = parseInt(yearStr, 10);\n        if (year <= 49) {\n            return 2000 + year;\n        } else if (year <= 999) {\n            return 1900 + year;\n        }\n        return year;\n    }\n    function preprocessRFC2822(s) {\n        // Remove comments and folding whitespace and replace multiple-spaces with a single space\n        return s.replace(/\\([^()]*\\)|[\\n\\t]/g, \" \").replace(/(\\s\\s+)/g, \" \").replace(/^\\s\\s*/, \"\").replace(/\\s\\s*$/, \"\");\n    }\n    function checkWeekday(weekdayStr, parsedInput, config) {\n        if (weekdayStr) {\n            // TODO: Replace the vanilla JS Date object with an independent day-of-week check.\n            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();\n            if (weekdayProvided !== weekdayActual) {\n                getParsingFlags(config).weekdayMismatch = true;\n                config._isValid = false;\n                return false;\n            }\n        }\n        return true;\n    }\n    function calculateOffset(obsOffset, militaryOffset, numOffset) {\n        if (obsOffset) {\n            return obsOffsets[obsOffset];\n        } else if (militaryOffset) {\n            // the only allowed military tz is Z\n            return 0;\n        } else {\n            var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;\n            return h * 60 + m;\n        }\n    }\n    // date and time from ref 2822 format\n    function configFromRFC2822(config) {\n        var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;\n        if (match) {\n            parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);\n            if (!checkWeekday(match[1], parsedArray, config)) {\n                return;\n            }\n            config._a = parsedArray;\n            config._tzm = calculateOffset(match[8], match[9], match[10]);\n            config._d = createUTCDate.apply(null, config._a);\n            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n            getParsingFlags(config).rfc2822 = true;\n        } else {\n            config._isValid = false;\n        }\n    }\n    // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict\n    function configFromString(config) {\n        var matched = aspNetJsonRegex.exec(config._i);\n        if (matched !== null) {\n            config._d = new Date(+matched[1]);\n            return;\n        }\n        configFromISO(config);\n        if (config._isValid === false) {\n            delete config._isValid;\n        } else {\n            return;\n        }\n        configFromRFC2822(config);\n        if (config._isValid === false) {\n            delete config._isValid;\n        } else {\n            return;\n        }\n        if (config._strict) {\n            config._isValid = false;\n        } else {\n            // Final attempt, use Input Fallback\n            hooks.createFromInputFallback(config);\n        }\n    }\n    hooks.createFromInputFallback = deprecate(\"value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), \" + \"which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are \" + \"discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.\", function(config) {\n        config._d = new Date(config._i + (config._useUTC ? \" UTC\" : \"\"));\n    });\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n    function currentDateArray(config) {\n        // hooks is actually the exported moment object\n        var nowValue = new Date(hooks.now());\n        if (config._useUTC) {\n            return [\n                nowValue.getUTCFullYear(),\n                nowValue.getUTCMonth(),\n                nowValue.getUTCDate()\n            ];\n        }\n        return [\n            nowValue.getFullYear(),\n            nowValue.getMonth(),\n            nowValue.getDate()\n        ];\n    }\n    // convert an array to a date.\n    // the array should mirror the parameters below\n    // note: all values past the year are optional and will default to the lowest possible value.\n    // [year, month, day , hour, minute, second, millisecond]\n    function configFromArray(config) {\n        var i, date, input = [], currentDate, expectedWeekday, yearToUse;\n        if (config._d) {\n            return;\n        }\n        currentDate = currentDateArray(config);\n        //compute day of the year from weeks and weekdays\n        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {\n            dayOfYearFromWeekInfo(config);\n        }\n        //if the day of the year is set, figure out what it is\n        if (config._dayOfYear != null) {\n            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);\n            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {\n                getParsingFlags(config)._overflowDayOfYear = true;\n            }\n            date = createUTCDate(yearToUse, 0, config._dayOfYear);\n            config._a[MONTH] = date.getUTCMonth();\n            config._a[DATE] = date.getUTCDate();\n        }\n        // Default to current date.\n        // * if no year, month, day of month are given, default to today\n        // * if day of month is given, default month and year\n        // * if month is given, default only year\n        // * if year is given, don't default anything\n        for(i = 0; i < 3 && config._a[i] == null; ++i){\n            config._a[i] = input[i] = currentDate[i];\n        }\n        // Zero out whatever was not defaulted, including time\n        for(; i < 7; i++){\n            config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];\n        }\n        // Check for 24:00:00.000\n        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {\n            config._nextDay = true;\n            config._a[HOUR] = 0;\n        }\n        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);\n        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();\n        // Apply timezone offset from input. The actual utcOffset can be changed\n        // with parseZone.\n        if (config._tzm != null) {\n            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n        }\n        if (config._nextDay) {\n            config._a[HOUR] = 24;\n        }\n        // check for mismatching day of week\n        if (config._w && typeof config._w.d !== \"undefined\" && config._w.d !== expectedWeekday) {\n            getParsingFlags(config).weekdayMismatch = true;\n        }\n    }\n    function dayOfYearFromWeekInfo(config) {\n        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;\n        w = config._w;\n        if (w.GG != null || w.W != null || w.E != null) {\n            dow = 1;\n            doy = 4;\n            // TODO: We need to take the current isoWeekYear, but that depends on\n            // how we interpret now (local, utc, fixed offset). So create\n            // a now version of current config (take local/utc/offset flags, and\n            // create now).\n            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);\n            week = defaults(w.W, 1);\n            weekday = defaults(w.E, 1);\n            if (weekday < 1 || weekday > 7) {\n                weekdayOverflow = true;\n            }\n        } else {\n            dow = config._locale._week.dow;\n            doy = config._locale._week.doy;\n            curWeek = weekOfYear(createLocal(), dow, doy);\n            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);\n            // Default to current week.\n            week = defaults(w.w, curWeek.week);\n            if (w.d != null) {\n                // weekday -- low day numbers are considered next week\n                weekday = w.d;\n                if (weekday < 0 || weekday > 6) {\n                    weekdayOverflow = true;\n                }\n            } else if (w.e != null) {\n                // local weekday -- counting starts from beginning of week\n                weekday = w.e + dow;\n                if (w.e < 0 || w.e > 6) {\n                    weekdayOverflow = true;\n                }\n            } else {\n                // default to beginning of week\n                weekday = dow;\n            }\n        }\n        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {\n            getParsingFlags(config)._overflowWeeks = true;\n        } else if (weekdayOverflow != null) {\n            getParsingFlags(config)._overflowWeekday = true;\n        } else {\n            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);\n            config._a[YEAR] = temp.year;\n            config._dayOfYear = temp.dayOfYear;\n        }\n    }\n    // constant that refers to the ISO standard\n    hooks.ISO_8601 = function() {};\n    // constant that refers to the RFC 2822 form\n    hooks.RFC_2822 = function() {};\n    // date from string and format string\n    function configFromStringAndFormat(config) {\n        // TODO: Move this to another part of the creation flow to prevent circular deps\n        if (config._f === hooks.ISO_8601) {\n            configFromISO(config);\n            return;\n        }\n        if (config._f === hooks.RFC_2822) {\n            configFromRFC2822(config);\n            return;\n        }\n        config._a = [];\n        getParsingFlags(config).empty = true;\n        // This array is used to make a Date, either with `new Date` or `Date.UTC`\n        var string = \"\" + config._i, i, parsedInput, tokens, token, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;\n        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];\n        tokenLen = tokens.length;\n        for(i = 0; i < tokenLen; i++){\n            token = tokens[i];\n            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];\n            if (parsedInput) {\n                skipped = string.substr(0, string.indexOf(parsedInput));\n                if (skipped.length > 0) {\n                    getParsingFlags(config).unusedInput.push(skipped);\n                }\n                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);\n                totalParsedInputLength += parsedInput.length;\n            }\n            // don't parse if it's not a known token\n            if (formatTokenFunctions[token]) {\n                if (parsedInput) {\n                    getParsingFlags(config).empty = false;\n                } else {\n                    getParsingFlags(config).unusedTokens.push(token);\n                }\n                addTimeToArrayFromToken(token, parsedInput, config);\n            } else if (config._strict && !parsedInput) {\n                getParsingFlags(config).unusedTokens.push(token);\n            }\n        }\n        // add remaining unparsed input length to the string\n        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;\n        if (string.length > 0) {\n            getParsingFlags(config).unusedInput.push(string);\n        }\n        // clear _12h flag if hour is <= 12\n        if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {\n            getParsingFlags(config).bigHour = undefined;\n        }\n        getParsingFlags(config).parsedDateParts = config._a.slice(0);\n        getParsingFlags(config).meridiem = config._meridiem;\n        // handle meridiem\n        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);\n        // handle era\n        era = getParsingFlags(config).era;\n        if (era !== null) {\n            config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);\n        }\n        configFromArray(config);\n        checkOverflow(config);\n    }\n    function meridiemFixWrap(locale, hour, meridiem) {\n        var isPm;\n        if (meridiem == null) {\n            // nothing to do\n            return hour;\n        }\n        if (locale.meridiemHour != null) {\n            return locale.meridiemHour(hour, meridiem);\n        } else if (locale.isPM != null) {\n            // Fallback\n            isPm = locale.isPM(meridiem);\n            if (isPm && hour < 12) {\n                hour += 12;\n            }\n            if (!isPm && hour === 12) {\n                hour = 0;\n            }\n            return hour;\n        } else {\n            // this is not supposed to happen\n            return hour;\n        }\n    }\n    // date from string and array of format strings\n    function configFromStringAndArray(config) {\n        var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;\n        if (configfLen === 0) {\n            getParsingFlags(config).invalidFormat = true;\n            config._d = new Date(NaN);\n            return;\n        }\n        for(i = 0; i < configfLen; i++){\n            currentScore = 0;\n            validFormatFound = false;\n            tempConfig = copyConfig({}, config);\n            if (config._useUTC != null) {\n                tempConfig._useUTC = config._useUTC;\n            }\n            tempConfig._f = config._f[i];\n            configFromStringAndFormat(tempConfig);\n            if (isValid(tempConfig)) {\n                validFormatFound = true;\n            }\n            // if there is any input that was not parsed add a penalty for that format\n            currentScore += getParsingFlags(tempConfig).charsLeftOver;\n            //or tokens\n            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;\n            getParsingFlags(tempConfig).score = currentScore;\n            if (!bestFormatIsValid) {\n                if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {\n                    scoreToBeat = currentScore;\n                    bestMoment = tempConfig;\n                    if (validFormatFound) {\n                        bestFormatIsValid = true;\n                    }\n                }\n            } else {\n                if (currentScore < scoreToBeat) {\n                    scoreToBeat = currentScore;\n                    bestMoment = tempConfig;\n                }\n            }\n        }\n        extend(config, bestMoment || tempConfig);\n    }\n    function configFromObject(config) {\n        if (config._d) {\n            return;\n        }\n        var i = normalizeObjectUnits(config._i), dayOrDate = i.day === undefined ? i.date : i.day;\n        config._a = map([\n            i.year,\n            i.month,\n            dayOrDate,\n            i.hour,\n            i.minute,\n            i.second,\n            i.millisecond\n        ], function(obj) {\n            return obj && parseInt(obj, 10);\n        });\n        configFromArray(config);\n    }\n    function createFromConfig(config) {\n        var res = new Moment(checkOverflow(prepareConfig(config)));\n        if (res._nextDay) {\n            // Adding is smart enough around DST\n            res.add(1, \"d\");\n            res._nextDay = undefined;\n        }\n        return res;\n    }\n    function prepareConfig(config) {\n        var input = config._i, format = config._f;\n        config._locale = config._locale || getLocale(config._l);\n        if (input === null || format === undefined && input === \"\") {\n            return createInvalid({\n                nullInput: true\n            });\n        }\n        if (typeof input === \"string\") {\n            config._i = input = config._locale.preparse(input);\n        }\n        if (isMoment(input)) {\n            return new Moment(checkOverflow(input));\n        } else if (isDate(input)) {\n            config._d = input;\n        } else if (isArray(format)) {\n            configFromStringAndArray(config);\n        } else if (format) {\n            configFromStringAndFormat(config);\n        } else {\n            configFromInput(config);\n        }\n        if (!isValid(config)) {\n            config._d = null;\n        }\n        return config;\n    }\n    function configFromInput(config) {\n        var input = config._i;\n        if (isUndefined(input)) {\n            config._d = new Date(hooks.now());\n        } else if (isDate(input)) {\n            config._d = new Date(input.valueOf());\n        } else if (typeof input === \"string\") {\n            configFromString(config);\n        } else if (isArray(input)) {\n            config._a = map(input.slice(0), function(obj) {\n                return parseInt(obj, 10);\n            });\n            configFromArray(config);\n        } else if (isObject(input)) {\n            configFromObject(config);\n        } else if (isNumber(input)) {\n            // from milliseconds\n            config._d = new Date(input);\n        } else {\n            hooks.createFromInputFallback(config);\n        }\n    }\n    function createLocalOrUTC(input, format, locale, strict, isUTC) {\n        var c = {};\n        if (format === true || format === false) {\n            strict = format;\n            format = undefined;\n        }\n        if (locale === true || locale === false) {\n            strict = locale;\n            locale = undefined;\n        }\n        if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {\n            input = undefined;\n        }\n        // object construction must be done this way.\n        // https://github.com/moment/moment/issues/1423\n        c._isAMomentObject = true;\n        c._useUTC = c._isUTC = isUTC;\n        c._l = locale;\n        c._i = input;\n        c._f = format;\n        c._strict = strict;\n        return createFromConfig(c);\n    }\n    function createLocal(input, format, locale, strict) {\n        return createLocalOrUTC(input, format, locale, strict, false);\n    }\n    var prototypeMin = deprecate(\"moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/\", function() {\n        var other = createLocal.apply(null, arguments);\n        if (this.isValid() && other.isValid()) {\n            return other < this ? this : other;\n        } else {\n            return createInvalid();\n        }\n    }), prototypeMax = deprecate(\"moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/\", function() {\n        var other = createLocal.apply(null, arguments);\n        if (this.isValid() && other.isValid()) {\n            return other > this ? this : other;\n        } else {\n            return createInvalid();\n        }\n    });\n    // Pick a moment m from moments so that m[fn](other) is true for all\n    // other. This relies on the function fn to be transitive.\n    //\n    // moments should either be an array of moment objects or an array, whose\n    // first element is an array of moment objects.\n    function pickBy(fn, moments) {\n        var res, i;\n        if (moments.length === 1 && isArray(moments[0])) {\n            moments = moments[0];\n        }\n        if (!moments.length) {\n            return createLocal();\n        }\n        res = moments[0];\n        for(i = 1; i < moments.length; ++i){\n            if (!moments[i].isValid() || moments[i][fn](res)) {\n                res = moments[i];\n            }\n        }\n        return res;\n    }\n    // TODO: Use [].sort instead?\n    function min() {\n        var args = [].slice.call(arguments, 0);\n        return pickBy(\"isBefore\", args);\n    }\n    function max() {\n        var args = [].slice.call(arguments, 0);\n        return pickBy(\"isAfter\", args);\n    }\n    var now = function() {\n        return Date.now ? Date.now() : +new Date();\n    };\n    var ordering = [\n        \"year\",\n        \"quarter\",\n        \"month\",\n        \"week\",\n        \"day\",\n        \"hour\",\n        \"minute\",\n        \"second\",\n        \"millisecond\"\n    ];\n    function isDurationValid(m) {\n        var key, unitHasDecimal = false, i, orderLen = ordering.length;\n        for(key in m){\n            if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {\n                return false;\n            }\n        }\n        for(i = 0; i < orderLen; ++i){\n            if (m[ordering[i]]) {\n                if (unitHasDecimal) {\n                    return false; // only allow non-integers for smallest unit\n                }\n                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {\n                    unitHasDecimal = true;\n                }\n            }\n        }\n        return true;\n    }\n    function isValid$1() {\n        return this._isValid;\n    }\n    function createInvalid$1() {\n        return createDuration(NaN);\n    }\n    function Duration(duration) {\n        var normalizedInput = normalizeObjectUnits(duration), years = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months = normalizedInput.month || 0, weeks = normalizedInput.week || normalizedInput.isoWeek || 0, days = normalizedInput.day || 0, hours = normalizedInput.hour || 0, minutes = normalizedInput.minute || 0, seconds = normalizedInput.second || 0, milliseconds = normalizedInput.millisecond || 0;\n        this._isValid = isDurationValid(normalizedInput);\n        // representation for dateAddRemove\n        this._milliseconds = +milliseconds + seconds * 1e3 + // 1000\n        minutes * 6e4 + // 1000 * 60\n        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978\n        // Because of dateAddRemove treats 24 hours as different from a\n        // day when working around DST, we need to store them separately\n        this._days = +days + weeks * 7;\n        // It is impossible to translate months into days without knowing\n        // which months you are are talking about, so we have to store\n        // it separately.\n        this._months = +months + quarters * 3 + years * 12;\n        this._data = {};\n        this._locale = getLocale();\n        this._bubble();\n    }\n    function isDuration(obj) {\n        return obj instanceof Duration;\n    }\n    function absRound(number) {\n        if (number < 0) {\n            return Math.round(-1 * number) * -1;\n        } else {\n            return Math.round(number);\n        }\n    }\n    // compare two arrays, return the number of differences\n    function compareArrays(array1, array2, dontConvert) {\n        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;\n        for(i = 0; i < len; i++){\n            if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {\n                diffs++;\n            }\n        }\n        return diffs + lengthDiff;\n    }\n    // FORMATTING\n    function offset(token, separator) {\n        addFormatToken(token, 0, 0, function() {\n            var offset = this.utcOffset(), sign = \"+\";\n            if (offset < 0) {\n                offset = -offset;\n                sign = \"-\";\n            }\n            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);\n        });\n    }\n    offset(\"Z\", \":\");\n    offset(\"ZZ\", \"\");\n    // PARSING\n    addRegexToken(\"Z\", matchShortOffset);\n    addRegexToken(\"ZZ\", matchShortOffset);\n    addParseToken([\n        \"Z\",\n        \"ZZ\"\n    ], function(input, array, config) {\n        config._useUTC = true;\n        config._tzm = offsetFromString(matchShortOffset, input);\n    });\n    // HELPERS\n    // timezone chunker\n    // '+10:00' > ['10',  '00']\n    // '-1530'  > ['-15', '30']\n    var chunkOffset = /([\\+\\-]|\\d\\d)/gi;\n    function offsetFromString(matcher, string) {\n        var matches = (string || \"\").match(matcher), chunk, parts, minutes;\n        if (matches === null) {\n            return null;\n        }\n        chunk = matches[matches.length - 1] || [];\n        parts = (chunk + \"\").match(chunkOffset) || [\n            \"-\",\n            0,\n            0\n        ];\n        minutes = +(parts[1] * 60) + toInt(parts[2]);\n        return minutes === 0 ? 0 : parts[0] === \"+\" ? minutes : -minutes;\n    }\n    // Return a moment from input, that is local/utc/zone equivalent to model.\n    function cloneWithOffset(input, model) {\n        var res, diff;\n        if (model._isUTC) {\n            res = model.clone();\n            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();\n            // Use low-level api, because this fn is low-level api.\n            res._d.setTime(res._d.valueOf() + diff);\n            hooks.updateOffset(res, false);\n            return res;\n        } else {\n            return createLocal(input).local();\n        }\n    }\n    function getDateOffset(m) {\n        // On Firefox.24 Date#getTimezoneOffset returns a floating point.\n        // https://github.com/moment/moment/pull/1871\n        return -Math.round(m._d.getTimezoneOffset());\n    }\n    // HOOKS\n    // This function will be called whenever a moment is mutated.\n    // It is intended to keep the offset in sync with the timezone.\n    hooks.updateOffset = function() {};\n    // MOMENTS\n    // keepLocalTime = true means only change the timezone, without\n    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->\n    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset\n    // +0200, so we adjust the time as needed, to be valid.\n    //\n    // Keeping the time actually adds/subtracts (one hour)\n    // from the actual represented time. That is why we call updateOffset\n    // a second time. In case it wants us to change the offset again\n    // _changeInProgress == true case, then we have to adjust, because\n    // there is no such time in the given timezone.\n    function getSetOffset(input, keepLocalTime, keepMinutes) {\n        var offset = this._offset || 0, localAdjust;\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n        if (input != null) {\n            if (typeof input === \"string\") {\n                input = offsetFromString(matchShortOffset, input);\n                if (input === null) {\n                    return this;\n                }\n            } else if (Math.abs(input) < 16 && !keepMinutes) {\n                input = input * 60;\n            }\n            if (!this._isUTC && keepLocalTime) {\n                localAdjust = getDateOffset(this);\n            }\n            this._offset = input;\n            this._isUTC = true;\n            if (localAdjust != null) {\n                this.add(localAdjust, \"m\");\n            }\n            if (offset !== input) {\n                if (!keepLocalTime || this._changeInProgress) {\n                    addSubtract(this, createDuration(input - offset, \"m\"), 1, false);\n                } else if (!this._changeInProgress) {\n                    this._changeInProgress = true;\n                    hooks.updateOffset(this, true);\n                    this._changeInProgress = null;\n                }\n            }\n            return this;\n        } else {\n            return this._isUTC ? offset : getDateOffset(this);\n        }\n    }\n    function getSetZone(input, keepLocalTime) {\n        if (input != null) {\n            if (typeof input !== \"string\") {\n                input = -input;\n            }\n            this.utcOffset(input, keepLocalTime);\n            return this;\n        } else {\n            return -this.utcOffset();\n        }\n    }\n    function setOffsetToUTC(keepLocalTime) {\n        return this.utcOffset(0, keepLocalTime);\n    }\n    function setOffsetToLocal(keepLocalTime) {\n        if (this._isUTC) {\n            this.utcOffset(0, keepLocalTime);\n            this._isUTC = false;\n            if (keepLocalTime) {\n                this.subtract(getDateOffset(this), \"m\");\n            }\n        }\n        return this;\n    }\n    function setOffsetToParsedOffset() {\n        if (this._tzm != null) {\n            this.utcOffset(this._tzm, false, true);\n        } else if (typeof this._i === \"string\") {\n            var tZone = offsetFromString(matchOffset, this._i);\n            if (tZone != null) {\n                this.utcOffset(tZone);\n            } else {\n                this.utcOffset(0, true);\n            }\n        }\n        return this;\n    }\n    function hasAlignedHourOffset(input) {\n        if (!this.isValid()) {\n            return false;\n        }\n        input = input ? createLocal(input).utcOffset() : 0;\n        return (this.utcOffset() - input) % 60 === 0;\n    }\n    function isDaylightSavingTime() {\n        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();\n    }\n    function isDaylightSavingTimeShifted() {\n        if (!isUndefined(this._isDSTShifted)) {\n            return this._isDSTShifted;\n        }\n        var c = {}, other;\n        copyConfig(c, this);\n        c = prepareConfig(c);\n        if (c._a) {\n            other = c._isUTC ? createUTC(c._a) : createLocal(c._a);\n            this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;\n        } else {\n            this._isDSTShifted = false;\n        }\n        return this._isDSTShifted;\n    }\n    function isLocal() {\n        return this.isValid() ? !this._isUTC : false;\n    }\n    function isUtcOffset() {\n        return this.isValid() ? this._isUTC : false;\n    }\n    function isUtc() {\n        return this.isValid() ? this._isUTC && this._offset === 0 : false;\n    }\n    // ASP.NET json date format regex\n    var aspNetRegex = /^(-|\\+)?(?:(\\d*)[. ])?(\\d+):(\\d+)(?::(\\d+)(\\.\\d*)?)?$/, // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html\n    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere\n    // and further modified to allow for strings containing both week and day\n    isoRegex = /^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;\n    function createDuration(input, key) {\n        var duration = input, // matching against regexp is expensive, do it on demand\n        match = null, sign, ret, diffRes;\n        if (isDuration(input)) {\n            duration = {\n                ms: input._milliseconds,\n                d: input._days,\n                M: input._months\n            };\n        } else if (isNumber(input) || !isNaN(+input)) {\n            duration = {};\n            if (key) {\n                duration[key] = +input;\n            } else {\n                duration.milliseconds = +input;\n            }\n        } else if (match = aspNetRegex.exec(input)) {\n            sign = match[1] === \"-\" ? -1 : 1;\n            duration = {\n                y: 0,\n                d: toInt(match[DATE]) * sign,\n                h: toInt(match[HOUR]) * sign,\n                m: toInt(match[MINUTE]) * sign,\n                s: toInt(match[SECOND]) * sign,\n                ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign\n            };\n        } else if (match = isoRegex.exec(input)) {\n            sign = match[1] === \"-\" ? -1 : 1;\n            duration = {\n                y: parseIso(match[2], sign),\n                M: parseIso(match[3], sign),\n                w: parseIso(match[4], sign),\n                d: parseIso(match[5], sign),\n                h: parseIso(match[6], sign),\n                m: parseIso(match[7], sign),\n                s: parseIso(match[8], sign)\n            };\n        } else if (duration == null) {\n            // checks for null or undefined\n            duration = {};\n        } else if (typeof duration === \"object\" && (\"from\" in duration || \"to\" in duration)) {\n            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));\n            duration = {};\n            duration.ms = diffRes.milliseconds;\n            duration.M = diffRes.months;\n        }\n        ret = new Duration(duration);\n        if (isDuration(input) && hasOwnProp(input, \"_locale\")) {\n            ret._locale = input._locale;\n        }\n        if (isDuration(input) && hasOwnProp(input, \"_isValid\")) {\n            ret._isValid = input._isValid;\n        }\n        return ret;\n    }\n    createDuration.fn = Duration.prototype;\n    createDuration.invalid = createInvalid$1;\n    function parseIso(inp, sign) {\n        // We'd normally use ~~inp for this, but unfortunately it also\n        // converts floats to ints.\n        // inp may be undefined, so careful calling replace on it.\n        var res = inp && parseFloat(inp.replace(\",\", \".\"));\n        // apply sign while we're at it\n        return (isNaN(res) ? 0 : res) * sign;\n    }\n    function positiveMomentsDifference(base, other) {\n        var res = {};\n        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;\n        if (base.clone().add(res.months, \"M\").isAfter(other)) {\n            --res.months;\n        }\n        res.milliseconds = +other - +base.clone().add(res.months, \"M\");\n        return res;\n    }\n    function momentsDifference(base, other) {\n        var res;\n        if (!(base.isValid() && other.isValid())) {\n            return {\n                milliseconds: 0,\n                months: 0\n            };\n        }\n        other = cloneWithOffset(other, base);\n        if (base.isBefore(other)) {\n            res = positiveMomentsDifference(base, other);\n        } else {\n            res = positiveMomentsDifference(other, base);\n            res.milliseconds = -res.milliseconds;\n            res.months = -res.months;\n        }\n        return res;\n    }\n    // TODO: remove 'name' arg after deprecation is removed\n    function createAdder(direction, name) {\n        return function(val, period) {\n            var dur, tmp;\n            //invert the arguments, but complain about it\n            if (period !== null && !isNaN(+period)) {\n                deprecateSimple(name, \"moment().\" + name + \"(period, number) is deprecated. Please use moment().\" + name + \"(number, period). \" + \"See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.\");\n                tmp = val;\n                val = period;\n                period = tmp;\n            }\n            dur = createDuration(val, period);\n            addSubtract(this, dur, direction);\n            return this;\n        };\n    }\n    function addSubtract(mom, duration, isAdding, updateOffset) {\n        var milliseconds = duration._milliseconds, days = absRound(duration._days), months = absRound(duration._months);\n        if (!mom.isValid()) {\n            // No op\n            return;\n        }\n        updateOffset = updateOffset == null ? true : updateOffset;\n        if (months) {\n            setMonth(mom, get(mom, \"Month\") + months * isAdding);\n        }\n        if (days) {\n            set$1(mom, \"Date\", get(mom, \"Date\") + days * isAdding);\n        }\n        if (milliseconds) {\n            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);\n        }\n        if (updateOffset) {\n            hooks.updateOffset(mom, days || months);\n        }\n    }\n    var add = createAdder(1, \"add\"), subtract = createAdder(-1, \"subtract\");\n    function isString(input) {\n        return typeof input === \"string\" || input instanceof String;\n    }\n    // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined\n    function isMomentInput(input) {\n        return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === undefined;\n    }\n    function isMomentInputObject(input) {\n        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [\n            \"years\",\n            \"year\",\n            \"y\",\n            \"months\",\n            \"month\",\n            \"M\",\n            \"days\",\n            \"day\",\n            \"d\",\n            \"dates\",\n            \"date\",\n            \"D\",\n            \"hours\",\n            \"hour\",\n            \"h\",\n            \"minutes\",\n            \"minute\",\n            \"m\",\n            \"seconds\",\n            \"second\",\n            \"s\",\n            \"milliseconds\",\n            \"millisecond\",\n            \"ms\"\n        ], i, property, propertyLen = properties.length;\n        for(i = 0; i < propertyLen; i += 1){\n            property = properties[i];\n            propertyTest = propertyTest || hasOwnProp(input, property);\n        }\n        return objectTest && propertyTest;\n    }\n    function isNumberOrStringArray(input) {\n        var arrayTest = isArray(input), dataTypeTest = false;\n        if (arrayTest) {\n            dataTypeTest = input.filter(function(item) {\n                return !isNumber(item) && isString(input);\n            }).length === 0;\n        }\n        return arrayTest && dataTypeTest;\n    }\n    function isCalendarSpec(input) {\n        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [\n            \"sameDay\",\n            \"nextDay\",\n            \"lastDay\",\n            \"nextWeek\",\n            \"lastWeek\",\n            \"sameElse\"\n        ], i, property;\n        for(i = 0; i < properties.length; i += 1){\n            property = properties[i];\n            propertyTest = propertyTest || hasOwnProp(input, property);\n        }\n        return objectTest && propertyTest;\n    }\n    function getCalendarFormat(myMoment, now) {\n        var diff = myMoment.diff(now, \"days\", true);\n        return diff < -6 ? \"sameElse\" : diff < -1 ? \"lastWeek\" : diff < 0 ? \"lastDay\" : diff < 1 ? \"sameDay\" : diff < 2 ? \"nextDay\" : diff < 7 ? \"nextWeek\" : \"sameElse\";\n    }\n    function calendar$1(time, formats) {\n        // Support for single parameter, formats only overload to the calendar function\n        if (arguments.length === 1) {\n            if (!arguments[0]) {\n                time = undefined;\n                formats = undefined;\n            } else if (isMomentInput(arguments[0])) {\n                time = arguments[0];\n                formats = undefined;\n            } else if (isCalendarSpec(arguments[0])) {\n                formats = arguments[0];\n                time = undefined;\n            }\n        }\n        // We want to compare the start of today, vs this.\n        // Getting start-of-today depends on whether we're local/utc/offset or not.\n        var now = time || createLocal(), sod = cloneWithOffset(now, this).startOf(\"day\"), format = hooks.calendarFormat(this, sod) || \"sameElse\", output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);\n        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));\n    }\n    function clone() {\n        return new Moment(this);\n    }\n    function isAfter(input, units) {\n        var localInput = isMoment(input) ? input : createLocal(input);\n        if (!(this.isValid() && localInput.isValid())) {\n            return false;\n        }\n        units = normalizeUnits(units) || \"millisecond\";\n        if (units === \"millisecond\") {\n            return this.valueOf() > localInput.valueOf();\n        } else {\n            return localInput.valueOf() < this.clone().startOf(units).valueOf();\n        }\n    }\n    function isBefore(input, units) {\n        var localInput = isMoment(input) ? input : createLocal(input);\n        if (!(this.isValid() && localInput.isValid())) {\n            return false;\n        }\n        units = normalizeUnits(units) || \"millisecond\";\n        if (units === \"millisecond\") {\n            return this.valueOf() < localInput.valueOf();\n        } else {\n            return this.clone().endOf(units).valueOf() < localInput.valueOf();\n        }\n    }\n    function isBetween(from, to, units, inclusivity) {\n        var localFrom = isMoment(from) ? from : createLocal(from), localTo = isMoment(to) ? to : createLocal(to);\n        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {\n            return false;\n        }\n        inclusivity = inclusivity || \"()\";\n        return (inclusivity[0] === \"(\" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === \")\" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));\n    }\n    function isSame(input, units) {\n        var localInput = isMoment(input) ? input : createLocal(input), inputMs;\n        if (!(this.isValid() && localInput.isValid())) {\n            return false;\n        }\n        units = normalizeUnits(units) || \"millisecond\";\n        if (units === \"millisecond\") {\n            return this.valueOf() === localInput.valueOf();\n        } else {\n            inputMs = localInput.valueOf();\n            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();\n        }\n    }\n    function isSameOrAfter(input, units) {\n        return this.isSame(input, units) || this.isAfter(input, units);\n    }\n    function isSameOrBefore(input, units) {\n        return this.isSame(input, units) || this.isBefore(input, units);\n    }\n    function diff(input, units, asFloat) {\n        var that, zoneDelta, output;\n        if (!this.isValid()) {\n            return NaN;\n        }\n        that = cloneWithOffset(input, this);\n        if (!that.isValid()) {\n            return NaN;\n        }\n        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;\n        units = normalizeUnits(units);\n        switch(units){\n            case \"year\":\n                output = monthDiff(this, that) / 12;\n                break;\n            case \"month\":\n                output = monthDiff(this, that);\n                break;\n            case \"quarter\":\n                output = monthDiff(this, that) / 3;\n                break;\n            case \"second\":\n                output = (this - that) / 1e3;\n                break; // 1000\n            case \"minute\":\n                output = (this - that) / 6e4;\n                break; // 1000 * 60\n            case \"hour\":\n                output = (this - that) / 36e5;\n                break; // 1000 * 60 * 60\n            case \"day\":\n                output = (this - that - zoneDelta) / 864e5;\n                break; // 1000 * 60 * 60 * 24, negate dst\n            case \"week\":\n                output = (this - that - zoneDelta) / 6048e5;\n                break; // 1000 * 60 * 60 * 24 * 7, negate dst\n            default:\n                output = this - that;\n        }\n        return asFloat ? output : absFloor(output);\n    }\n    function monthDiff(a, b) {\n        if (a.date() < b.date()) {\n            // end-of-month calculations work correct when the start month has more\n            // days than the end month.\n            return -monthDiff(b, a);\n        }\n        // difference in months\n        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), // b is in (anchor - 1 month, anchor + 1 month)\n        anchor = a.clone().add(wholeMonthDiff, \"months\"), anchor2, adjust;\n        if (b - anchor < 0) {\n            anchor2 = a.clone().add(wholeMonthDiff - 1, \"months\");\n            // linear across the month\n            adjust = (b - anchor) / (anchor - anchor2);\n        } else {\n            anchor2 = a.clone().add(wholeMonthDiff + 1, \"months\");\n            // linear across the month\n            adjust = (b - anchor) / (anchor2 - anchor);\n        }\n        //check for negative zero, return zero if negative zero\n        return -(wholeMonthDiff + adjust) || 0;\n    }\n    hooks.defaultFormat = \"YYYY-MM-DDTHH:mm:ssZ\";\n    hooks.defaultFormatUtc = \"YYYY-MM-DDTHH:mm:ss[Z]\";\n    function toString() {\n        return this.clone().locale(\"en\").format(\"ddd MMM DD YYYY HH:mm:ss [GMT]ZZ\");\n    }\n    function toISOString(keepOffset) {\n        if (!this.isValid()) {\n            return null;\n        }\n        var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;\n        if (m.year() < 0 || m.year() > 9999) {\n            return formatMoment(m, utc ? \"YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]\" : \"YYYYYY-MM-DD[T]HH:mm:ss.SSSZ\");\n        }\n        if (isFunction(Date.prototype.toISOString)) {\n            // native implementation is ~50x faster, use it when we can\n            if (utc) {\n                return this.toDate().toISOString();\n            } else {\n                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace(\"Z\", formatMoment(m, \"Z\"));\n            }\n        }\n        return formatMoment(m, utc ? \"YYYY-MM-DD[T]HH:mm:ss.SSS[Z]\" : \"YYYY-MM-DD[T]HH:mm:ss.SSSZ\");\n    }\n    /**\n     * Return a human readable representation of a moment that can\n     * also be evaluated to get a new moment which is the same\n     *\n     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects\n     */ function inspect() {\n        if (!this.isValid()) {\n            return \"moment.invalid(/* \" + this._i + \" */)\";\n        }\n        var func = \"moment\", zone = \"\", prefix, year, datetime, suffix;\n        if (!this.isLocal()) {\n            func = this.utcOffset() === 0 ? \"moment.utc\" : \"moment.parseZone\";\n            zone = \"Z\";\n        }\n        prefix = \"[\" + func + '(\"]';\n        year = 0 <= this.year() && this.year() <= 9999 ? \"YYYY\" : \"YYYYYY\";\n        datetime = \"-MM-DD[T]HH:mm:ss.SSS\";\n        suffix = zone + '[\")]';\n        return this.format(prefix + year + datetime + suffix);\n    }\n    function format(inputString) {\n        if (!inputString) {\n            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;\n        }\n        var output = formatMoment(this, inputString);\n        return this.localeData().postformat(output);\n    }\n    function from(time, withoutSuffix) {\n        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {\n            return createDuration({\n                to: this,\n                from: time\n            }).locale(this.locale()).humanize(!withoutSuffix);\n        } else {\n            return this.localeData().invalidDate();\n        }\n    }\n    function fromNow(withoutSuffix) {\n        return this.from(createLocal(), withoutSuffix);\n    }\n    function to(time, withoutSuffix) {\n        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {\n            return createDuration({\n                from: this,\n                to: time\n            }).locale(this.locale()).humanize(!withoutSuffix);\n        } else {\n            return this.localeData().invalidDate();\n        }\n    }\n    function toNow(withoutSuffix) {\n        return this.to(createLocal(), withoutSuffix);\n    }\n    // If passed a locale key, it will set the locale for this\n    // instance.  Otherwise, it will return the locale configuration\n    // variables for this instance.\n    function locale(key) {\n        var newLocaleData;\n        if (key === undefined) {\n            return this._locale._abbr;\n        } else {\n            newLocaleData = getLocale(key);\n            if (newLocaleData != null) {\n                this._locale = newLocaleData;\n            }\n            return this;\n        }\n    }\n    var lang = deprecate(\"moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.\", function(key) {\n        if (key === undefined) {\n            return this.localeData();\n        } else {\n            return this.locale(key);\n        }\n    });\n    function localeData() {\n        return this._locale;\n    }\n    var MS_PER_SECOND = 1000, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;\n    // actual modulo - handles negative numbers (for dates before 1970):\n    function mod$1(dividend, divisor) {\n        return (dividend % divisor + divisor) % divisor;\n    }\n    function localStartOfDate(y, m, d) {\n        // the date constructor remaps years 0-99 to 1900-1999\n        if (y < 100 && y >= 0) {\n            // preserve leap years using a full 400 year cycle, then reset\n            return new Date(y + 400, m, d) - MS_PER_400_YEARS;\n        } else {\n            return new Date(y, m, d).valueOf();\n        }\n    }\n    function utcStartOfDate(y, m, d) {\n        // Date.UTC remaps years 0-99 to 1900-1999\n        if (y < 100 && y >= 0) {\n            // preserve leap years using a full 400 year cycle, then reset\n            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;\n        } else {\n            return Date.UTC(y, m, d);\n        }\n    }\n    function startOf(units) {\n        var time, startOfDate;\n        units = normalizeUnits(units);\n        if (units === undefined || units === \"millisecond\" || !this.isValid()) {\n            return this;\n        }\n        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;\n        switch(units){\n            case \"year\":\n                time = startOfDate(this.year(), 0, 1);\n                break;\n            case \"quarter\":\n                time = startOfDate(this.year(), this.month() - this.month() % 3, 1);\n                break;\n            case \"month\":\n                time = startOfDate(this.year(), this.month(), 1);\n                break;\n            case \"week\":\n                time = startOfDate(this.year(), this.month(), this.date() - this.weekday());\n                break;\n            case \"isoWeek\":\n                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));\n                break;\n            case \"day\":\n            case \"date\":\n                time = startOfDate(this.year(), this.month(), this.date());\n                break;\n            case \"hour\":\n                time = this._d.valueOf();\n                time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);\n                break;\n            case \"minute\":\n                time = this._d.valueOf();\n                time -= mod$1(time, MS_PER_MINUTE);\n                break;\n            case \"second\":\n                time = this._d.valueOf();\n                time -= mod$1(time, MS_PER_SECOND);\n                break;\n        }\n        this._d.setTime(time);\n        hooks.updateOffset(this, true);\n        return this;\n    }\n    function endOf(units) {\n        var time, startOfDate;\n        units = normalizeUnits(units);\n        if (units === undefined || units === \"millisecond\" || !this.isValid()) {\n            return this;\n        }\n        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;\n        switch(units){\n            case \"year\":\n                time = startOfDate(this.year() + 1, 0, 1) - 1;\n                break;\n            case \"quarter\":\n                time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;\n                break;\n            case \"month\":\n                time = startOfDate(this.year(), this.month() + 1, 1) - 1;\n                break;\n            case \"week\":\n                time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;\n                break;\n            case \"isoWeek\":\n                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;\n                break;\n            case \"day\":\n            case \"date\":\n                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;\n                break;\n            case \"hour\":\n                time = this._d.valueOf();\n                time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;\n                break;\n            case \"minute\":\n                time = this._d.valueOf();\n                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;\n                break;\n            case \"second\":\n                time = this._d.valueOf();\n                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;\n                break;\n        }\n        this._d.setTime(time);\n        hooks.updateOffset(this, true);\n        return this;\n    }\n    function valueOf() {\n        return this._d.valueOf() - (this._offset || 0) * 60000;\n    }\n    function unix() {\n        return Math.floor(this.valueOf() / 1000);\n    }\n    function toDate() {\n        return new Date(this.valueOf());\n    }\n    function toArray() {\n        var m = this;\n        return [\n            m.year(),\n            m.month(),\n            m.date(),\n            m.hour(),\n            m.minute(),\n            m.second(),\n            m.millisecond()\n        ];\n    }\n    function toObject() {\n        var m = this;\n        return {\n            years: m.year(),\n            months: m.month(),\n            date: m.date(),\n            hours: m.hours(),\n            minutes: m.minutes(),\n            seconds: m.seconds(),\n            milliseconds: m.milliseconds()\n        };\n    }\n    function toJSON() {\n        // new Date(NaN).toJSON() === null\n        return this.isValid() ? this.toISOString() : null;\n    }\n    function isValid$2() {\n        return isValid(this);\n    }\n    function parsingFlags() {\n        return extend({}, getParsingFlags(this));\n    }\n    function invalidAt() {\n        return getParsingFlags(this).overflow;\n    }\n    function creationData() {\n        return {\n            input: this._i,\n            format: this._f,\n            locale: this._locale,\n            isUTC: this._isUTC,\n            strict: this._strict\n        };\n    }\n    addFormatToken(\"N\", 0, 0, \"eraAbbr\");\n    addFormatToken(\"NN\", 0, 0, \"eraAbbr\");\n    addFormatToken(\"NNN\", 0, 0, \"eraAbbr\");\n    addFormatToken(\"NNNN\", 0, 0, \"eraName\");\n    addFormatToken(\"NNNNN\", 0, 0, \"eraNarrow\");\n    addFormatToken(\"y\", [\n        \"y\",\n        1\n    ], \"yo\", \"eraYear\");\n    addFormatToken(\"y\", [\n        \"yy\",\n        2\n    ], 0, \"eraYear\");\n    addFormatToken(\"y\", [\n        \"yyy\",\n        3\n    ], 0, \"eraYear\");\n    addFormatToken(\"y\", [\n        \"yyyy\",\n        4\n    ], 0, \"eraYear\");\n    addRegexToken(\"N\", matchEraAbbr);\n    addRegexToken(\"NN\", matchEraAbbr);\n    addRegexToken(\"NNN\", matchEraAbbr);\n    addRegexToken(\"NNNN\", matchEraName);\n    addRegexToken(\"NNNNN\", matchEraNarrow);\n    addParseToken([\n        \"N\",\n        \"NN\",\n        \"NNN\",\n        \"NNNN\",\n        \"NNNNN\"\n    ], function(input, array, config, token) {\n        var era = config._locale.erasParse(input, token, config._strict);\n        if (era) {\n            getParsingFlags(config).era = era;\n        } else {\n            getParsingFlags(config).invalidEra = input;\n        }\n    });\n    addRegexToken(\"y\", matchUnsigned);\n    addRegexToken(\"yy\", matchUnsigned);\n    addRegexToken(\"yyy\", matchUnsigned);\n    addRegexToken(\"yyyy\", matchUnsigned);\n    addRegexToken(\"yo\", matchEraYearOrdinal);\n    addParseToken([\n        \"y\",\n        \"yy\",\n        \"yyy\",\n        \"yyyy\"\n    ], YEAR);\n    addParseToken([\n        \"yo\"\n    ], function(input, array, config, token) {\n        var match;\n        if (config._locale._eraYearOrdinalRegex) {\n            match = input.match(config._locale._eraYearOrdinalRegex);\n        }\n        if (config._locale.eraYearOrdinalParse) {\n            array[YEAR] = config._locale.eraYearOrdinalParse(input, match);\n        } else {\n            array[YEAR] = parseInt(input, 10);\n        }\n    });\n    function localeEras(m, format) {\n        var i, l, date, eras = this._eras || getLocale(\"en\")._eras;\n        for(i = 0, l = eras.length; i < l; ++i){\n            switch(typeof eras[i].since){\n                case \"string\":\n                    // truncate time\n                    date = hooks(eras[i].since).startOf(\"day\");\n                    eras[i].since = date.valueOf();\n                    break;\n            }\n            switch(typeof eras[i].until){\n                case \"undefined\":\n                    eras[i].until = +Infinity;\n                    break;\n                case \"string\":\n                    // truncate time\n                    date = hooks(eras[i].until).startOf(\"day\").valueOf();\n                    eras[i].until = date.valueOf();\n                    break;\n            }\n        }\n        return eras;\n    }\n    function localeErasParse(eraName, format, strict) {\n        var i, l, eras = this.eras(), name, abbr, narrow;\n        eraName = eraName.toUpperCase();\n        for(i = 0, l = eras.length; i < l; ++i){\n            name = eras[i].name.toUpperCase();\n            abbr = eras[i].abbr.toUpperCase();\n            narrow = eras[i].narrow.toUpperCase();\n            if (strict) {\n                switch(format){\n                    case \"N\":\n                    case \"NN\":\n                    case \"NNN\":\n                        if (abbr === eraName) {\n                            return eras[i];\n                        }\n                        break;\n                    case \"NNNN\":\n                        if (name === eraName) {\n                            return eras[i];\n                        }\n                        break;\n                    case \"NNNNN\":\n                        if (narrow === eraName) {\n                            return eras[i];\n                        }\n                        break;\n                }\n            } else if ([\n                name,\n                abbr,\n                narrow\n            ].indexOf(eraName) >= 0) {\n                return eras[i];\n            }\n        }\n    }\n    function localeErasConvertYear(era, year) {\n        var dir = era.since <= era.until ? +1 : -1;\n        if (year === undefined) {\n            return hooks(era.since).year();\n        } else {\n            return hooks(era.since).year() + (year - era.offset) * dir;\n        }\n    }\n    function getEraName() {\n        var i, l, val, eras = this.localeData().eras();\n        for(i = 0, l = eras.length; i < l; ++i){\n            // truncate time\n            val = this.clone().startOf(\"day\").valueOf();\n            if (eras[i].since <= val && val <= eras[i].until) {\n                return eras[i].name;\n            }\n            if (eras[i].until <= val && val <= eras[i].since) {\n                return eras[i].name;\n            }\n        }\n        return \"\";\n    }\n    function getEraNarrow() {\n        var i, l, val, eras = this.localeData().eras();\n        for(i = 0, l = eras.length; i < l; ++i){\n            // truncate time\n            val = this.clone().startOf(\"day\").valueOf();\n            if (eras[i].since <= val && val <= eras[i].until) {\n                return eras[i].narrow;\n            }\n            if (eras[i].until <= val && val <= eras[i].since) {\n                return eras[i].narrow;\n            }\n        }\n        return \"\";\n    }\n    function getEraAbbr() {\n        var i, l, val, eras = this.localeData().eras();\n        for(i = 0, l = eras.length; i < l; ++i){\n            // truncate time\n            val = this.clone().startOf(\"day\").valueOf();\n            if (eras[i].since <= val && val <= eras[i].until) {\n                return eras[i].abbr;\n            }\n            if (eras[i].until <= val && val <= eras[i].since) {\n                return eras[i].abbr;\n            }\n        }\n        return \"\";\n    }\n    function getEraYear() {\n        var i, l, dir, val, eras = this.localeData().eras();\n        for(i = 0, l = eras.length; i < l; ++i){\n            dir = eras[i].since <= eras[i].until ? +1 : -1;\n            // truncate time\n            val = this.clone().startOf(\"day\").valueOf();\n            if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {\n                return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;\n            }\n        }\n        return this.year();\n    }\n    function erasNameRegex(isStrict) {\n        if (!hasOwnProp(this, \"_erasNameRegex\")) {\n            computeErasParse.call(this);\n        }\n        return isStrict ? this._erasNameRegex : this._erasRegex;\n    }\n    function erasAbbrRegex(isStrict) {\n        if (!hasOwnProp(this, \"_erasAbbrRegex\")) {\n            computeErasParse.call(this);\n        }\n        return isStrict ? this._erasAbbrRegex : this._erasRegex;\n    }\n    function erasNarrowRegex(isStrict) {\n        if (!hasOwnProp(this, \"_erasNarrowRegex\")) {\n            computeErasParse.call(this);\n        }\n        return isStrict ? this._erasNarrowRegex : this._erasRegex;\n    }\n    function matchEraAbbr(isStrict, locale) {\n        return locale.erasAbbrRegex(isStrict);\n    }\n    function matchEraName(isStrict, locale) {\n        return locale.erasNameRegex(isStrict);\n    }\n    function matchEraNarrow(isStrict, locale) {\n        return locale.erasNarrowRegex(isStrict);\n    }\n    function matchEraYearOrdinal(isStrict, locale) {\n        return locale._eraYearOrdinalRegex || matchUnsigned;\n    }\n    function computeErasParse() {\n        var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, eras = this.eras();\n        for(i = 0, l = eras.length; i < l; ++i){\n            namePieces.push(regexEscape(eras[i].name));\n            abbrPieces.push(regexEscape(eras[i].abbr));\n            narrowPieces.push(regexEscape(eras[i].narrow));\n            mixedPieces.push(regexEscape(eras[i].name));\n            mixedPieces.push(regexEscape(eras[i].abbr));\n            mixedPieces.push(regexEscape(eras[i].narrow));\n        }\n        this._erasRegex = new RegExp(\"^(\" + mixedPieces.join(\"|\") + \")\", \"i\");\n        this._erasNameRegex = new RegExp(\"^(\" + namePieces.join(\"|\") + \")\", \"i\");\n        this._erasAbbrRegex = new RegExp(\"^(\" + abbrPieces.join(\"|\") + \")\", \"i\");\n        this._erasNarrowRegex = new RegExp(\"^(\" + narrowPieces.join(\"|\") + \")\", \"i\");\n    }\n    // FORMATTING\n    addFormatToken(0, [\n        \"gg\",\n        2\n    ], 0, function() {\n        return this.weekYear() % 100;\n    });\n    addFormatToken(0, [\n        \"GG\",\n        2\n    ], 0, function() {\n        return this.isoWeekYear() % 100;\n    });\n    function addWeekYearFormatToken(token, getter) {\n        addFormatToken(0, [\n            token,\n            token.length\n        ], 0, getter);\n    }\n    addWeekYearFormatToken(\"gggg\", \"weekYear\");\n    addWeekYearFormatToken(\"ggggg\", \"weekYear\");\n    addWeekYearFormatToken(\"GGGG\", \"isoWeekYear\");\n    addWeekYearFormatToken(\"GGGGG\", \"isoWeekYear\");\n    // ALIASES\n    addUnitAlias(\"weekYear\", \"gg\");\n    addUnitAlias(\"isoWeekYear\", \"GG\");\n    // PRIORITY\n    addUnitPriority(\"weekYear\", 1);\n    addUnitPriority(\"isoWeekYear\", 1);\n    // PARSING\n    addRegexToken(\"G\", matchSigned);\n    addRegexToken(\"g\", matchSigned);\n    addRegexToken(\"GG\", match1to2, match2);\n    addRegexToken(\"gg\", match1to2, match2);\n    addRegexToken(\"GGGG\", match1to4, match4);\n    addRegexToken(\"gggg\", match1to4, match4);\n    addRegexToken(\"GGGGG\", match1to6, match6);\n    addRegexToken(\"ggggg\", match1to6, match6);\n    addWeekParseToken([\n        \"gggg\",\n        \"ggggg\",\n        \"GGGG\",\n        \"GGGGG\"\n    ], function(input, week, config, token) {\n        week[token.substr(0, 2)] = toInt(input);\n    });\n    addWeekParseToken([\n        \"gg\",\n        \"GG\"\n    ], function(input, week, config, token) {\n        week[token] = hooks.parseTwoDigitYear(input);\n    });\n    // MOMENTS\n    function getSetWeekYear(input) {\n        return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);\n    }\n    function getSetISOWeekYear(input) {\n        return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);\n    }\n    function getISOWeeksInYear() {\n        return weeksInYear(this.year(), 1, 4);\n    }\n    function getISOWeeksInISOWeekYear() {\n        return weeksInYear(this.isoWeekYear(), 1, 4);\n    }\n    function getWeeksInYear() {\n        var weekInfo = this.localeData()._week;\n        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);\n    }\n    function getWeeksInWeekYear() {\n        var weekInfo = this.localeData()._week;\n        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);\n    }\n    function getSetWeekYearHelper(input, week, weekday, dow, doy) {\n        var weeksTarget;\n        if (input == null) {\n            return weekOfYear(this, dow, doy).year;\n        } else {\n            weeksTarget = weeksInYear(input, dow, doy);\n            if (week > weeksTarget) {\n                week = weeksTarget;\n            }\n            return setWeekAll.call(this, input, week, weekday, dow, doy);\n        }\n    }\n    function setWeekAll(weekYear, week, weekday, dow, doy) {\n        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);\n        this.year(date.getUTCFullYear());\n        this.month(date.getUTCMonth());\n        this.date(date.getUTCDate());\n        return this;\n    }\n    // FORMATTING\n    addFormatToken(\"Q\", 0, \"Qo\", \"quarter\");\n    // ALIASES\n    addUnitAlias(\"quarter\", \"Q\");\n    // PRIORITY\n    addUnitPriority(\"quarter\", 7);\n    // PARSING\n    addRegexToken(\"Q\", match1);\n    addParseToken(\"Q\", function(input, array) {\n        array[MONTH] = (toInt(input) - 1) * 3;\n    });\n    // MOMENTS\n    function getSetQuarter(input) {\n        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);\n    }\n    // FORMATTING\n    addFormatToken(\"D\", [\n        \"DD\",\n        2\n    ], \"Do\", \"date\");\n    // ALIASES\n    addUnitAlias(\"date\", \"D\");\n    // PRIORITY\n    addUnitPriority(\"date\", 9);\n    // PARSING\n    addRegexToken(\"D\", match1to2);\n    addRegexToken(\"DD\", match1to2, match2);\n    addRegexToken(\"Do\", function(isStrict, locale) {\n        // TODO: Remove \"ordinalParse\" fallback in next major release.\n        return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;\n    });\n    addParseToken([\n        \"D\",\n        \"DD\"\n    ], DATE);\n    addParseToken(\"Do\", function(input, array) {\n        array[DATE] = toInt(input.match(match1to2)[0]);\n    });\n    // MOMENTS\n    var getSetDayOfMonth = makeGetSet(\"Date\", true);\n    // FORMATTING\n    addFormatToken(\"DDD\", [\n        \"DDDD\",\n        3\n    ], \"DDDo\", \"dayOfYear\");\n    // ALIASES\n    addUnitAlias(\"dayOfYear\", \"DDD\");\n    // PRIORITY\n    addUnitPriority(\"dayOfYear\", 4);\n    // PARSING\n    addRegexToken(\"DDD\", match1to3);\n    addRegexToken(\"DDDD\", match3);\n    addParseToken([\n        \"DDD\",\n        \"DDDD\"\n    ], function(input, array, config) {\n        config._dayOfYear = toInt(input);\n    });\n    // HELPERS\n    // MOMENTS\n    function getSetDayOfYear(input) {\n        var dayOfYear = Math.round((this.clone().startOf(\"day\") - this.clone().startOf(\"year\")) / 864e5) + 1;\n        return input == null ? dayOfYear : this.add(input - dayOfYear, \"d\");\n    }\n    // FORMATTING\n    addFormatToken(\"m\", [\n        \"mm\",\n        2\n    ], 0, \"minute\");\n    // ALIASES\n    addUnitAlias(\"minute\", \"m\");\n    // PRIORITY\n    addUnitPriority(\"minute\", 14);\n    // PARSING\n    addRegexToken(\"m\", match1to2);\n    addRegexToken(\"mm\", match1to2, match2);\n    addParseToken([\n        \"m\",\n        \"mm\"\n    ], MINUTE);\n    // MOMENTS\n    var getSetMinute = makeGetSet(\"Minutes\", false);\n    // FORMATTING\n    addFormatToken(\"s\", [\n        \"ss\",\n        2\n    ], 0, \"second\");\n    // ALIASES\n    addUnitAlias(\"second\", \"s\");\n    // PRIORITY\n    addUnitPriority(\"second\", 15);\n    // PARSING\n    addRegexToken(\"s\", match1to2);\n    addRegexToken(\"ss\", match1to2, match2);\n    addParseToken([\n        \"s\",\n        \"ss\"\n    ], SECOND);\n    // MOMENTS\n    var getSetSecond = makeGetSet(\"Seconds\", false);\n    // FORMATTING\n    addFormatToken(\"S\", 0, 0, function() {\n        return ~~(this.millisecond() / 100);\n    });\n    addFormatToken(0, [\n        \"SS\",\n        2\n    ], 0, function() {\n        return ~~(this.millisecond() / 10);\n    });\n    addFormatToken(0, [\n        \"SSS\",\n        3\n    ], 0, \"millisecond\");\n    addFormatToken(0, [\n        \"SSSS\",\n        4\n    ], 0, function() {\n        return this.millisecond() * 10;\n    });\n    addFormatToken(0, [\n        \"SSSSS\",\n        5\n    ], 0, function() {\n        return this.millisecond() * 100;\n    });\n    addFormatToken(0, [\n        \"SSSSSS\",\n        6\n    ], 0, function() {\n        return this.millisecond() * 1000;\n    });\n    addFormatToken(0, [\n        \"SSSSSSS\",\n        7\n    ], 0, function() {\n        return this.millisecond() * 10000;\n    });\n    addFormatToken(0, [\n        \"SSSSSSSS\",\n        8\n    ], 0, function() {\n        return this.millisecond() * 100000;\n    });\n    addFormatToken(0, [\n        \"SSSSSSSSS\",\n        9\n    ], 0, function() {\n        return this.millisecond() * 1000000;\n    });\n    // ALIASES\n    addUnitAlias(\"millisecond\", \"ms\");\n    // PRIORITY\n    addUnitPriority(\"millisecond\", 16);\n    // PARSING\n    addRegexToken(\"S\", match1to3, match1);\n    addRegexToken(\"SS\", match1to3, match2);\n    addRegexToken(\"SSS\", match1to3, match3);\n    var token, getSetMillisecond;\n    for(token = \"SSSS\"; token.length <= 9; token += \"S\"){\n        addRegexToken(token, matchUnsigned);\n    }\n    function parseMs(input, array) {\n        array[MILLISECOND] = toInt((\"0.\" + input) * 1000);\n    }\n    for(token = \"S\"; token.length <= 9; token += \"S\"){\n        addParseToken(token, parseMs);\n    }\n    getSetMillisecond = makeGetSet(\"Milliseconds\", false);\n    // FORMATTING\n    addFormatToken(\"z\", 0, 0, \"zoneAbbr\");\n    addFormatToken(\"zz\", 0, 0, \"zoneName\");\n    // MOMENTS\n    function getZoneAbbr() {\n        return this._isUTC ? \"UTC\" : \"\";\n    }\n    function getZoneName() {\n        return this._isUTC ? \"Coordinated Universal Time\" : \"\";\n    }\n    var proto = Moment.prototype;\n    proto.add = add;\n    proto.calendar = calendar$1;\n    proto.clone = clone;\n    proto.diff = diff;\n    proto.endOf = endOf;\n    proto.format = format;\n    proto.from = from;\n    proto.fromNow = fromNow;\n    proto.to = to;\n    proto.toNow = toNow;\n    proto.get = stringGet;\n    proto.invalidAt = invalidAt;\n    proto.isAfter = isAfter;\n    proto.isBefore = isBefore;\n    proto.isBetween = isBetween;\n    proto.isSame = isSame;\n    proto.isSameOrAfter = isSameOrAfter;\n    proto.isSameOrBefore = isSameOrBefore;\n    proto.isValid = isValid$2;\n    proto.lang = lang;\n    proto.locale = locale;\n    proto.localeData = localeData;\n    proto.max = prototypeMax;\n    proto.min = prototypeMin;\n    proto.parsingFlags = parsingFlags;\n    proto.set = stringSet;\n    proto.startOf = startOf;\n    proto.subtract = subtract;\n    proto.toArray = toArray;\n    proto.toObject = toObject;\n    proto.toDate = toDate;\n    proto.toISOString = toISOString;\n    proto.inspect = inspect;\n    if (typeof Symbol !== \"undefined\" && Symbol.for != null) {\n        proto[Symbol.for(\"nodejs.util.inspect.custom\")] = function() {\n            return \"Moment<\" + this.format() + \">\";\n        };\n    }\n    proto.toJSON = toJSON;\n    proto.toString = toString;\n    proto.unix = unix;\n    proto.valueOf = valueOf;\n    proto.creationData = creationData;\n    proto.eraName = getEraName;\n    proto.eraNarrow = getEraNarrow;\n    proto.eraAbbr = getEraAbbr;\n    proto.eraYear = getEraYear;\n    proto.year = getSetYear;\n    proto.isLeapYear = getIsLeapYear;\n    proto.weekYear = getSetWeekYear;\n    proto.isoWeekYear = getSetISOWeekYear;\n    proto.quarter = proto.quarters = getSetQuarter;\n    proto.month = getSetMonth;\n    proto.daysInMonth = getDaysInMonth;\n    proto.week = proto.weeks = getSetWeek;\n    proto.isoWeek = proto.isoWeeks = getSetISOWeek;\n    proto.weeksInYear = getWeeksInYear;\n    proto.weeksInWeekYear = getWeeksInWeekYear;\n    proto.isoWeeksInYear = getISOWeeksInYear;\n    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;\n    proto.date = getSetDayOfMonth;\n    proto.day = proto.days = getSetDayOfWeek;\n    proto.weekday = getSetLocaleDayOfWeek;\n    proto.isoWeekday = getSetISODayOfWeek;\n    proto.dayOfYear = getSetDayOfYear;\n    proto.hour = proto.hours = getSetHour;\n    proto.minute = proto.minutes = getSetMinute;\n    proto.second = proto.seconds = getSetSecond;\n    proto.millisecond = proto.milliseconds = getSetMillisecond;\n    proto.utcOffset = getSetOffset;\n    proto.utc = setOffsetToUTC;\n    proto.local = setOffsetToLocal;\n    proto.parseZone = setOffsetToParsedOffset;\n    proto.hasAlignedHourOffset = hasAlignedHourOffset;\n    proto.isDST = isDaylightSavingTime;\n    proto.isLocal = isLocal;\n    proto.isUtcOffset = isUtcOffset;\n    proto.isUtc = isUtc;\n    proto.isUTC = isUtc;\n    proto.zoneAbbr = getZoneAbbr;\n    proto.zoneName = getZoneName;\n    proto.dates = deprecate(\"dates accessor is deprecated. Use date instead.\", getSetDayOfMonth);\n    proto.months = deprecate(\"months accessor is deprecated. Use month instead\", getSetMonth);\n    proto.years = deprecate(\"years accessor is deprecated. Use year instead\", getSetYear);\n    proto.zone = deprecate(\"moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/\", getSetZone);\n    proto.isDSTShifted = deprecate(\"isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information\", isDaylightSavingTimeShifted);\n    function createUnix(input) {\n        return createLocal(input * 1000);\n    }\n    function createInZone() {\n        return createLocal.apply(null, arguments).parseZone();\n    }\n    function preParsePostFormat(string) {\n        return string;\n    }\n    var proto$1 = Locale.prototype;\n    proto$1.calendar = calendar;\n    proto$1.longDateFormat = longDateFormat;\n    proto$1.invalidDate = invalidDate;\n    proto$1.ordinal = ordinal;\n    proto$1.preparse = preParsePostFormat;\n    proto$1.postformat = preParsePostFormat;\n    proto$1.relativeTime = relativeTime;\n    proto$1.pastFuture = pastFuture;\n    proto$1.set = set;\n    proto$1.eras = localeEras;\n    proto$1.erasParse = localeErasParse;\n    proto$1.erasConvertYear = localeErasConvertYear;\n    proto$1.erasAbbrRegex = erasAbbrRegex;\n    proto$1.erasNameRegex = erasNameRegex;\n    proto$1.erasNarrowRegex = erasNarrowRegex;\n    proto$1.months = localeMonths;\n    proto$1.monthsShort = localeMonthsShort;\n    proto$1.monthsParse = localeMonthsParse;\n    proto$1.monthsRegex = monthsRegex;\n    proto$1.monthsShortRegex = monthsShortRegex;\n    proto$1.week = localeWeek;\n    proto$1.firstDayOfYear = localeFirstDayOfYear;\n    proto$1.firstDayOfWeek = localeFirstDayOfWeek;\n    proto$1.weekdays = localeWeekdays;\n    proto$1.weekdaysMin = localeWeekdaysMin;\n    proto$1.weekdaysShort = localeWeekdaysShort;\n    proto$1.weekdaysParse = localeWeekdaysParse;\n    proto$1.weekdaysRegex = weekdaysRegex;\n    proto$1.weekdaysShortRegex = weekdaysShortRegex;\n    proto$1.weekdaysMinRegex = weekdaysMinRegex;\n    proto$1.isPM = localeIsPM;\n    proto$1.meridiem = localeMeridiem;\n    function get$1(format, index, field, setter) {\n        var locale = getLocale(), utc = createUTC().set(setter, index);\n        return locale[field](utc, format);\n    }\n    function listMonthsImpl(format, index, field) {\n        if (isNumber(format)) {\n            index = format;\n            format = undefined;\n        }\n        format = format || \"\";\n        if (index != null) {\n            return get$1(format, index, field, \"month\");\n        }\n        var i, out = [];\n        for(i = 0; i < 12; i++){\n            out[i] = get$1(format, i, field, \"month\");\n        }\n        return out;\n    }\n    // ()\n    // (5)\n    // (fmt, 5)\n    // (fmt)\n    // (true)\n    // (true, 5)\n    // (true, fmt, 5)\n    // (true, fmt)\n    function listWeekdaysImpl(localeSorted, format, index, field) {\n        if (typeof localeSorted === \"boolean\") {\n            if (isNumber(format)) {\n                index = format;\n                format = undefined;\n            }\n            format = format || \"\";\n        } else {\n            format = localeSorted;\n            index = format;\n            localeSorted = false;\n            if (isNumber(format)) {\n                index = format;\n                format = undefined;\n            }\n            format = format || \"\";\n        }\n        var locale = getLocale(), shift = localeSorted ? locale._week.dow : 0, i, out = [];\n        if (index != null) {\n            return get$1(format, (index + shift) % 7, field, \"day\");\n        }\n        for(i = 0; i < 7; i++){\n            out[i] = get$1(format, (i + shift) % 7, field, \"day\");\n        }\n        return out;\n    }\n    function listMonths(format, index) {\n        return listMonthsImpl(format, index, \"months\");\n    }\n    function listMonthsShort(format, index) {\n        return listMonthsImpl(format, index, \"monthsShort\");\n    }\n    function listWeekdays(localeSorted, format, index) {\n        return listWeekdaysImpl(localeSorted, format, index, \"weekdays\");\n    }\n    function listWeekdaysShort(localeSorted, format, index) {\n        return listWeekdaysImpl(localeSorted, format, index, \"weekdaysShort\");\n    }\n    function listWeekdaysMin(localeSorted, format, index) {\n        return listWeekdaysImpl(localeSorted, format, index, \"weekdaysMin\");\n    }\n    getSetGlobalLocale(\"en\", {\n        eras: [\n            {\n                since: \"0001-01-01\",\n                until: +Infinity,\n                offset: 1,\n                name: \"Anno Domini\",\n                narrow: \"AD\",\n                abbr: \"AD\"\n            },\n            {\n                since: \"0000-12-31\",\n                until: -Infinity,\n                offset: 1,\n                name: \"Before Christ\",\n                narrow: \"BC\",\n                abbr: \"BC\"\n            }\n        ],\n        dayOfMonthOrdinalParse: /\\d{1,2}(th|st|nd|rd)/,\n        ordinal: function(number) {\n            var b = number % 10, output = toInt(number % 100 / 10) === 1 ? \"th\" : b === 1 ? \"st\" : b === 2 ? \"nd\" : b === 3 ? \"rd\" : \"th\";\n            return number + output;\n        }\n    });\n    // Side effect imports\n    hooks.lang = deprecate(\"moment.lang is deprecated. Use moment.locale instead.\", getSetGlobalLocale);\n    hooks.langData = deprecate(\"moment.langData is deprecated. Use moment.localeData instead.\", getLocale);\n    var mathAbs = Math.abs;\n    function abs() {\n        var data = this._data;\n        this._milliseconds = mathAbs(this._milliseconds);\n        this._days = mathAbs(this._days);\n        this._months = mathAbs(this._months);\n        data.milliseconds = mathAbs(data.milliseconds);\n        data.seconds = mathAbs(data.seconds);\n        data.minutes = mathAbs(data.minutes);\n        data.hours = mathAbs(data.hours);\n        data.months = mathAbs(data.months);\n        data.years = mathAbs(data.years);\n        return this;\n    }\n    function addSubtract$1(duration, input, value, direction) {\n        var other = createDuration(input, value);\n        duration._milliseconds += direction * other._milliseconds;\n        duration._days += direction * other._days;\n        duration._months += direction * other._months;\n        return duration._bubble();\n    }\n    // supports only 2.0-style add(1, 's') or add(duration)\n    function add$1(input, value) {\n        return addSubtract$1(this, input, value, 1);\n    }\n    // supports only 2.0-style subtract(1, 's') or subtract(duration)\n    function subtract$1(input, value) {\n        return addSubtract$1(this, input, value, -1);\n    }\n    function absCeil(number) {\n        if (number < 0) {\n            return Math.floor(number);\n        } else {\n            return Math.ceil(number);\n        }\n    }\n    function bubble() {\n        var milliseconds = this._milliseconds, days = this._days, months = this._months, data = this._data, seconds, minutes, hours, years, monthsFromDays;\n        // if we have a mix of positive and negative values, bubble down first\n        // check: https://github.com/moment/moment/issues/2166\n        if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {\n            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;\n            days = 0;\n            months = 0;\n        }\n        // The following code bubbles up values, see the tests for\n        // examples of what that means.\n        data.milliseconds = milliseconds % 1000;\n        seconds = absFloor(milliseconds / 1000);\n        data.seconds = seconds % 60;\n        minutes = absFloor(seconds / 60);\n        data.minutes = minutes % 60;\n        hours = absFloor(minutes / 60);\n        data.hours = hours % 24;\n        days += absFloor(hours / 24);\n        // convert days to months\n        monthsFromDays = absFloor(daysToMonths(days));\n        months += monthsFromDays;\n        days -= absCeil(monthsToDays(monthsFromDays));\n        // 12 months -> 1 year\n        years = absFloor(months / 12);\n        months %= 12;\n        data.days = days;\n        data.months = months;\n        data.years = years;\n        return this;\n    }\n    function daysToMonths(days) {\n        // 400 years have 146097 days (taking into account leap year rules)\n        // 400 years have 12 months === 4800\n        return days * 4800 / 146097;\n    }\n    function monthsToDays(months) {\n        // the reverse of daysToMonths\n        return months * 146097 / 4800;\n    }\n    function as(units) {\n        if (!this.isValid()) {\n            return NaN;\n        }\n        var days, months, milliseconds = this._milliseconds;\n        units = normalizeUnits(units);\n        if (units === \"month\" || units === \"quarter\" || units === \"year\") {\n            days = this._days + milliseconds / 864e5;\n            months = this._months + daysToMonths(days);\n            switch(units){\n                case \"month\":\n                    return months;\n                case \"quarter\":\n                    return months / 3;\n                case \"year\":\n                    return months / 12;\n            }\n        } else {\n            // handle milliseconds separately because of floating point math errors (issue #1867)\n            days = this._days + Math.round(monthsToDays(this._months));\n            switch(units){\n                case \"week\":\n                    return days / 7 + milliseconds / 6048e5;\n                case \"day\":\n                    return days + milliseconds / 864e5;\n                case \"hour\":\n                    return days * 24 + milliseconds / 36e5;\n                case \"minute\":\n                    return days * 1440 + milliseconds / 6e4;\n                case \"second\":\n                    return days * 86400 + milliseconds / 1000;\n                // Math.floor prevents floating point math errors here\n                case \"millisecond\":\n                    return Math.floor(days * 864e5) + milliseconds;\n                default:\n                    throw new Error(\"Unknown unit \" + units);\n            }\n        }\n    }\n    // TODO: Use this.as('ms')?\n    function valueOf$1() {\n        if (!this.isValid()) {\n            return NaN;\n        }\n        return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;\n    }\n    function makeAs(alias) {\n        return function() {\n            return this.as(alias);\n        };\n    }\n    var asMilliseconds = makeAs(\"ms\"), asSeconds = makeAs(\"s\"), asMinutes = makeAs(\"m\"), asHours = makeAs(\"h\"), asDays = makeAs(\"d\"), asWeeks = makeAs(\"w\"), asMonths = makeAs(\"M\"), asQuarters = makeAs(\"Q\"), asYears = makeAs(\"y\");\n    function clone$1() {\n        return createDuration(this);\n    }\n    function get$2(units) {\n        units = normalizeUnits(units);\n        return this.isValid() ? this[units + \"s\"]() : NaN;\n    }\n    function makeGetter(name) {\n        return function() {\n            return this.isValid() ? this._data[name] : NaN;\n        };\n    }\n    var milliseconds = makeGetter(\"milliseconds\"), seconds = makeGetter(\"seconds\"), minutes = makeGetter(\"minutes\"), hours = makeGetter(\"hours\"), days = makeGetter(\"days\"), months = makeGetter(\"months\"), years = makeGetter(\"years\");\n    function weeks() {\n        return absFloor(this.days() / 7);\n    }\n    var round = Math.round, thresholds = {\n        ss: 44,\n        s: 45,\n        m: 45,\n        h: 22,\n        d: 26,\n        w: null,\n        M: 11\n    };\n    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize\n    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {\n        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);\n    }\n    function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {\n        var duration = createDuration(posNegDuration).abs(), seconds = round(duration.as(\"s\")), minutes = round(duration.as(\"m\")), hours = round(duration.as(\"h\")), days = round(duration.as(\"d\")), months = round(duration.as(\"M\")), weeks = round(duration.as(\"w\")), years = round(duration.as(\"y\")), a = seconds <= thresholds.ss && [\n            \"s\",\n            seconds\n        ] || seconds < thresholds.s && [\n            \"ss\",\n            seconds\n        ] || minutes <= 1 && [\n            \"m\"\n        ] || minutes < thresholds.m && [\n            \"mm\",\n            minutes\n        ] || hours <= 1 && [\n            \"h\"\n        ] || hours < thresholds.h && [\n            \"hh\",\n            hours\n        ] || days <= 1 && [\n            \"d\"\n        ] || days < thresholds.d && [\n            \"dd\",\n            days\n        ];\n        if (thresholds.w != null) {\n            a = a || weeks <= 1 && [\n                \"w\"\n            ] || weeks < thresholds.w && [\n                \"ww\",\n                weeks\n            ];\n        }\n        a = a || months <= 1 && [\n            \"M\"\n        ] || months < thresholds.M && [\n            \"MM\",\n            months\n        ] || years <= 1 && [\n            \"y\"\n        ] || [\n            \"yy\",\n            years\n        ];\n        a[2] = withoutSuffix;\n        a[3] = +posNegDuration > 0;\n        a[4] = locale;\n        return substituteTimeAgo.apply(null, a);\n    }\n    // This function allows you to set the rounding function for relative time strings\n    function getSetRelativeTimeRounding(roundingFunction) {\n        if (roundingFunction === undefined) {\n            return round;\n        }\n        if (typeof roundingFunction === \"function\") {\n            round = roundingFunction;\n            return true;\n        }\n        return false;\n    }\n    // This function allows you to set a threshold for relative time strings\n    function getSetRelativeTimeThreshold(threshold, limit) {\n        if (thresholds[threshold] === undefined) {\n            return false;\n        }\n        if (limit === undefined) {\n            return thresholds[threshold];\n        }\n        thresholds[threshold] = limit;\n        if (threshold === \"s\") {\n            thresholds.ss = limit - 1;\n        }\n        return true;\n    }\n    function humanize(argWithSuffix, argThresholds) {\n        if (!this.isValid()) {\n            return this.localeData().invalidDate();\n        }\n        var withSuffix = false, th = thresholds, locale, output;\n        if (typeof argWithSuffix === \"object\") {\n            argThresholds = argWithSuffix;\n            argWithSuffix = false;\n        }\n        if (typeof argWithSuffix === \"boolean\") {\n            withSuffix = argWithSuffix;\n        }\n        if (typeof argThresholds === \"object\") {\n            th = Object.assign({}, thresholds, argThresholds);\n            if (argThresholds.s != null && argThresholds.ss == null) {\n                th.ss = argThresholds.s - 1;\n            }\n        }\n        locale = this.localeData();\n        output = relativeTime$1(this, !withSuffix, th, locale);\n        if (withSuffix) {\n            output = locale.pastFuture(+this, output);\n        }\n        return locale.postformat(output);\n    }\n    var abs$1 = Math.abs;\n    function sign(x) {\n        return (x > 0) - (x < 0) || +x;\n    }\n    function toISOString$1() {\n        // for ISO strings we do not use the normal bubbling rules:\n        //  * milliseconds bubble up until they become hours\n        //  * days do not bubble at all\n        //  * months bubble up until they become years\n        // This is because there is no context-free conversion between hours and days\n        // (think of clock changes)\n        // and also not between days and months (28-31 days per month)\n        if (!this.isValid()) {\n            return this.localeData().invalidDate();\n        }\n        var seconds = abs$1(this._milliseconds) / 1000, days = abs$1(this._days), months = abs$1(this._months), minutes, hours, years, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;\n        if (!total) {\n            // this is the same as C#'s (Noda) and python (isodate)...\n            // but not other JS (goog.date)\n            return \"P0D\";\n        }\n        // 3600 seconds -> 60 minutes -> 1 hour\n        minutes = absFloor(seconds / 60);\n        hours = absFloor(minutes / 60);\n        seconds %= 60;\n        minutes %= 60;\n        // 12 months -> 1 year\n        years = absFloor(months / 12);\n        months %= 12;\n        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js\n        s = seconds ? seconds.toFixed(3).replace(/\\.?0+$/, \"\") : \"\";\n        totalSign = total < 0 ? \"-\" : \"\";\n        ymSign = sign(this._months) !== sign(total) ? \"-\" : \"\";\n        daysSign = sign(this._days) !== sign(total) ? \"-\" : \"\";\n        hmsSign = sign(this._milliseconds) !== sign(total) ? \"-\" : \"\";\n        return totalSign + \"P\" + (years ? ymSign + years + \"Y\" : \"\") + (months ? ymSign + months + \"M\" : \"\") + (days ? daysSign + days + \"D\" : \"\") + (hours || minutes || seconds ? \"T\" : \"\") + (hours ? hmsSign + hours + \"H\" : \"\") + (minutes ? hmsSign + minutes + \"M\" : \"\") + (seconds ? hmsSign + s + \"S\" : \"\");\n    }\n    var proto$2 = Duration.prototype;\n    proto$2.isValid = isValid$1;\n    proto$2.abs = abs;\n    proto$2.add = add$1;\n    proto$2.subtract = subtract$1;\n    proto$2.as = as;\n    proto$2.asMilliseconds = asMilliseconds;\n    proto$2.asSeconds = asSeconds;\n    proto$2.asMinutes = asMinutes;\n    proto$2.asHours = asHours;\n    proto$2.asDays = asDays;\n    proto$2.asWeeks = asWeeks;\n    proto$2.asMonths = asMonths;\n    proto$2.asQuarters = asQuarters;\n    proto$2.asYears = asYears;\n    proto$2.valueOf = valueOf$1;\n    proto$2._bubble = bubble;\n    proto$2.clone = clone$1;\n    proto$2.get = get$2;\n    proto$2.milliseconds = milliseconds;\n    proto$2.seconds = seconds;\n    proto$2.minutes = minutes;\n    proto$2.hours = hours;\n    proto$2.days = days;\n    proto$2.weeks = weeks;\n    proto$2.months = months;\n    proto$2.years = years;\n    proto$2.humanize = humanize;\n    proto$2.toISOString = toISOString$1;\n    proto$2.toString = toISOString$1;\n    proto$2.toJSON = toISOString$1;\n    proto$2.locale = locale;\n    proto$2.localeData = localeData;\n    proto$2.toIsoString = deprecate(\"toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)\", toISOString$1);\n    proto$2.lang = lang;\n    // FORMATTING\n    addFormatToken(\"X\", 0, 0, \"unix\");\n    addFormatToken(\"x\", 0, 0, \"valueOf\");\n    // PARSING\n    addRegexToken(\"x\", matchSigned);\n    addRegexToken(\"X\", matchTimestamp);\n    addParseToken(\"X\", function(input, array, config) {\n        config._d = new Date(parseFloat(input) * 1000);\n    });\n    addParseToken(\"x\", function(input, array, config) {\n        config._d = new Date(toInt(input));\n    });\n    //! moment.js\n    hooks.version = \"2.29.4\";\n    setHookCallback(createLocal);\n    hooks.fn = proto;\n    hooks.min = min;\n    hooks.max = max;\n    hooks.now = now;\n    hooks.utc = createUTC;\n    hooks.unix = createUnix;\n    hooks.months = listMonths;\n    hooks.isDate = isDate;\n    hooks.locale = getSetGlobalLocale;\n    hooks.invalid = createInvalid;\n    hooks.duration = createDuration;\n    hooks.isMoment = isMoment;\n    hooks.weekdays = listWeekdays;\n    hooks.parseZone = createInZone;\n    hooks.localeData = getLocale;\n    hooks.isDuration = isDuration;\n    hooks.monthsShort = listMonthsShort;\n    hooks.weekdaysMin = listWeekdaysMin;\n    hooks.defineLocale = defineLocale;\n    hooks.updateLocale = updateLocale;\n    hooks.locales = listLocales;\n    hooks.weekdaysShort = listWeekdaysShort;\n    hooks.normalizeUnits = normalizeUnits;\n    hooks.relativeTimeRounding = getSetRelativeTimeRounding;\n    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;\n    hooks.calendarFormat = getCalendarFormat;\n    hooks.prototype = proto;\n    // currently HTML5 input type only supports 24-hour formats\n    hooks.HTML5_FMT = {\n        DATETIME_LOCAL: \"YYYY-MM-DDTHH:mm\",\n        DATETIME_LOCAL_SECONDS: \"YYYY-MM-DDTHH:mm:ss\",\n        DATETIME_LOCAL_MS: \"YYYY-MM-DDTHH:mm:ss.SSS\",\n        DATE: \"YYYY-MM-DD\",\n        TIME: \"HH:mm\",\n        TIME_SECONDS: \"HH:mm:ss\",\n        TIME_MS: \"HH:mm:ss.SSS\",\n        WEEK: \"GGGG-[W]WW\",\n        MONTH: \"YYYY-MM\"\n    };\n    return hooks;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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ZzBCLFNBQVMsR0FBR087SUFDbEJ2MEIsTUFBTXFLLFVBQVUsR0FBRzZUO0lBQ25CbGUsTUFBTW1uQixVQUFVLEdBQUdBO0lBQ25Cbm5CLE1BQU1xVCxXQUFXLEdBQUdpaUI7SUFDcEJ0MUIsTUFBTW9ZLFdBQVcsR0FBR3FkO0lBQ3BCejFCLE1BQU1tZSxZQUFZLEdBQUdBO0lBQ3JCbmUsTUFBTXVlLFlBQVksR0FBR0E7SUFDckJ2ZSxNQUFNNGMsT0FBTyxHQUFHNkI7SUFDaEJ6ZSxNQUFNcVksYUFBYSxHQUFHbWQ7SUFDdEJ4MUIsTUFBTStOLGNBQWMsR0FBR0E7SUFDdkIvTixNQUFNNjRCLG9CQUFvQixHQUFHckI7SUFDN0J4M0IsTUFBTTg0QixxQkFBcUIsR0FBR3BCO0lBQzlCMTNCLE1BQU13c0IsY0FBYyxHQUFHUDtJQUN2QmpzQixNQUFNUyxTQUFTLEdBQUc2eUI7SUFFbEIsMkRBQTJEO0lBQzNEdHpCLE1BQU0rNEIsU0FBUyxHQUFHO1FBQ2RDLGdCQUFnQjtRQUNoQkMsd0JBQXdCO1FBQ3hCQyxtQkFBbUI7UUFDbkIxbUIsTUFBTTtRQUNOMm1CLE1BQU07UUFDTkMsY0FBYztRQUNkQyxTQUFTO1FBQ1R4bUIsTUFBTTtRQUNOTixPQUFPO0lBQ1g7SUFFQSxPQUFPdlM7QUFFWCIsInNvdXJjZXMiOlsid2VicGFjazovL2Utc2hvcC8uL25vZGVfbW9kdWxlcy9tb21lbnQvbW9tZW50LmpzPzkzODAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8hIG1vbWVudC5qc1xuLy8hIHZlcnNpb24gOiAyLjI5LjRcbi8vISBhdXRob3JzIDogVGltIFdvb2QsIElza3JlbiBDaGVybmV2LCBNb21lbnQuanMgY29udHJpYnV0b3JzXG4vLyEgbGljZW5zZSA6IE1JVFxuLy8hIG1vbWVudGpzLmNvbVxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgICBnbG9iYWwubW9tZW50ID0gZmFjdG9yeSgpXG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBob29rQ2FsbGJhY2s7XG5cbiAgICBmdW5jdGlvbiBob29rcygpIHtcbiAgICAgICAgcmV0dXJuIGhvb2tDYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgZG9uZSB0byByZWdpc3RlciB0aGUgbWV0aG9kIGNhbGxlZCB3aXRoIG1vbWVudCgpXG4gICAgLy8gd2l0aG91dCBjcmVhdGluZyBjaXJjdWxhciBkZXBlbmRlbmNpZXMuXG4gICAgZnVuY3Rpb24gc2V0SG9va0NhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgICAgIGhvb2tDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQXJyYXkoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGlucHV0IGluc3RhbmNlb2YgQXJyYXkgfHxcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEFycmF5XSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09iamVjdChpbnB1dCkge1xuICAgICAgICAvLyBJRTggd2lsbCB0cmVhdCB1bmRlZmluZWQgYW5kIG51bGwgYXMgb2JqZWN0IGlmIGl0IHdhc24ndCBmb3JcbiAgICAgICAgLy8gaW5wdXQgIT0gbnVsbFxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaW5wdXQgIT0gbnVsbCAmJlxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgT2JqZWN0XSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNPd25Qcm9wKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLCBiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09iamVjdEVtcHR5KG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBrO1xuICAgICAgICAgICAgZm9yIChrIGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKG9iaiwgaykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09PSB2b2lkIDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNOdW1iZXIoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IE51bWJlcl0nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXRlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBpbnB1dCBpbnN0YW5jZW9mIERhdGUgfHxcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IERhdGVdJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hcChhcnIsIGZuKSB7XG4gICAgICAgIHZhciByZXMgPSBbXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBhcnJMZW4gPSBhcnIubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyTGVuOyArK2kpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKGZuKGFycltpXSwgaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0ZW5kKGEsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBiKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChiLCBpKSkge1xuICAgICAgICAgICAgICAgIGFbaV0gPSBiW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc093blByb3AoYiwgJ3RvU3RyaW5nJykpIHtcbiAgICAgICAgICAgIGEudG9TdHJpbmcgPSBiLnRvU3RyaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc093blByb3AoYiwgJ3ZhbHVlT2YnKSkge1xuICAgICAgICAgICAgYS52YWx1ZU9mID0gYi52YWx1ZU9mO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCB0cnVlKS51dGMoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0UGFyc2luZ0ZsYWdzKCkge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGRlZXAgY2xvbmUgdGhpcyBvYmplY3QuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbXB0eTogZmFsc2UsXG4gICAgICAgICAgICB1bnVzZWRUb2tlbnM6IFtdLFxuICAgICAgICAgICAgdW51c2VkSW5wdXQ6IFtdLFxuICAgICAgICAgICAgb3ZlcmZsb3c6IC0yLFxuICAgICAgICAgICAgY2hhcnNMZWZ0T3ZlcjogMCxcbiAgICAgICAgICAgIG51bGxJbnB1dDogZmFsc2UsXG4gICAgICAgICAgICBpbnZhbGlkRXJhOiBudWxsLFxuICAgICAgICAgICAgaW52YWxpZE1vbnRoOiBudWxsLFxuICAgICAgICAgICAgaW52YWxpZEZvcm1hdDogZmFsc2UsXG4gICAgICAgICAgICB1c2VySW52YWxpZGF0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgaXNvOiBmYWxzZSxcbiAgICAgICAgICAgIHBhcnNlZERhdGVQYXJ0czogW10sXG4gICAgICAgICAgICBlcmE6IG51bGwsXG4gICAgICAgICAgICBtZXJpZGllbTogbnVsbCxcbiAgICAgICAgICAgIHJmYzI4MjI6IGZhbHNlLFxuICAgICAgICAgICAgd2Vla2RheU1pc21hdGNoOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJzaW5nRmxhZ3MobSkge1xuICAgICAgICBpZiAobS5fcGYgPT0gbnVsbCkge1xuICAgICAgICAgICAgbS5fcGYgPSBkZWZhdWx0UGFyc2luZ0ZsYWdzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0uX3BmO1xuICAgIH1cblxuICAgIHZhciBzb21lO1xuICAgIGlmIChBcnJheS5wcm90b3R5cGUuc29tZSkge1xuICAgICAgICBzb21lID0gQXJyYXkucHJvdG90eXBlLnNvbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc29tZSA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICAgICAgICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpLFxuICAgICAgICAgICAgICAgIGxlbiA9IHQubGVuZ3RoID4+PiAwLFxuICAgICAgICAgICAgICAgIGk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpIGluIHQgJiYgZnVuLmNhbGwodGhpcywgdFtpXSwgaSwgdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWYWxpZChtKSB7XG4gICAgICAgIGlmIChtLl9pc1ZhbGlkID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBmbGFncyA9IGdldFBhcnNpbmdGbGFncyhtKSxcbiAgICAgICAgICAgICAgICBwYXJzZWRQYXJ0cyA9IHNvbWUuY2FsbChmbGFncy5wYXJzZWREYXRlUGFydHMsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpICE9IG51bGw7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgaXNOb3dWYWxpZCA9XG4gICAgICAgICAgICAgICAgICAgICFpc05hTihtLl9kLmdldFRpbWUoKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3Mub3ZlcmZsb3cgPCAwICYmXG4gICAgICAgICAgICAgICAgICAgICFmbGFncy5lbXB0eSAmJlxuICAgICAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZEVyYSAmJlxuICAgICAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZE1vbnRoICYmXG4gICAgICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkV2Vla2RheSAmJlxuICAgICAgICAgICAgICAgICAgICAhZmxhZ3Mud2Vla2RheU1pc21hdGNoICYmXG4gICAgICAgICAgICAgICAgICAgICFmbGFncy5udWxsSW5wdXQgJiZcbiAgICAgICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRGb3JtYXQgJiZcbiAgICAgICAgICAgICAgICAgICAgIWZsYWdzLnVzZXJJbnZhbGlkYXRlZCAmJlxuICAgICAgICAgICAgICAgICAgICAoIWZsYWdzLm1lcmlkaWVtIHx8IChmbGFncy5tZXJpZGllbSAmJiBwYXJzZWRQYXJ0cykpO1xuXG4gICAgICAgICAgICBpZiAobS5fc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgaXNOb3dWYWxpZCA9XG4gICAgICAgICAgICAgICAgICAgIGlzTm93VmFsaWQgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuY2hhcnNMZWZ0T3ZlciA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy51bnVzZWRUb2tlbnMubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLmJpZ0hvdXIgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5pc0Zyb3plbiA9PSBudWxsIHx8ICFPYmplY3QuaXNGcm96ZW4obSkpIHtcbiAgICAgICAgICAgICAgICBtLl9pc1ZhbGlkID0gaXNOb3dWYWxpZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzTm93VmFsaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0uX2lzVmFsaWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSW52YWxpZChmbGFncykge1xuICAgICAgICB2YXIgbSA9IGNyZWF0ZVVUQyhOYU4pO1xuICAgICAgICBpZiAoZmxhZ3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgZXh0ZW5kKGdldFBhcnNpbmdGbGFncyhtKSwgZmxhZ3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLnVzZXJJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICAvLyBQbHVnaW5zIHRoYXQgYWRkIHByb3BlcnRpZXMgc2hvdWxkIGFsc28gYWRkIHRoZSBrZXkgaGVyZSAobnVsbCB2YWx1ZSksXG4gICAgLy8gc28gd2UgY2FuIHByb3Blcmx5IGNsb25lIG91cnNlbHZlcy5cbiAgICB2YXIgbW9tZW50UHJvcGVydGllcyA9IChob29rcy5tb21lbnRQcm9wZXJ0aWVzID0gW10pLFxuICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBjb3B5Q29uZmlnKHRvLCBmcm9tKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgcHJvcCxcbiAgICAgICAgICAgIHZhbCxcbiAgICAgICAgICAgIG1vbWVudFByb3BlcnRpZXNMZW4gPSBtb21lbnRQcm9wZXJ0aWVzLmxlbmd0aDtcblxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2lzQU1vbWVudE9iamVjdCkpIHtcbiAgICAgICAgICAgIHRvLl9pc0FNb21lbnRPYmplY3QgPSBmcm9tLl9pc0FNb21lbnRPYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pKSkge1xuICAgICAgICAgICAgdG8uX2kgPSBmcm9tLl9pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fZikpIHtcbiAgICAgICAgICAgIHRvLl9mID0gZnJvbS5fZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2wpKSB7XG4gICAgICAgICAgICB0by5fbCA9IGZyb20uX2w7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9zdHJpY3QpKSB7XG4gICAgICAgICAgICB0by5fc3RyaWN0ID0gZnJvbS5fc3RyaWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fdHptKSkge1xuICAgICAgICAgICAgdG8uX3R6bSA9IGZyb20uX3R6bTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2lzVVRDKSkge1xuICAgICAgICAgICAgdG8uX2lzVVRDID0gZnJvbS5faXNVVEM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9vZmZzZXQpKSB7XG4gICAgICAgICAgICB0by5fb2Zmc2V0ID0gZnJvbS5fb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fcGYpKSB7XG4gICAgICAgICAgICB0by5fcGYgPSBnZXRQYXJzaW5nRmxhZ3MoZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9sb2NhbGUpKSB7XG4gICAgICAgICAgICB0by5fbG9jYWxlID0gZnJvbS5fbG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vbWVudFByb3BlcnRpZXNMZW4gPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbW9tZW50UHJvcGVydGllc0xlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcHJvcCA9IG1vbWVudFByb3BlcnRpZXNbaV07XG4gICAgICAgICAgICAgICAgdmFsID0gZnJvbVtwcm9wXTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9bcHJvcF0gPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cblxuICAgIC8vIE1vbWVudCBwcm90b3R5cGUgb2JqZWN0XG4gICAgZnVuY3Rpb24gTW9tZW50KGNvbmZpZykge1xuICAgICAgICBjb3B5Q29uZmlnKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgIHRoaXMuX2QgPSBuZXcgRGF0ZShjb25maWcuX2QgIT0gbnVsbCA/IGNvbmZpZy5fZC5nZXRUaW1lKCkgOiBOYU4pO1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9kID0gbmV3IERhdGUoTmFOKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmV2ZW50IGluZmluaXRlIGxvb3AgaW4gY2FzZSB1cGRhdGVPZmZzZXQgY3JlYXRlcyBuZXcgbW9tZW50XG4gICAgICAgIC8vIG9iamVjdHMuXG4gICAgICAgIGlmICh1cGRhdGVJblByb2dyZXNzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc01vbWVudChvYmopIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIG9iaiBpbnN0YW5jZW9mIE1vbWVudCB8fCAob2JqICE9IG51bGwgJiYgb2JqLl9pc0FNb21lbnRPYmplY3QgIT0gbnVsbClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3YXJuKG1zZykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPT09IGZhbHNlICYmXG4gICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIGNvbnNvbGUud2FyblxuICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRpb24gd2FybmluZzogJyArIG1zZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXByZWNhdGUobXNnLCBmbikge1xuICAgICAgICB2YXIgZmlyc3RUaW1lID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gZXh0ZW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlcihudWxsLCBtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpcnN0VGltZSkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgICAgICAgICAgICAgIGFyZyxcbiAgICAgICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICBhcmdMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmdMZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBhcmcgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbaV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcgKz0gJ1xcblsnICsgaSArICddICc7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBhcmd1bWVudHNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcChhcmd1bWVudHNbMF0sIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnICs9IGtleSArICc6ICcgKyBhcmd1bWVudHNbMF1ba2V5XSArICcsICc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJnLnNsaWNlKDAsIC0yKTsgLy8gUmVtb3ZlIHRyYWlsaW5nIGNvbW1hIGFuZCBzcGFjZVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChhcmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICAgICBtc2cgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1xcbkFyZ3VtZW50czogJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKS5qb2luKCcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgRXJyb3IoKS5zdGFja1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZmlyc3RUaW1lID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSwgZm4pO1xuICAgIH1cblxuICAgIHZhciBkZXByZWNhdGlvbnMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCBtc2cpIHtcbiAgICAgICAgaWYgKGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgICAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobmFtZSwgbXNnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlcHJlY2F0aW9uc1tuYW1lXSkge1xuICAgICAgICAgICAgd2Fybihtc2cpO1xuICAgICAgICAgICAgZGVwcmVjYXRpb25zW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9IGZhbHNlO1xuICAgIGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciA9IG51bGw7XG5cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAodHlwZW9mIEZ1bmN0aW9uICE9PSAndW5kZWZpbmVkJyAmJiBpbnB1dCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB8fFxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldChjb25maWcpIHtcbiAgICAgICAgdmFyIHByb3AsIGk7XG4gICAgICAgIGZvciAoaSBpbiBjb25maWcpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGNvbmZpZywgaSkpIHtcbiAgICAgICAgICAgICAgICBwcm9wID0gY29uZmlnW2ldO1xuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbaV0gPSBwcm9wO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbJ18nICsgaV0gPSBwcm9wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG4gICAgICAgIC8vIExlbmllbnQgb3JkaW5hbCBwYXJzaW5nIGFjY2VwdHMganVzdCBhIG51bWJlciBpbiBhZGRpdGlvbiB0b1xuICAgICAgICAvLyBudW1iZXIgKyAocG9zc2libHkpIHN0dWZmIGNvbWluZyBmcm9tIF9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlLlxuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgXCJvcmRpbmFsUGFyc2VcIiBmYWxsYmFjayBpbiBuZXh0IG1ham9yIHJlbGVhc2UuXG4gICAgICAgIHRoaXMuX2RheU9mTW9udGhPcmRpbmFsUGFyc2VMZW5pZW50ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICh0aGlzLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlLnNvdXJjZSB8fCB0aGlzLl9vcmRpbmFsUGFyc2Uuc291cmNlKSArXG4gICAgICAgICAgICAgICAgJ3wnICtcbiAgICAgICAgICAgICAgICAvXFxkezEsMn0vLnNvdXJjZVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNoaWxkQ29uZmlnKSB7XG4gICAgICAgIHZhciByZXMgPSBleHRlbmQoe30sIHBhcmVudENvbmZpZyksXG4gICAgICAgICAgICBwcm9wO1xuICAgICAgICBmb3IgKHByb3AgaW4gY2hpbGRDb25maWcpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGNoaWxkQ29uZmlnLCBwcm9wKSkge1xuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChwYXJlbnRDb25maWdbcHJvcF0pICYmIGlzT2JqZWN0KGNoaWxkQ29uZmlnW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5kKHJlc1twcm9wXSwgcGFyZW50Q29uZmlnW3Byb3BdKTtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5kKHJlc1twcm9wXSwgY2hpbGRDb25maWdbcHJvcF0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGRDb25maWdbcHJvcF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSBjaGlsZENvbmZpZ1twcm9wXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcmVzW3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHByb3AgaW4gcGFyZW50Q29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgaGFzT3duUHJvcChwYXJlbnRDb25maWcsIHByb3ApICYmXG4gICAgICAgICAgICAgICAgIWhhc093blByb3AoY2hpbGRDb25maWcsIHByb3ApICYmXG4gICAgICAgICAgICAgICAgaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGNoYW5nZXMgdG8gcHJvcGVydGllcyBkb24ndCBtb2RpZnkgcGFyZW50IGNvbmZpZ1xuICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IGV4dGVuZCh7fSwgcmVzW3Byb3BdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIExvY2FsZShjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnNldChjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGtleXM7XG5cbiAgICBpZiAoT2JqZWN0LmtleXMpIHtcbiAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgICByZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcChvYmosIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRDYWxlbmRhciA9IHtcbiAgICAgICAgc2FtZURheTogJ1tUb2RheSBhdF0gTFQnLFxuICAgICAgICBuZXh0RGF5OiAnW1RvbW9ycm93IGF0XSBMVCcsXG4gICAgICAgIG5leHRXZWVrOiAnZGRkZCBbYXRdIExUJyxcbiAgICAgICAgbGFzdERheTogJ1tZZXN0ZXJkYXkgYXRdIExUJyxcbiAgICAgICAgbGFzdFdlZWs6ICdbTGFzdF0gZGRkZCBbYXRdIExUJyxcbiAgICAgICAgc2FtZUVsc2U6ICdMJyxcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2FsZW5kYXIoa2V5LCBtb20sIG5vdykge1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fY2FsZW5kYXJba2V5XSB8fCB0aGlzLl9jYWxlbmRhclsnc2FtZUVsc2UnXTtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24ob3V0cHV0KSA/IG91dHB1dC5jYWxsKG1vbSwgbm93KSA6IG91dHB1dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB6ZXJvRmlsbChudW1iZXIsIHRhcmdldExlbmd0aCwgZm9yY2VTaWduKSB7XG4gICAgICAgIHZhciBhYnNOdW1iZXIgPSAnJyArIE1hdGguYWJzKG51bWJlciksXG4gICAgICAgICAgICB6ZXJvc1RvRmlsbCA9IHRhcmdldExlbmd0aCAtIGFic051bWJlci5sZW5ndGgsXG4gICAgICAgICAgICBzaWduID0gbnVtYmVyID49IDA7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoc2lnbiA/IChmb3JjZVNpZ24gPyAnKycgOiAnJykgOiAnLScpICtcbiAgICAgICAgICAgIE1hdGgucG93KDEwLCBNYXRoLm1heCgwLCB6ZXJvc1RvRmlsbCkpLnRvU3RyaW5nKCkuc3Vic3RyKDEpICtcbiAgICAgICAgICAgIGFic051bWJlclxuICAgICAgICApO1xuICAgIH1cblxuICAgIHZhciBmb3JtYXR0aW5nVG9rZW5zID1cbiAgICAgICAgICAgIC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhbSGhdbW0oc3MpP3xNb3xNTT9NP00/fERvfERERG98REQ/RD9EP3xkZGQ/ZD98ZG8/fHdbb3x3XT98V1tvfFddP3xRbz98TnsxLDV9fFlZWVlZWXxZWVlZWXxZWVlZfFlZfHl7Miw0fXx5bz98Z2coZ2dnPyk/fEdHKEdHRz8pP3xlfEV8YXxBfGhoP3xISD98a2s/fG1tP3xzcz98U3sxLDl9fHh8WHx6ej98Wlo/fC4pL2csXG4gICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhMVFN8TFR8TEw/TD9MP3xsezEsNH0pL2csXG4gICAgICAgIGZvcm1hdEZ1bmN0aW9ucyA9IHt9LFxuICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9ucyA9IHt9O1xuXG4gICAgLy8gdG9rZW46ICAgICdNJ1xuICAgIC8vIHBhZGRlZDogICBbJ01NJywgMl1cbiAgICAvLyBvcmRpbmFsOiAgJ01vJ1xuICAgIC8vIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7IHRoaXMubW9udGgoKSArIDEgfVxuICAgIGZ1bmN0aW9uIGFkZEZvcm1hdFRva2VuKHRva2VuLCBwYWRkZWQsIG9yZGluYWwsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBmdW5jID0gY2FsbGJhY2s7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBmdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2NhbGxiYWNrXSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhZGRlZCkge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbcGFkZGVkWzBdXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gemVyb0ZpbGwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBwYWRkZWRbMV0sIHBhZGRlZFsyXSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcmRpbmFsKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1tvcmRpbmFsXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkub3JkaW5hbChcbiAgICAgICAgICAgICAgICAgICAgZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICAgICAgICAgICAgICB0b2tlblxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQubWF0Y2goL1xcW1tcXHNcXFNdLykpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9eXFxbfFxcXSQvZywgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9cXFxcL2csICcnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgICAgIHZhciBhcnJheSA9IGZvcm1hdC5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBsZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV0pIHtcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSByZW1vdmVGb3JtYXR0aW5nVG9rZW5zKGFycmF5W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobW9tKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gJycsXG4gICAgICAgICAgICAgICAgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSBpc0Z1bmN0aW9uKGFycmF5W2ldKVxuICAgICAgICAgICAgICAgICAgICA/IGFycmF5W2ldLmNhbGwobW9tLCBmb3JtYXQpXG4gICAgICAgICAgICAgICAgICAgIDogYXJyYXlbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIGZvcm1hdCBkYXRlIHVzaW5nIG5hdGl2ZSBkYXRlIG9iamVjdFxuICAgIGZ1bmN0aW9uIGZvcm1hdE1vbWVudChtLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFtLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG0ubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBleHBhbmRGb3JtYXQoZm9ybWF0LCBtLmxvY2FsZURhdGEoKSk7XG4gICAgICAgIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdID1cbiAgICAgICAgICAgIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdIHx8IG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpO1xuXG4gICAgICAgIHJldHVybiBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XShtKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHBhbmRGb3JtYXQoZm9ybWF0LCBsb2NhbGUpIHtcbiAgICAgICAgdmFyIGkgPSA1O1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2VucyhpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS5sb25nRGF0ZUZvcm1hdChpbnB1dCkgfHwgaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMubGFzdEluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiBsb2NhbEZvcm1hdHRpbmdUb2tlbnMudGVzdChmb3JtYXQpKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZShcbiAgICAgICAgICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMsXG4gICAgICAgICAgICAgICAgcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICBpIC09IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQgPSB7XG4gICAgICAgIExUUzogJ2g6bW06c3MgQScsXG4gICAgICAgIExUOiAnaDptbSBBJyxcbiAgICAgICAgTDogJ01NL0REL1lZWVknLFxuICAgICAgICBMTDogJ01NTU0gRCwgWVlZWScsXG4gICAgICAgIExMTDogJ01NTU0gRCwgWVlZWSBoOm1tIEEnLFxuICAgICAgICBMTExMOiAnZGRkZCwgTU1NTSBELCBZWVlZIGg6bW0gQScsXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvbmdEYXRlRm9ybWF0KGtleSkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSxcbiAgICAgICAgICAgIGZvcm1hdFVwcGVyID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5LnRvVXBwZXJDYXNlKCldO1xuXG4gICAgICAgIGlmIChmb3JtYXQgfHwgIWZvcm1hdFVwcGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSA9IGZvcm1hdFVwcGVyXG4gICAgICAgICAgICAubWF0Y2goZm9ybWF0dGluZ1Rva2VucylcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHRvaykge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgdG9rID09PSAnTU1NTScgfHxcbiAgICAgICAgICAgICAgICAgICAgdG9rID09PSAnTU0nIHx8XG4gICAgICAgICAgICAgICAgICAgIHRvayA9PT0gJ0REJyB8fFxuICAgICAgICAgICAgICAgICAgICB0b2sgPT09ICdkZGRkJ1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCcnKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdEludmFsaWREYXRlID0gJ0ludmFsaWQgZGF0ZSc7XG5cbiAgICBmdW5jdGlvbiBpbnZhbGlkRGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludmFsaWREYXRlO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0T3JkaW5hbCA9ICclZCcsXG4gICAgICAgIGRlZmF1bHREYXlPZk1vbnRoT3JkaW5hbFBhcnNlID0gL1xcZHsxLDJ9LztcblxuICAgIGZ1bmN0aW9uIG9yZGluYWwobnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcmRpbmFsLnJlcGxhY2UoJyVkJywgbnVtYmVyKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFJlbGF0aXZlVGltZSA9IHtcbiAgICAgICAgZnV0dXJlOiAnaW4gJXMnLFxuICAgICAgICBwYXN0OiAnJXMgYWdvJyxcbiAgICAgICAgczogJ2EgZmV3IHNlY29uZHMnLFxuICAgICAgICBzczogJyVkIHNlY29uZHMnLFxuICAgICAgICBtOiAnYSBtaW51dGUnLFxuICAgICAgICBtbTogJyVkIG1pbnV0ZXMnLFxuICAgICAgICBoOiAnYW4gaG91cicsXG4gICAgICAgIGhoOiAnJWQgaG91cnMnLFxuICAgICAgICBkOiAnYSBkYXknLFxuICAgICAgICBkZDogJyVkIGRheXMnLFxuICAgICAgICB3OiAnYSB3ZWVrJyxcbiAgICAgICAgd3c6ICclZCB3ZWVrcycsXG4gICAgICAgIE06ICdhIG1vbnRoJyxcbiAgICAgICAgTU06ICclZCBtb250aHMnLFxuICAgICAgICB5OiAnYSB5ZWFyJyxcbiAgICAgICAgeXk6ICclZCB5ZWFycycsXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJlbGF0aXZlVGltZShudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuX3JlbGF0aXZlVGltZVtzdHJpbmddO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihvdXRwdXQpXG4gICAgICAgICAgICA/IG91dHB1dChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpXG4gICAgICAgICAgICA6IG91dHB1dC5yZXBsYWNlKC8lZC9pLCBudW1iZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhc3RGdXR1cmUoZGlmZiwgb3V0cHV0KSB7XG4gICAgICAgIHZhciBmb3JtYXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbZGlmZiA+IDAgPyAnZnV0dXJlJyA6ICdwYXN0J107XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKGZvcm1hdCkgPyBmb3JtYXQob3V0cHV0KSA6IGZvcm1hdC5yZXBsYWNlKC8lcy9pLCBvdXRwdXQpO1xuICAgIH1cblxuICAgIHZhciBhbGlhc2VzID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRVbml0QWxpYXModW5pdCwgc2hvcnRoYW5kKSB7XG4gICAgICAgIHZhciBsb3dlckNhc2UgPSB1bml0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGFsaWFzZXNbbG93ZXJDYXNlXSA9IGFsaWFzZXNbbG93ZXJDYXNlICsgJ3MnXSA9IGFsaWFzZXNbc2hvcnRoYW5kXSA9IHVuaXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplVW5pdHModW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB1bml0cyA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gYWxpYXNlc1t1bml0c10gfHwgYWxpYXNlc1t1bml0cy50b0xvd2VyQ2FzZSgpXVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplT2JqZWN0VW5pdHMoaW5wdXRPYmplY3QpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IHt9LFxuICAgICAgICAgICAgbm9ybWFsaXplZFByb3AsXG4gICAgICAgICAgICBwcm9wO1xuXG4gICAgICAgIGZvciAocHJvcCBpbiBpbnB1dE9iamVjdCkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoaW5wdXRPYmplY3QsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZFByb3AgPSBub3JtYWxpemVVbml0cyhwcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZFByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZElucHV0W25vcm1hbGl6ZWRQcm9wXSA9IGlucHV0T2JqZWN0W3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkSW5wdXQ7XG4gICAgfVxuXG4gICAgdmFyIHByaW9yaXRpZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFVuaXRQcmlvcml0eSh1bml0LCBwcmlvcml0eSkge1xuICAgICAgICBwcmlvcml0aWVzW3VuaXRdID0gcHJpb3JpdHk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UHJpb3JpdGl6ZWRVbml0cyh1bml0c09iaikge1xuICAgICAgICB2YXIgdW5pdHMgPSBbXSxcbiAgICAgICAgICAgIHU7XG4gICAgICAgIGZvciAodSBpbiB1bml0c09iaikge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AodW5pdHNPYmosIHUpKSB7XG4gICAgICAgICAgICAgICAgdW5pdHMucHVzaCh7IHVuaXQ6IHUsIHByaW9yaXR5OiBwcmlvcml0aWVzW3VdIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHVuaXRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhLnByaW9yaXR5IC0gYi5wcmlvcml0eTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB1bml0cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgICAgICAgcmV0dXJuICh5ZWFyICUgNCA9PT0gMCAmJiB5ZWFyICUgMTAwICE9PSAwKSB8fCB5ZWFyICUgNDAwID09PSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic0Zsb29yKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgLy8gLTAgLT4gMFxuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpIHx8IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JbnQoYXJndW1lbnRGb3JDb2VyY2lvbikge1xuICAgICAgICB2YXIgY29lcmNlZE51bWJlciA9ICthcmd1bWVudEZvckNvZXJjaW9uLFxuICAgICAgICAgICAgdmFsdWUgPSAwO1xuXG4gICAgICAgIGlmIChjb2VyY2VkTnVtYmVyICE9PSAwICYmIGlzRmluaXRlKGNvZXJjZWROdW1iZXIpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGFic0Zsb29yKGNvZXJjZWROdW1iZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VHZXRTZXQodW5pdCwga2VlcFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzZXQkMSh0aGlzLCB1bml0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIGtlZXBUaW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldCh0aGlzLCB1bml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXQobW9tLCB1bml0KSB7XG4gICAgICAgIHJldHVybiBtb20uaXNWYWxpZCgpXG4gICAgICAgICAgICA/IG1vbS5fZFsnZ2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSgpXG4gICAgICAgICAgICA6IE5hTjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXQkMShtb20sIHVuaXQsIHZhbHVlKSB7XG4gICAgICAgIGlmIChtb20uaXNWYWxpZCgpICYmICFpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICB1bml0ID09PSAnRnVsbFllYXInICYmXG4gICAgICAgICAgICAgICAgaXNMZWFwWWVhcihtb20ueWVhcigpKSAmJlxuICAgICAgICAgICAgICAgIG1vbS5tb250aCgpID09PSAxICYmXG4gICAgICAgICAgICAgICAgbW9tLmRhdGUoKSA9PT0gMjlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdG9JbnQodmFsdWUpO1xuICAgICAgICAgICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XShcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIG1vbS5tb250aCgpLFxuICAgICAgICAgICAgICAgICAgICBkYXlzSW5Nb250aCh2YWx1ZSwgbW9tLm1vbnRoKCkpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIHN0cmluZ0dldCh1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1t1bml0c10oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdHJpbmdTZXQodW5pdHMsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdW5pdHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIHZhciBwcmlvcml0aXplZCA9IGdldFByaW9yaXRpemVkVW5pdHModW5pdHMpLFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgcHJpb3JpdGl6ZWRMZW4gPSBwcmlvcml0aXplZC5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcHJpb3JpdGl6ZWRMZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXNbcHJpb3JpdGl6ZWRbaV0udW5pdF0odW5pdHNbcHJpb3JpdGl6ZWRbaV0udW5pdF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzW3VuaXRzXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1t1bml0c10odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBtYXRjaDEgPSAvXFxkLywgLy8gICAgICAgMCAtIDlcbiAgICAgICAgbWF0Y2gyID0gL1xcZFxcZC8sIC8vICAgICAgMDAgLSA5OVxuICAgICAgICBtYXRjaDMgPSAvXFxkezN9LywgLy8gICAgIDAwMCAtIDk5OVxuICAgICAgICBtYXRjaDQgPSAvXFxkezR9LywgLy8gICAgMDAwMCAtIDk5OTlcbiAgICAgICAgbWF0Y2g2ID0gL1srLV0/XFxkezZ9LywgLy8gLTk5OTk5OSAtIDk5OTk5OVxuICAgICAgICBtYXRjaDF0bzIgPSAvXFxkXFxkPy8sIC8vICAgICAgIDAgLSA5OVxuICAgICAgICBtYXRjaDN0bzQgPSAvXFxkXFxkXFxkXFxkPy8sIC8vICAgICA5OTkgLSA5OTk5XG4gICAgICAgIG1hdGNoNXRvNiA9IC9cXGRcXGRcXGRcXGRcXGRcXGQ/LywgLy8gICA5OTk5OSAtIDk5OTk5OVxuICAgICAgICBtYXRjaDF0bzMgPSAvXFxkezEsM30vLCAvLyAgICAgICAwIC0gOTk5XG4gICAgICAgIG1hdGNoMXRvNCA9IC9cXGR7MSw0fS8sIC8vICAgICAgIDAgLSA5OTk5XG4gICAgICAgIG1hdGNoMXRvNiA9IC9bKy1dP1xcZHsxLDZ9LywgLy8gLTk5OTk5OSAtIDk5OTk5OVxuICAgICAgICBtYXRjaFVuc2lnbmVkID0gL1xcZCsvLCAvLyAgICAgICAwIC0gaW5mXG4gICAgICAgIG1hdGNoU2lnbmVkID0gL1srLV0/XFxkKy8sIC8vICAgIC1pbmYgLSBpbmZcbiAgICAgICAgbWF0Y2hPZmZzZXQgPSAvWnxbKy1dXFxkXFxkOj9cXGRcXGQvZ2ksIC8vICswMDowMCAtMDA6MDAgKzAwMDAgLTAwMDAgb3IgWlxuICAgICAgICBtYXRjaFNob3J0T2Zmc2V0ID0gL1p8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8vZ2ksIC8vICswMCAtMDAgKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG4gICAgICAgIG1hdGNoVGltZXN0YW1wID0gL1srLV0/XFxkKyhcXC5cXGR7MSwzfSk/LywgLy8gMTIzNDU2Nzg5IDEyMzQ1Njc4OS4xMjNcbiAgICAgICAgLy8gYW55IHdvcmQgKG9yIHR3bykgY2hhcmFjdGVycyBvciBudW1iZXJzIGluY2x1ZGluZyB0d28vdGhyZWUgd29yZCBtb250aCBpbiBhcmFiaWMuXG4gICAgICAgIC8vIGluY2x1ZGVzIHNjb3R0aXNoIGdhZWxpYyB0d28gd29yZCBhbmQgaHlwaGVuYXRlZCBtb250aHNcbiAgICAgICAgbWF0Y2hXb3JkID1cbiAgICAgICAgICAgIC9bMC05XXswLDI1Nn1bJ2EtelxcdTAwQTAtXFx1MDVGRlxcdTA3MDAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkYwN1xcdUZGMTAtXFx1RkZFRl17MSwyNTZ9fFtcXHUwNjAwLVxcdTA2RkZcXC9dezEsMjU2fShcXHMqP1tcXHUwNjAwLVxcdTA2RkZdezEsMjU2fSl7MSwyfS9pLFxuICAgICAgICByZWdleGVzO1xuXG4gICAgcmVnZXhlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkUmVnZXhUb2tlbih0b2tlbiwgcmVnZXgsIHN0cmljdFJlZ2V4KSB7XG4gICAgICAgIHJlZ2V4ZXNbdG9rZW5dID0gaXNGdW5jdGlvbihyZWdleClcbiAgICAgICAgICAgID8gcmVnZXhcbiAgICAgICAgICAgIDogZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGVEYXRhKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaXNTdHJpY3QgJiYgc3RyaWN0UmVnZXggPyBzdHJpY3RSZWdleCA6IHJlZ2V4O1xuICAgICAgICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcChyZWdleGVzLCB0b2tlbikpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHVuZXNjYXBlRm9ybWF0KHRva2VuKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVnZXhlc1t0b2tlbl0oY29uZmlnLl9zdHJpY3QsIGNvbmZpZy5fbG9jYWxlKTtcbiAgICB9XG5cbiAgICAvLyBDb2RlIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNTYxNDkzL2lzLXRoZXJlLWEtcmVnZXhwLWVzY2FwZS1mdW5jdGlvbi1pbi1qYXZhc2NyaXB0XG4gICAgZnVuY3Rpb24gdW5lc2NhcGVGb3JtYXQocykge1xuICAgICAgICByZXR1cm4gcmVnZXhFc2NhcGUoXG4gICAgICAgICAgICBzXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoJ1xcXFwnLCAnJylcbiAgICAgICAgICAgICAgICAucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgICAgL1xcXFwoXFxbKXxcXFxcKFxcXSl8XFxbKFteXFxdXFxbXSopXFxdfFxcXFwoLikvZyxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKG1hdGNoZWQsIHAxLCBwMiwgcDMsIHA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcDEgfHwgcDIgfHwgcDMgfHwgcDQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVnZXhFc2NhcGUocykge1xuICAgICAgICByZXR1cm4gcy5yZXBsYWNlKC9bLVxcL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKTtcbiAgICB9XG5cbiAgICB2YXIgdG9rZW5zID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRQYXJzZVRva2VuKHRva2VuLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGZ1bmMgPSBjYWxsYmFjayxcbiAgICAgICAgICAgIHRva2VuTGVuO1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdG9rZW4gPSBbdG9rZW5dO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc051bWJlcihjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbY2FsbGJhY2tdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0b2tlbkxlbiA9IHRva2VuLmxlbmd0aDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2VuTGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRva2Vuc1t0b2tlbltpXV0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkV2Vla1BhcnNlVG9rZW4odG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgICAgIGNvbmZpZy5fdyA9IGNvbmZpZy5fdyB8fCB7fTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGlucHV0LCBjb25maWcuX3csIGNvbmZpZywgdG9rZW4pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgaW5wdXQsIGNvbmZpZykge1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCAmJiBoYXNPd25Qcm9wKHRva2VucywgdG9rZW4pKSB7XG4gICAgICAgICAgICB0b2tlbnNbdG9rZW5dKGlucHV0LCBjb25maWcuX2EsIGNvbmZpZywgdG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFlFQVIgPSAwLFxuICAgICAgICBNT05USCA9IDEsXG4gICAgICAgIERBVEUgPSAyLFxuICAgICAgICBIT1VSID0gMyxcbiAgICAgICAgTUlOVVRFID0gNCxcbiAgICAgICAgU0VDT05EID0gNSxcbiAgICAgICAgTUlMTElTRUNPTkQgPSA2LFxuICAgICAgICBXRUVLID0gNyxcbiAgICAgICAgV0VFS0RBWSA9IDg7XG5cbiAgICBmdW5jdGlvbiBtb2QobiwgeCkge1xuICAgICAgICByZXR1cm4gKChuICUgeCkgKyB4KSAlIHg7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4T2Y7XG5cbiAgICBpZiAoQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIHtcbiAgICAgICAgaW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4T2YgPSBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgLy8gSSBrbm93XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNbaV0gPT09IG8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XG4gICAgICAgIGlmIChpc05hTih5ZWFyKSB8fCBpc05hTihtb250aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1vZE1vbnRoID0gbW9kKG1vbnRoLCAxMik7XG4gICAgICAgIHllYXIgKz0gKG1vbnRoIC0gbW9kTW9udGgpIC8gMTI7XG4gICAgICAgIHJldHVybiBtb2RNb250aCA9PT0gMVxuICAgICAgICAgICAgPyBpc0xlYXBZZWFyKHllYXIpXG4gICAgICAgICAgICAgICAgPyAyOVxuICAgICAgICAgICAgICAgIDogMjhcbiAgICAgICAgICAgIDogMzEgLSAoKG1vZE1vbnRoICUgNykgJSAyKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignTScsIFsnTU0nLCAyXSwgJ01vJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb250aCgpICsgMTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHNTaG9ydCh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ01NTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHModGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnbW9udGgnLCAnTScpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnbW9udGgnLCA4KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ00nLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NTScsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUubW9udGhzU2hvcnRSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG4gICAgYWRkUmVnZXhUb2tlbignTU1NTScsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUubW9udGhzUmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ00nLCAnTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNT05USF0gPSB0b0ludChpbnB1dCkgLSAxO1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ01NTScsICdNTU1NJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgdmFyIG1vbnRoID0gY29uZmlnLl9sb2NhbGUubW9udGhzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgICAgIC8vIGlmIHdlIGRpZG4ndCBmaW5kIGEgbW9udGggbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkLlxuICAgICAgICBpZiAobW9udGggIT0gbnVsbCkge1xuICAgICAgICAgICAgYXJyYXlbTU9OVEhdID0gbW9udGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkTW9udGggPSBpbnB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNb250aHMgPVxuICAgICAgICAgICAgJ0phbnVhcnlfRmVicnVhcnlfTWFyY2hfQXByaWxfTWF5X0p1bmVfSnVseV9BdWd1c3RfU2VwdGVtYmVyX09jdG9iZXJfTm92ZW1iZXJfRGVjZW1iZXInLnNwbGl0KFxuICAgICAgICAgICAgICAgICdfJ1xuICAgICAgICAgICAgKSxcbiAgICAgICAgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0ID1cbiAgICAgICAgICAgICdKYW5fRmViX01hcl9BcHJfTWF5X0p1bl9KdWxfQXVnX1NlcF9PY3RfTm92X0RlYycuc3BsaXQoJ18nKSxcbiAgICAgICAgTU9OVEhTX0lOX0ZPUk1BVCA9IC9EW29EXT8oXFxbW15cXFtcXF1dKlxcXXxcXHMpK01NTU0/LyxcbiAgICAgICAgZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXggPSBtYXRjaFdvcmQsXG4gICAgICAgIGRlZmF1bHRNb250aHNSZWdleCA9IG1hdGNoV29yZDtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRocyhtLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHMpXG4gICAgICAgICAgICAgICAgPyB0aGlzLl9tb250aHNcbiAgICAgICAgICAgICAgICA6IHRoaXMuX21vbnRoc1snc3RhbmRhbG9uZSddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocylcbiAgICAgICAgICAgID8gdGhpcy5fbW9udGhzW20ubW9udGgoKV1cbiAgICAgICAgICAgIDogdGhpcy5fbW9udGhzW1xuICAgICAgICAgICAgICAgICAgKHRoaXMuX21vbnRocy5pc0Zvcm1hdCB8fCBNT05USFNfSU5fRk9STUFUKS50ZXN0KGZvcm1hdClcbiAgICAgICAgICAgICAgICAgICAgICA/ICdmb3JtYXQnXG4gICAgICAgICAgICAgICAgICAgICAgOiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICAgICAgXVttLm1vbnRoKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRoc1Nob3J0KG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KVxuICAgICAgICAgICAgICAgID8gdGhpcy5fbW9udGhzU2hvcnRcbiAgICAgICAgICAgICAgICA6IHRoaXMuX21vbnRoc1Nob3J0WydzdGFuZGFsb25lJ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzU2hvcnQpXG4gICAgICAgICAgICA/IHRoaXMuX21vbnRoc1Nob3J0W20ubW9udGgoKV1cbiAgICAgICAgICAgIDogdGhpcy5fbW9udGhzU2hvcnRbXG4gICAgICAgICAgICAgICAgICBNT05USFNfSU5fRk9STUFULnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXG4gICAgICAgICAgICAgIF1bbS5tb250aCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVTdHJpY3RQYXJzZShtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgaWksXG4gICAgICAgICAgICBtb20sXG4gICAgICAgICAgICBsbGMgPSBtb250aE5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBub3QgdXNlZFxuICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyArK2kpIHtcbiAgICAgICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gdGhpcy5tb250aHNTaG9ydChcbiAgICAgICAgICAgICAgICAgICAgbW9tLFxuICAgICAgICAgICAgICAgICAgICAnJ1xuICAgICAgICAgICAgICAgICkudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSB0aGlzLm1vbnRocyhtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ01NTScpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ01NTScpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHNQYXJzZShtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlU3RyaWN0UGFyc2UuY2FsbCh0aGlzLCBtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IGFkZCBzb3J0aW5nXG4gICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXJcbiAgICAgICAgLy8gc2VlIHNvcnRpbmcgaW4gY29tcHV0ZU1vbnRoc1BhcnNlXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICAgICAgICAgJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJyxcbiAgICAgICAgICAgICAgICAgICAgJ2knXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICAgICAgICAgJ14nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLFxuICAgICAgICAgICAgICAgICAgICAnaSdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzdHJpY3QgJiYgIXRoaXMuX21vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgcmVnZXggPVxuICAgICAgICAgICAgICAgICAgICAnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKSArICd8XicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBzdHJpY3QgJiZcbiAgICAgICAgICAgICAgICBmb3JtYXQgPT09ICdNTU1NJyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICBzdHJpY3QgJiZcbiAgICAgICAgICAgICAgICBmb3JtYXQgPT09ICdNTU0nICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmIHRoaXMuX21vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gc2V0TW9udGgobW9tLCB2YWx1ZSkge1xuICAgICAgICB2YXIgZGF5T2ZNb250aDtcblxuICAgICAgICBpZiAoIW1vbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIC8vIE5vIG9wXG4gICAgICAgICAgICByZXR1cm4gbW9tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICgvXlxcZCskLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdG9JbnQodmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG1vbS5sb2NhbGVEYXRhKCkubW9udGhzUGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IEFub3RoZXIgc2lsZW50IGZhaWx1cmU/XG4gICAgICAgICAgICAgICAgaWYgKCFpc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkYXlPZk1vbnRoID0gTWF0aC5taW4obW9tLmRhdGUoKSwgZGF5c0luTW9udGgobW9tLnllYXIoKSwgdmFsdWUpKTtcbiAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArICdNb250aCddKHZhbHVlLCBkYXlPZk1vbnRoKTtcbiAgICAgICAgcmV0dXJuIG1vbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRNb250aCh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0TW9udGgodGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0KHRoaXMsICdNb250aCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGF5c0luTW9udGgoKSB7XG4gICAgICAgIHJldHVybiBkYXlzSW5Nb250aCh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb250aHNTaG9ydFJlZ2V4KGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZU1vbnRoc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNTaG9ydFJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdFxuICAgICAgICAgICAgICAgID8gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleFxuICAgICAgICAgICAgICAgIDogdGhpcy5fbW9udGhzU2hvcnRSZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbnRoc1JlZ2V4KGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZU1vbnRoc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNSZWdleCA9IGRlZmF1bHRNb250aHNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTdHJpY3RSZWdleCAmJiBpc1N0cmljdFxuICAgICAgICAgICAgICAgID8gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXhcbiAgICAgICAgICAgICAgICA6IHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZU1vbnRoc1BhcnNlKCkge1xuICAgICAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2hvcnRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIGxvbmdQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIG1peGVkUGllY2VzID0gW10sXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgbW9tO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgIHNob3J0UGllY2VzLnB1c2godGhpcy5tb250aHNTaG9ydChtb20sICcnKSk7XG4gICAgICAgICAgICBsb25nUGllY2VzLnB1c2godGhpcy5tb250aHMobW9tLCAnJykpO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcbiAgICAgICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgICAgICBzaG9ydFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICBzaG9ydFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKHNob3J0UGllY2VzW2ldKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXNbaV0gPSByZWdleEVzY2FwZShsb25nUGllY2VzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMjQ7IGkrKykge1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShtaXhlZFBpZWNlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9tb250aHNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRSZWdleCA9IHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICB0aGlzLl9tb250aHNTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAnXignICsgbG9uZ1BpZWNlcy5qb2luKCd8JykgKyAnKScsXG4gICAgICAgICAgICAnaSdcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLFxuICAgICAgICAgICAgJ2knXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1knLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB5ID0gdGhpcy55ZWFyKCk7XG4gICAgICAgIHJldHVybiB5IDw9IDk5OTkgPyB6ZXJvRmlsbCh5LCA0KSA6ICcrJyArIHk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZJywgNF0sIDAsICd5ZWFyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWScsIDVdLCAwLCAneWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVlZJywgNiwgdHJ1ZV0sIDAsICd5ZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3llYXInLCAneScpO1xuXG4gICAgLy8gUFJJT1JJVElFU1xuXG4gICAgYWRkVW5pdFByaW9yaXR5KCd5ZWFyJywgMSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdZJywgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVknLCBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWVknLCBtYXRjaDF0bzYsIG1hdGNoNik7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWVlZJywgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ1lZWVlZJywgJ1lZWVlZWSddLCBZRUFSKTtcbiAgICBhZGRQYXJzZVRva2VuKCdZWVlZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtZRUFSXSA9XG4gICAgICAgICAgICBpbnB1dC5sZW5ndGggPT09IDIgPyBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCkgOiB0b0ludChpbnB1dCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W1lFQVJdID0gaG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1knLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W1lFQVJdID0gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIGZ1bmN0aW9uIGRheXNJblllYXIoeWVhcikge1xuICAgICAgICByZXR1cm4gaXNMZWFwWWVhcih5ZWFyKSA/IDM2NiA6IDM2NTtcbiAgICB9XG5cbiAgICAvLyBIT09LU1xuXG4gICAgaG9va3MucGFyc2VUd29EaWdpdFllYXIgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRvSW50KGlucHV0KSArICh0b0ludChpbnB1dCkgPiA2OCA/IDE5MDAgOiAyMDAwKTtcbiAgICB9O1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldFllYXIgPSBtYWtlR2V0U2V0KCdGdWxsWWVhcicsIHRydWUpO1xuXG4gICAgZnVuY3Rpb24gZ2V0SXNMZWFwWWVhcigpIHtcbiAgICAgICAgcmV0dXJuIGlzTGVhcFllYXIodGhpcy55ZWFyKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZURhdGUoeSwgbSwgZCwgaCwgTSwgcywgbXMpIHtcbiAgICAgICAgLy8gY2FuJ3QganVzdCBhcHBseSgpIHRvIGNyZWF0ZSBhIGRhdGU6XG4gICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS8xODEzNDhcbiAgICAgICAgdmFyIGRhdGU7XG4gICAgICAgIC8vIHRoZSBkYXRlIGNvbnN0cnVjdG9yIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDApIHtcbiAgICAgICAgICAgIC8vIHByZXNlcnZlIGxlYXAgeWVhcnMgdXNpbmcgYSBmdWxsIDQwMCB5ZWFyIGN5Y2xlLCB0aGVuIHJlc2V0XG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoeSArIDQwMCwgbSwgZCwgaCwgTSwgcywgbXMpO1xuICAgICAgICAgICAgaWYgKGlzRmluaXRlKGRhdGUuZ2V0RnVsbFllYXIoKSkpIHtcbiAgICAgICAgICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHksIG0sIGQsIGgsIE0sIHMsIG1zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVUQ0RhdGUoeSkge1xuICAgICAgICB2YXIgZGF0ZSwgYXJncztcbiAgICAgICAgLy8gdGhlIERhdGUuVVRDIGZ1bmN0aW9uIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDApIHtcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgICAgIGFyZ3NbMF0gPSB5ICsgNDAwO1xuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDLmFwcGx5KG51bGwsIGFyZ3MpKTtcbiAgICAgICAgICAgIGlmIChpc0Zpbml0ZShkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpKSB7XG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQy5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIC8vIHN0YXJ0LW9mLWZpcnN0LXdlZWsgLSBzdGFydC1vZi15ZWFyXG4gICAgZnVuY3Rpb24gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSB7XG4gICAgICAgIHZhciAvLyBmaXJzdC13ZWVrIGRheSAtLSB3aGljaCBqYW51YXJ5IGlzIGFsd2F5cyBpbiB0aGUgZmlyc3Qgd2VlayAoNCBmb3IgaXNvLCAxIGZvciBvdGhlcilcbiAgICAgICAgICAgIGZ3ZCA9IDcgKyBkb3cgLSBkb3ksXG4gICAgICAgICAgICAvLyBmaXJzdC13ZWVrIGRheSBsb2NhbCB3ZWVrZGF5IC0tIHdoaWNoIGxvY2FsIHdlZWtkYXkgaXMgZndkXG4gICAgICAgICAgICBmd2RsdyA9ICg3ICsgY3JlYXRlVVRDRGF0ZSh5ZWFyLCAwLCBmd2QpLmdldFVUQ0RheSgpIC0gZG93KSAlIDc7XG5cbiAgICAgICAgcmV0dXJuIC1md2RsdyArIGZ3ZCAtIDE7XG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZSNDYWxjdWxhdGluZ19hX2RhdGVfZ2l2ZW5fdGhlX3llYXIuMkNfd2Vla19udW1iZXJfYW5kX3dlZWtkYXlcbiAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla3MoeWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIGxvY2FsV2Vla2RheSA9ICg3ICsgd2Vla2RheSAtIGRvdykgJSA3LFxuICAgICAgICAgICAgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSksXG4gICAgICAgICAgICBkYXlPZlllYXIgPSAxICsgNyAqICh3ZWVrIC0gMSkgKyBsb2NhbFdlZWtkYXkgKyB3ZWVrT2Zmc2V0LFxuICAgICAgICAgICAgcmVzWWVhcixcbiAgICAgICAgICAgIHJlc0RheU9mWWVhcjtcblxuICAgICAgICBpZiAoZGF5T2ZZZWFyIDw9IDApIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSB5ZWFyIC0gMTtcbiAgICAgICAgICAgIHJlc0RheU9mWWVhciA9IGRheXNJblllYXIocmVzWWVhcikgKyBkYXlPZlllYXI7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyKSkge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXIgKyAxO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyIC0gZGF5c0luWWVhcih5ZWFyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSB5ZWFyO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXI6IHJlc1llYXIsXG4gICAgICAgICAgICBkYXlPZlllYXI6IHJlc0RheU9mWWVhcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3ZWVrT2ZZZWFyKG1vbSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQobW9tLnllYXIoKSwgZG93LCBkb3kpLFxuICAgICAgICAgICAgd2VlayA9IE1hdGguZmxvb3IoKG1vbS5kYXlPZlllYXIoKSAtIHdlZWtPZmZzZXQgLSAxKSAvIDcpICsgMSxcbiAgICAgICAgICAgIHJlc1dlZWssXG4gICAgICAgICAgICByZXNZZWFyO1xuXG4gICAgICAgIGlmICh3ZWVrIDwgMSkge1xuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCkgLSAxO1xuICAgICAgICAgICAgcmVzV2VlayA9IHdlZWsgKyB3ZWVrc0luWWVhcihyZXNZZWFyLCBkb3csIGRveSk7XG4gICAgICAgIH0gZWxzZSBpZiAod2VlayA+IHdlZWtzSW5ZZWFyKG1vbS55ZWFyKCksIGRvdywgZG95KSkge1xuICAgICAgICAgICAgcmVzV2VlayA9IHdlZWsgLSB3ZWVrc0luWWVhcihtb20ueWVhcigpLCBkb3csIGRveSk7XG4gICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKSArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKTtcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdlZWs6IHJlc1dlZWssXG4gICAgICAgICAgICB5ZWFyOiByZXNZZWFyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtzSW5ZZWFyKHllYXIsIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcbiAgICAgICAgICAgIHdlZWtPZmZzZXROZXh0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIgKyAxLCBkb3csIGRveSk7XG4gICAgICAgIHJldHVybiAoZGF5c0luWWVhcih5ZWFyKSAtIHdlZWtPZmZzZXQgKyB3ZWVrT2Zmc2V0TmV4dCkgLyA3O1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCd3JywgWyd3dycsIDJdLCAnd28nLCAnd2VlaycpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdXJywgWydXVycsIDJdLCAnV28nLCAnaXNvV2VlaycpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrJywgJ3cnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWsnLCAnVycpO1xuXG4gICAgLy8gUFJJT1JJVElFU1xuXG4gICAgYWRkVW5pdFByaW9yaXR5KCd3ZWVrJywgNSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrJywgNSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCd3JywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCd3dycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdXJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdXVycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFxuICAgICAgICBbJ3cnLCAnd3cnLCAnVycsICdXVyddLFxuICAgICAgICBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDEpXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrKG1vbSkge1xuICAgICAgICByZXR1cm4gd2Vla09mWWVhcihtb20sIHRoaXMuX3dlZWsuZG93LCB0aGlzLl93ZWVrLmRveSkud2VlaztcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWsgPSB7XG4gICAgICAgIGRvdzogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgIGRveTogNiwgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNnRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVGaXJzdERheU9mV2VlaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG93O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZZZWFyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3k7XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2VlayhpbnB1dCkge1xuICAgICAgICB2YXIgd2VlayA9IHRoaXMubG9jYWxlRGF0YSgpLndlZWsodGhpcyk7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09XZWVrKGlucHV0KSB7XG4gICAgICAgIHZhciB3ZWVrID0gd2Vla09mWWVhcih0aGlzLCAxLCA0KS53ZWVrO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2QnLCAwLCAnZG8nLCAnZGF5Jyk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c01pbih0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzU2hvcnQodGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXModGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdlJywgMCwgMCwgJ3dlZWtkYXknKTtcbiAgICBhZGRGb3JtYXRUb2tlbignRScsIDAsIDAsICdpc29XZWVrZGF5Jyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RheScsICdkJyk7XG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrZGF5JywgJ2UnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWtkYXknLCAnRScpO1xuXG4gICAgLy8gUFJJT1JJVFlcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2RheScsIDExKTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWtkYXknLCAxMSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrZGF5JywgMTEpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignZCcsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignZScsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignRScsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignZGQnLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzTWluUmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2RkZCcsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdkZGRkJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1JlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZGQnLCAnZGRkJywgJ2RkZGQnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gY29uZmlnLl9sb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGdldCBhIHdlZWtkYXkgbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkXG4gICAgICAgIGlmICh3ZWVrZGF5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHdlZWsuZCA9IHdlZWtkYXk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkV2Vla2RheSA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2QnLCAnZScsICdFJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIGZ1bmN0aW9uIHBhcnNlV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTmFOKGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpbnB1dCA9IGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlSXNvV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpICUgNyB8fCA3O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc05hTihpbnB1dCkgPyBudWxsIDogaW5wdXQ7XG4gICAgfVxuXG4gICAgLy8gTE9DQUxFU1xuICAgIGZ1bmN0aW9uIHNoaWZ0V2Vla2RheXMod3MsIG4pIHtcbiAgICAgICAgcmV0dXJuIHdzLnNsaWNlKG4sIDcpLmNvbmNhdCh3cy5zbGljZSgwLCBuKSk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5cyA9XG4gICAgICAgICAgICAnU3VuZGF5X01vbmRheV9UdWVzZGF5X1dlZG5lc2RheV9UaHVyc2RheV9GcmlkYXlfU2F0dXJkYXknLnNwbGl0KCdfJyksXG4gICAgICAgIGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0ID0gJ1N1bl9Nb25fVHVlX1dlZF9UaHVfRnJpX1NhdCcuc3BsaXQoJ18nKSxcbiAgICAgICAgZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluID0gJ1N1X01vX1R1X1dlX1RoX0ZyX1NhJy5zcGxpdCgnXycpLFxuICAgICAgICBkZWZhdWx0V2Vla2RheXNSZWdleCA9IG1hdGNoV29yZCxcbiAgICAgICAgZGVmYXVsdFdlZWtkYXlzU2hvcnRSZWdleCA9IG1hdGNoV29yZCxcbiAgICAgICAgZGVmYXVsdFdlZWtkYXlzTWluUmVnZXggPSBtYXRjaFdvcmQ7XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5cyhtLCBmb3JtYXQpIHtcbiAgICAgICAgdmFyIHdlZWtkYXlzID0gaXNBcnJheSh0aGlzLl93ZWVrZGF5cylcbiAgICAgICAgICAgID8gdGhpcy5fd2Vla2RheXNcbiAgICAgICAgICAgIDogdGhpcy5fd2Vla2RheXNbXG4gICAgICAgICAgICAgICAgICBtICYmIG0gIT09IHRydWUgJiYgdGhpcy5fd2Vla2RheXMuaXNGb3JtYXQudGVzdChmb3JtYXQpXG4gICAgICAgICAgICAgICAgICAgICAgPyAnZm9ybWF0J1xuICAgICAgICAgICAgICAgICAgICAgIDogJ3N0YW5kYWxvbmUnXG4gICAgICAgICAgICAgIF07XG4gICAgICAgIHJldHVybiBtID09PSB0cnVlXG4gICAgICAgICAgICA/IHNoaWZ0V2Vla2RheXMod2Vla2RheXMsIHRoaXMuX3dlZWsuZG93KVxuICAgICAgICAgICAgOiBtXG4gICAgICAgICAgICA/IHdlZWtkYXlzW20uZGF5KCldXG4gICAgICAgICAgICA6IHdlZWtkYXlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzU2hvcnQobSkge1xuICAgICAgICByZXR1cm4gbSA9PT0gdHJ1ZVxuICAgICAgICAgICAgPyBzaGlmdFdlZWtkYXlzKHRoaXMuX3dlZWtkYXlzU2hvcnQsIHRoaXMuX3dlZWsuZG93KVxuICAgICAgICAgICAgOiBtXG4gICAgICAgICAgICA/IHRoaXMuX3dlZWtkYXlzU2hvcnRbbS5kYXkoKV1cbiAgICAgICAgICAgIDogdGhpcy5fd2Vla2RheXNTaG9ydDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c01pbihtKSB7XG4gICAgICAgIHJldHVybiBtID09PSB0cnVlXG4gICAgICAgICAgICA/IHNoaWZ0V2Vla2RheXModGhpcy5fd2Vla2RheXNNaW4sIHRoaXMuX3dlZWsuZG93KVxuICAgICAgICAgICAgOiBtXG4gICAgICAgICAgICA/IHRoaXMuX3dlZWtkYXlzTWluW20uZGF5KCldXG4gICAgICAgICAgICA6IHRoaXMuX3dlZWtkYXlzTWluO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVN0cmljdFBhcnNlJDEod2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgaWksXG4gICAgICAgICAgICBtb20sXG4gICAgICAgICAgICBsbGMgPSB3ZWVrZGF5TmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZSA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgKytpKSB7XG4gICAgICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzTWluKFxuICAgICAgICAgICAgICAgICAgICBtb20sXG4gICAgICAgICAgICAgICAgICAgICcnXG4gICAgICAgICAgICAgICAgKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNTaG9ydChcbiAgICAgICAgICAgICAgICAgICAgbW9tLFxuICAgICAgICAgICAgICAgICAgICAnJ1xuICAgICAgICAgICAgICAgICkudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5cyhtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09ICdkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdkZGRkJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09ICdkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNQYXJzZSh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVN0cmljdFBhcnNlJDEuY2FsbCh0aGlzLCB3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcblxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAgICAgICAgICdeJyArIHRoaXMud2Vla2RheXMobW9tLCAnJykucmVwbGFjZSgnLicsICdcXFxcLj8nKSArICckJyxcbiAgICAgICAgICAgICAgICAgICAgJ2knXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgICAgICAnXicgKyB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICdcXFxcLj8nKSArICckJyxcbiAgICAgICAgICAgICAgICAgICAgJ2knXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICAgICAgICAgJ14nICsgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLFxuICAgICAgICAgICAgICAgICAgICAnaSdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgcmVnZXggPVxuICAgICAgICAgICAgICAgICAgICAnXicgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndlZWtkYXlzKG1vbSwgJycpICtcbiAgICAgICAgICAgICAgICAgICAgJ3xeJyArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKSArXG4gICAgICAgICAgICAgICAgICAgICd8XicgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHN0cmljdCAmJlxuICAgICAgICAgICAgICAgIGZvcm1hdCA9PT0gJ2RkZGQnICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICBzdHJpY3QgJiZcbiAgICAgICAgICAgICAgICBmb3JtYXQgPT09ICdkZGQnICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgc3RyaWN0ICYmXG4gICAgICAgICAgICAgICAgZm9ybWF0ID09PSAnZGQnICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fd2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0RGF5T2ZXZWVrKGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF5ID0gdGhpcy5faXNVVEMgPyB0aGlzLl9kLmdldFVUQ0RheSgpIDogdGhpcy5fZC5nZXREYXkoKTtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlucHV0ID0gcGFyc2VXZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQoaW5wdXQgLSBkYXksICdkJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGF5O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrKGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2Vla2RheSA9ICh0aGlzLmRheSgpICsgNyAtIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdykgJSA3O1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWtkYXkgOiB0aGlzLmFkZChpbnB1dCAtIHdlZWtkYXksICdkJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPRGF5T2ZXZWVrKGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGJlaGF2ZXMgdGhlIHNhbWUgYXMgbW9tZW50I2RheSBleGNlcHRcbiAgICAgICAgLy8gYXMgYSBnZXR0ZXIsIHJldHVybnMgNyBpbnN0ZWFkIG9mIDAgKDEtNyByYW5nZSBpbnN0ZWFkIG9mIDAtNilcbiAgICAgICAgLy8gYXMgYSBzZXR0ZXIsIHN1bmRheSBzaG91bGQgYmVsb25nIHRvIHRoZSBwcmV2aW91cyB3ZWVrLlxuXG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgd2Vla2RheSA9IHBhcnNlSXNvV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF5KHRoaXMuZGF5KCkgJSA3ID8gd2Vla2RheSA6IHdlZWtkYXkgLSA3KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRheSgpIHx8IDc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3ZWVrZGF5c1JlZ2V4KGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1JlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCAmJiBpc1N0cmljdFxuICAgICAgICAgICAgICAgID8gdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleFxuICAgICAgICAgICAgICAgIDogdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtkYXlzU2hvcnRSZWdleChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlV2Vla2RheXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzU2hvcnRSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzU2hvcnRSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggJiYgaXNTdHJpY3RcbiAgICAgICAgICAgICAgICA/IHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleFxuICAgICAgICAgICAgICAgIDogdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla2RheXNNaW5SZWdleChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlV2Vla2RheXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNNaW5SZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5SZWdleCA9IGRlZmF1bHRXZWVrZGF5c01pblJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggJiYgaXNTdHJpY3RcbiAgICAgICAgICAgICAgICA/IHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXhcbiAgICAgICAgICAgICAgICA6IHRoaXMuX3dlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlV2Vla2RheXNQYXJzZSgpIHtcbiAgICAgICAgZnVuY3Rpb24gY21wTGVuUmV2KGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1pblBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgc2hvcnRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIGxvbmdQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIG1peGVkUGllY2VzID0gW10sXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgbW9tLFxuICAgICAgICAgICAgbWlucCxcbiAgICAgICAgICAgIHNob3J0cCxcbiAgICAgICAgICAgIGxvbmdwO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgIG1pbnAgPSByZWdleEVzY2FwZSh0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpKTtcbiAgICAgICAgICAgIHNob3J0cCA9IHJlZ2V4RXNjYXBlKHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKSk7XG4gICAgICAgICAgICBsb25ncCA9IHJlZ2V4RXNjYXBlKHRoaXMud2Vla2RheXMobW9tLCAnJykpO1xuICAgICAgICAgICAgbWluUGllY2VzLnB1c2gobWlucCk7XG4gICAgICAgICAgICBzaG9ydFBpZWNlcy5wdXNoKHNob3J0cCk7XG4gICAgICAgICAgICBsb25nUGllY2VzLnB1c2gobG9uZ3ApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChtaW5wKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2goc2hvcnRwKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2gobG9uZ3ApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgd2Vla2RheSAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlciBpdFxuICAgICAgICAvLyB3aWxsIG1hdGNoIHRoZSBsb25nZXIgcGllY2UuXG4gICAgICAgIG1pblBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIHNob3J0UGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbG9uZ1BpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIG1peGVkUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcblxuICAgICAgICB0aGlzLl93ZWVrZGF5c1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWl4ZWRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXggPSB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICB0aGlzLl93ZWVrZGF5c01pblJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcblxuICAgICAgICB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJyxcbiAgICAgICAgICAgICdpJ1xuICAgICAgICApO1xuICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJ14oJyArIHNob3J0UGllY2VzLmpvaW4oJ3wnKSArICcpJyxcbiAgICAgICAgICAgICdpJ1xuICAgICAgICApO1xuICAgICAgICB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICdeKCcgKyBtaW5QaWVjZXMuam9pbignfCcpICsgJyknLFxuICAgICAgICAgICAgJ2knXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgZnVuY3Rpb24gaEZvcm1hdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG91cnMoKSAlIDEyIHx8IDEyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGtGb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvdXJzKCkgfHwgMjQ7XG4gICAgfVxuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0gnLCBbJ0hIJywgMl0sIDAsICdob3VyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ2gnLCBbJ2hoJywgMl0sIDAsIGhGb3JtYXQpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdrJywgWydraycsIDJdLCAwLCBrRm9ybWF0KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdobW0nLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnJyArIGhGb3JtYXQuYXBwbHkodGhpcykgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMik7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignaG1tc3MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAnJyArXG4gICAgICAgICAgICBoRm9ybWF0LmFwcGx5KHRoaXMpICtcbiAgICAgICAgICAgIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKSArXG4gICAgICAgICAgICB6ZXJvRmlsbCh0aGlzLnNlY29uZHMoKSwgMilcbiAgICAgICAgKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdIbW0nLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnJyArIHRoaXMuaG91cnMoKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdIbW1zcycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICcnICtcbiAgICAgICAgICAgIHRoaXMuaG91cnMoKSArXG4gICAgICAgICAgICB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMikgK1xuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5zZWNvbmRzKCksIDIpXG4gICAgICAgICk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBtZXJpZGllbSh0b2tlbiwgbG93ZXJjYXNlKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubWVyaWRpZW0oXG4gICAgICAgICAgICAgICAgdGhpcy5ob3VycygpLFxuICAgICAgICAgICAgICAgIHRoaXMubWludXRlcygpLFxuICAgICAgICAgICAgICAgIGxvd2VyY2FzZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbWVyaWRpZW0oJ2EnLCB0cnVlKTtcbiAgICBtZXJpZGllbSgnQScsIGZhbHNlKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnaG91cicsICdoJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnaG91cicsIDEzKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGZ1bmN0aW9uIG1hdGNoTWVyaWRpZW0oaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLl9tZXJpZGllbVBhcnNlO1xuICAgIH1cblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2EnLCBtYXRjaE1lcmlkaWVtKTtcbiAgICBhZGRSZWdleFRva2VuKCdBJywgbWF0Y2hNZXJpZGllbSk7XG4gICAgYWRkUmVnZXhUb2tlbignSCcsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignaCcsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignaycsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignSEgnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignaGgnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbigna2snLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbiAgICBhZGRSZWdleFRva2VuKCdobW0nLCBtYXRjaDN0bzQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2htbXNzJywgbWF0Y2g1dG82KTtcbiAgICBhZGRSZWdleFRva2VuKCdIbW0nLCBtYXRjaDN0bzQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0htbXNzJywgbWF0Y2g1dG82KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydIJywgJ0hIJ10sIEhPVVIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydrJywgJ2trJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIga0lucHV0ID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICBhcnJheVtIT1VSXSA9IGtJbnB1dCA9PT0gMjQgPyAwIDoga0lucHV0O1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oWydhJywgJ0EnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5faXNQbSA9IGNvbmZpZy5fbG9jYWxlLmlzUE0oaW5wdXQpO1xuICAgICAgICBjb25maWcuX21lcmlkaWVtID0gaW5wdXQ7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2gnLCAnaGgnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdobW0nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIHBvcyA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvcykpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvcykpO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdobW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zMSA9IGlucHV0Lmxlbmd0aCAtIDQsXG4gICAgICAgICAgICBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczEsIDIpKTtcbiAgICAgICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ0htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignSG1tc3MnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIHBvczEgPSBpbnB1dC5sZW5ndGggLSA0LFxuICAgICAgICAgICAgcG9zMiA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvczEpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MxLCAyKSk7XG4gICAgICAgIGFycmF5W1NFQ09ORF0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMikpO1xuICAgIH0pO1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlSXNQTShpbnB1dCkge1xuICAgICAgICAvLyBJRTggUXVpcmtzIE1vZGUgJiBJRTcgU3RhbmRhcmRzIE1vZGUgZG8gbm90IGFsbG93IGFjY2Vzc2luZyBzdHJpbmdzIGxpa2UgYXJyYXlzXG4gICAgICAgIC8vIFVzaW5nIGNoYXJBdCBzaG91bGQgYmUgbW9yZSBjb21wYXRpYmxlLlxuICAgICAgICByZXR1cm4gKGlucHV0ICsgJycpLnRvTG93ZXJDYXNlKCkuY2hhckF0KDApID09PSAncCc7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlID0gL1thcF1cXC4/bT9cXC4/L2ksXG4gICAgICAgIC8vIFNldHRpbmcgdGhlIGhvdXIgc2hvdWxkIGtlZXAgdGhlIHRpbWUsIGJlY2F1c2UgdGhlIHVzZXIgZXhwbGljaXRseVxuICAgICAgICAvLyBzcGVjaWZpZWQgd2hpY2ggaG91ciB0aGV5IHdhbnQuIFNvIHRyeWluZyB0byBtYWludGFpbiB0aGUgc2FtZSBob3VyIChpblxuICAgICAgICAvLyBhIG5ldyB0aW1lem9uZSkgbWFrZXMgc2Vuc2UuIEFkZGluZy9zdWJ0cmFjdGluZyBob3VycyBkb2VzIG5vdCBmb2xsb3dcbiAgICAgICAgLy8gdGhpcyBydWxlLlxuICAgICAgICBnZXRTZXRIb3VyID0gbWFrZUdldFNldCgnSG91cnMnLCB0cnVlKTtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZU1lcmlkaWVtKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XG4gICAgICAgIGlmIChob3VycyA+IDExKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdwbScgOiAnUE0nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAnYW0nIDogJ0FNJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBiYXNlQ29uZmlnID0ge1xuICAgICAgICBjYWxlbmRhcjogZGVmYXVsdENhbGVuZGFyLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdDogZGVmYXVsdExvbmdEYXRlRm9ybWF0LFxuICAgICAgICBpbnZhbGlkRGF0ZTogZGVmYXVsdEludmFsaWREYXRlLFxuICAgICAgICBvcmRpbmFsOiBkZWZhdWx0T3JkaW5hbCxcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogZGVmYXVsdERheU9mTW9udGhPcmRpbmFsUGFyc2UsXG4gICAgICAgIHJlbGF0aXZlVGltZTogZGVmYXVsdFJlbGF0aXZlVGltZSxcblxuICAgICAgICBtb250aHM6IGRlZmF1bHRMb2NhbGVNb250aHMsXG4gICAgICAgIG1vbnRoc1Nob3J0OiBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQsXG5cbiAgICAgICAgd2VlazogZGVmYXVsdExvY2FsZVdlZWssXG5cbiAgICAgICAgd2Vla2RheXM6IGRlZmF1bHRMb2NhbGVXZWVrZGF5cyxcbiAgICAgICAgd2Vla2RheXNNaW46IGRlZmF1bHRMb2NhbGVXZWVrZGF5c01pbixcbiAgICAgICAgd2Vla2RheXNTaG9ydDogZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQsXG5cbiAgICAgICAgbWVyaWRpZW1QYXJzZTogZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2UsXG4gICAgfTtcblxuICAgIC8vIGludGVybmFsIHN0b3JhZ2UgZm9yIGxvY2FsZSBjb25maWcgZmlsZXNcbiAgICB2YXIgbG9jYWxlcyA9IHt9LFxuICAgICAgICBsb2NhbGVGYW1pbGllcyA9IHt9LFxuICAgICAgICBnbG9iYWxMb2NhbGU7XG5cbiAgICBmdW5jdGlvbiBjb21tb25QcmVmaXgoYXJyMSwgYXJyMikge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIG1pbmwgPSBNYXRoLm1pbihhcnIxLmxlbmd0aCwgYXJyMi5sZW5ndGgpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbWlubDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoYXJyMVtpXSAhPT0gYXJyMltpXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW5sO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2FsZShrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleSA/IGtleS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ18nLCAnLScpIDoga2V5O1xuICAgIH1cblxuICAgIC8vIHBpY2sgdGhlIGxvY2FsZSBmcm9tIHRoZSBhcnJheVxuICAgIC8vIHRyeSBbJ2VuLWF1JywgJ2VuLWdiJ10gYXMgJ2VuLWF1JywgJ2VuLWdiJywgJ2VuJywgYXMgaW4gbW92ZSB0aHJvdWdoIHRoZSBsaXN0IHRyeWluZyBlYWNoXG4gICAgLy8gc3Vic3RyaW5nIGZyb20gbW9zdCBzcGVjaWZpYyB0byBsZWFzdCwgYnV0IG1vdmUgdG8gdGhlIG5leHQgYXJyYXkgaXRlbSBpZiBpdCdzIGEgbW9yZSBzcGVjaWZpYyB2YXJpYW50IHRoYW4gdGhlIGN1cnJlbnQgcm9vdFxuICAgIGZ1bmN0aW9uIGNob29zZUxvY2FsZShuYW1lcykge1xuICAgICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgICBqLFxuICAgICAgICAgICAgbmV4dCxcbiAgICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgICAgIHNwbGl0O1xuXG4gICAgICAgIHdoaWxlIChpIDwgbmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzcGxpdCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpXSkuc3BsaXQoJy0nKTtcbiAgICAgICAgICAgIGogPSBzcGxpdC5sZW5ndGg7XG4gICAgICAgICAgICBuZXh0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2kgKyAxXSk7XG4gICAgICAgICAgICBuZXh0ID0gbmV4dCA/IG5leHQuc3BsaXQoJy0nKSA6IG51bGw7XG4gICAgICAgICAgICB3aGlsZSAoaiA+IDApIHtcbiAgICAgICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKHNwbGl0LnNsaWNlKDAsIGopLmpvaW4oJy0nKSk7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIG5leHQgJiZcbiAgICAgICAgICAgICAgICAgICAgbmV4dC5sZW5ndGggPj0gaiAmJlxuICAgICAgICAgICAgICAgICAgICBjb21tb25QcmVmaXgoc3BsaXQsIG5leHQpID49IGogLSAxXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vdGhlIG5leHQgYXJyYXkgaXRlbSBpcyBiZXR0ZXIgdGhhbiBhIHNoYWxsb3dlciBzdWJzdHJpbmcgb2YgdGhpcyBvbmVcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTG9jYWxlTmFtZVNhbmUobmFtZSkge1xuICAgICAgICAvLyBQcmV2ZW50IG5hbWVzIHRoYXQgbG9vayBsaWtlIGZpbGVzeXN0ZW0gcGF0aHMsIGkuZSBjb250YWluICcvJyBvciAnXFwnXG4gICAgICAgIHJldHVybiBuYW1lLm1hdGNoKCdeW14vXFxcXFxcXFxdKiQnKSAhPSBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRMb2NhbGUobmFtZSkge1xuICAgICAgICB2YXIgb2xkTG9jYWxlID0gbnVsbCxcbiAgICAgICAgICAgIGFsaWFzZWRSZXF1aXJlO1xuICAgICAgICAvLyBUT0RPOiBGaW5kIGEgYmV0dGVyIHdheSB0byByZWdpc3RlciBhbmQgbG9hZCBhbGwgdGhlIGxvY2FsZXMgaW4gTm9kZVxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBsb2NhbGVzW25hbWVdID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICBtb2R1bGUgJiZcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzICYmXG4gICAgICAgICAgICBpc0xvY2FsZU5hbWVTYW5lKG5hbWUpXG4gICAgICAgICkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvbGRMb2NhbGUgPSBnbG9iYWxMb2NhbGUuX2FiYnI7XG4gICAgICAgICAgICAgICAgYWxpYXNlZFJlcXVpcmUgPSByZXF1aXJlO1xuICAgICAgICAgICAgICAgIGFsaWFzZWRSZXF1aXJlKCcuL2xvY2FsZS8nICsgbmFtZSk7XG4gICAgICAgICAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG9sZExvY2FsZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gbWFyayBhcyBub3QgZm91bmQgdG8gYXZvaWQgcmVwZWF0aW5nIGV4cGVuc2l2ZSBmaWxlIHJlcXVpcmUgY2FsbCBjYXVzaW5nIGhpZ2ggQ1BVXG4gICAgICAgICAgICAgICAgLy8gd2hlbiB0cnlpbmcgdG8gZmluZCBlbi1VUywgZW5fVVMsIGVuLXVzIGZvciBldmVyeSBmb3JtYXQgY2FsbFxuICAgICAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBudWxsOyAvLyBudWxsIG1lYW5zIG5vdCBmb3VuZFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBsb2FkIGxvY2FsZSBhbmQgdGhlbiBzZXQgdGhlIGdsb2JhbCBsb2NhbGUuICBJZlxuICAgIC8vIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGluLCBpdCB3aWxsIHNpbXBseSByZXR1cm4gdGhlIGN1cnJlbnQgZ2xvYmFsXG4gICAgLy8gbG9jYWxlIGtleS5cbiAgICBmdW5jdGlvbiBnZXRTZXRHbG9iYWxMb2NhbGUoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGdldExvY2FsZShrZXkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZGVmaW5lTG9jYWxlKGtleSwgdmFsdWVzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAvLyBtb21lbnQuZHVyYXRpb24uX2xvY2FsZSA9IG1vbWVudC5fbG9jYWxlID0gZGF0YTtcbiAgICAgICAgICAgICAgICBnbG9iYWxMb2NhbGUgPSBkYXRhO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICAgICAgICAgICAgICAvL3dhcm4gdXNlciBpZiBhcmd1bWVudHMgYXJlIHBhc3NlZCBidXQgdGhlIGxvY2FsZSBjb3VsZCBub3QgYmUgc2V0XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgICAgICAgICdMb2NhbGUgJyArIGtleSArICcgbm90IGZvdW5kLiBEaWQgeW91IGZvcmdldCB0byBsb2FkIGl0PydcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlLl9hYmJyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmluZUxvY2FsZShuYW1lLCBjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGxvY2FsZSxcbiAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBiYXNlQ29uZmlnO1xuICAgICAgICAgICAgY29uZmlnLmFiYnIgPSBuYW1lO1xuICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZShcbiAgICAgICAgICAgICAgICAgICAgJ2RlZmluZUxvY2FsZU92ZXJyaWRlJyxcbiAgICAgICAgICAgICAgICAgICAgJ3VzZSBtb21lbnQudXBkYXRlTG9jYWxlKGxvY2FsZU5hbWUsIGNvbmZpZykgdG8gY2hhbmdlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FuIGV4aXN0aW5nIGxvY2FsZS4gbW9tZW50LmRlZmluZUxvY2FsZShsb2NhbGVOYW1lLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjb25maWcpIHNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIGNyZWF0aW5nIGEgbmV3IGxvY2FsZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9kZWZpbmUtbG9jYWxlLyBmb3IgbW9yZSBpbmZvLidcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbbmFtZV0uX2NvbmZpZztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdLl9jb25maWc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShjb25maWcucGFyZW50TG9jYWxlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGUuX2NvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbG9jYWxlRmFtaWxpZXNbY29uZmlnLnBhcmVudExvY2FsZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlRmFtaWxpZXNbY29uZmlnLnBhcmVudExvY2FsZV0ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbmV3IExvY2FsZShtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjb25maWcpKTtcblxuICAgICAgICAgICAgaWYgKGxvY2FsZUZhbWlsaWVzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxlRmFtaWxpZXNbbmFtZV0uZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgICAgICBkZWZpbmVMb2NhbGUoeC5uYW1lLCB4LmNvbmZpZyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXQgZm9yIG5vdzogYWxzbyBzZXQgdGhlIGxvY2FsZVxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHdlIHNldCB0aGUgbG9jYWxlIEFGVEVSIGFsbCBjaGlsZCBsb2NhbGVzIGhhdmUgYmVlblxuICAgICAgICAgICAgLy8gY3JlYXRlZCwgc28gd2Ugd29uJ3QgZW5kIHVwIHdpdGggdGhlIGNoaWxkIGxvY2FsZSBzZXQuXG4gICAgICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUobmFtZSk7XG5cbiAgICAgICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdXNlZnVsIGZvciB0ZXN0aW5nXG4gICAgICAgICAgICBkZWxldGUgbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlTG9jYWxlKG5hbWUsIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbGUsXG4gICAgICAgICAgICAgICAgdG1wTG9jYWxlLFxuICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XG5cbiAgICAgICAgICAgIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwgJiYgbG9jYWxlc1tuYW1lXS5wYXJlbnRMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBleGlzdGluZyBjaGlsZCBsb2NhbGUgaW4tcGxhY2UgdG8gYXZvaWQgbWVtb3J5LWxlYWtzXG4gICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXS5zZXQobWVyZ2VDb25maWdzKGxvY2FsZXNbbmFtZV0uX2NvbmZpZywgY29uZmlnKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE1FUkdFXG4gICAgICAgICAgICAgICAgdG1wTG9jYWxlID0gbG9hZExvY2FsZShuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAodG1wTG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gdG1wTG9jYWxlLl9jb25maWc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbmZpZyA9IG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgaWYgKHRtcExvY2FsZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZUxvY2FsZSBpcyBjYWxsZWQgZm9yIGNyZWF0aW5nIGEgbmV3IGxvY2FsZVxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgYWJiciBzbyBpdCB3aWxsIGhhdmUgYSBuYW1lIChnZXR0ZXJzIHJldHVyblxuICAgICAgICAgICAgICAgICAgICAvLyB1bmRlZmluZWQgb3RoZXJ3aXNlKS5cbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmFiYnIgPSBuYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2NhbGUgPSBuZXcgTG9jYWxlKGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgbG9jYWxlLnBhcmVudExvY2FsZSA9IGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdCBmb3Igbm93OiBhbHNvIHNldCB0aGUgbG9jYWxlXG4gICAgICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUobmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBwYXNzIG51bGwgZm9yIGNvbmZpZyB0byB1bnVwZGF0ZSwgdXNlZnVsIGZvciB0ZXN0c1xuICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09IGdldFNldEdsb2JhbExvY2FsZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgfVxuXG4gICAgLy8gcmV0dXJucyBsb2NhbGUgZGF0YVxuICAgIGZ1bmN0aW9uIGdldExvY2FsZShrZXkpIHtcbiAgICAgICAgdmFyIGxvY2FsZTtcblxuICAgICAgICBpZiAoa2V5ICYmIGtleS5fbG9jYWxlICYmIGtleS5fbG9jYWxlLl9hYmJyKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXkuX2xvY2FsZS5fYWJicjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0FycmF5KGtleSkpIHtcbiAgICAgICAgICAgIC8vc2hvcnQtY2lyY3VpdCBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5ID0gW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hvb3NlTG9jYWxlKGtleSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdExvY2FsZXMoKSB7XG4gICAgICAgIHJldHVybiBrZXlzKGxvY2FsZXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrT3ZlcmZsb3cobSkge1xuICAgICAgICB2YXIgb3ZlcmZsb3csXG4gICAgICAgICAgICBhID0gbS5fYTtcblxuICAgICAgICBpZiAoYSAmJiBnZXRQYXJzaW5nRmxhZ3MobSkub3ZlcmZsb3cgPT09IC0yKSB7XG4gICAgICAgICAgICBvdmVyZmxvdyA9XG4gICAgICAgICAgICAgICAgYVtNT05USF0gPCAwIHx8IGFbTU9OVEhdID4gMTFcbiAgICAgICAgICAgICAgICAgICAgPyBNT05USFxuICAgICAgICAgICAgICAgICAgICA6IGFbREFURV0gPCAxIHx8IGFbREFURV0gPiBkYXlzSW5Nb250aChhW1lFQVJdLCBhW01PTlRIXSlcbiAgICAgICAgICAgICAgICAgICAgPyBEQVRFXG4gICAgICAgICAgICAgICAgICAgIDogYVtIT1VSXSA8IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICBhW0hPVVJdID4gMjQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAoYVtIT1VSXSA9PT0gMjQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKGFbTUlOVVRFXSAhPT0gMCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYVtTRUNPTkRdICE9PSAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhW01JTExJU0VDT05EXSAhPT0gMCkpXG4gICAgICAgICAgICAgICAgICAgID8gSE9VUlxuICAgICAgICAgICAgICAgICAgICA6IGFbTUlOVVRFXSA8IDAgfHwgYVtNSU5VVEVdID4gNTlcbiAgICAgICAgICAgICAgICAgICAgPyBNSU5VVEVcbiAgICAgICAgICAgICAgICAgICAgOiBhW1NFQ09ORF0gPCAwIHx8IGFbU0VDT05EXSA+IDU5XG4gICAgICAgICAgICAgICAgICAgID8gU0VDT05EXG4gICAgICAgICAgICAgICAgICAgIDogYVtNSUxMSVNFQ09ORF0gPCAwIHx8IGFbTUlMTElTRUNPTkRdID4gOTk5XG4gICAgICAgICAgICAgICAgICAgID8gTUlMTElTRUNPTkRcbiAgICAgICAgICAgICAgICAgICAgOiAtMTtcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dEYXlPZlllYXIgJiZcbiAgICAgICAgICAgICAgICAob3ZlcmZsb3cgPCBZRUFSIHx8IG92ZXJmbG93ID4gREFURSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gREFURTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla3MgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrZGF5ICYmIG92ZXJmbG93ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gV0VFS0RBWTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICAvLyBpc28gODYwMSByZWdleFxuICAgIC8vIDAwMDAtMDAtMDAgMDAwMC1XMDAgb3IgMDAwMC1XMDAtMCArIFQgKyAwMCBvciAwMDowMCBvciAwMDowMDowMCBvciAwMDowMDowMC4wMDAgKyArMDA6MDAgb3IgKzAwMDAgb3IgKzAwKVxuICAgIHZhciBleHRlbmRlZElzb1JlZ2V4ID1cbiAgICAgICAgICAgIC9eXFxzKigoPzpbKy1dXFxkezZ9fFxcZHs0fSktKD86XFxkXFxkLVxcZFxcZHxXXFxkXFxkLVxcZHxXXFxkXFxkfFxcZFxcZFxcZHxcXGRcXGQpKSg/OihUfCApKFxcZFxcZCg/OjpcXGRcXGQoPzo6XFxkXFxkKD86Wy4sXVxcZCspPyk/KT8pKFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPyQvLFxuICAgICAgICBiYXNpY0lzb1JlZ2V4ID1cbiAgICAgICAgICAgIC9eXFxzKigoPzpbKy1dXFxkezZ9fFxcZHs0fSkoPzpcXGRcXGRcXGRcXGR8V1xcZFxcZFxcZHxXXFxkXFxkfFxcZFxcZFxcZHxcXGRcXGR8KSkoPzooVHwgKShcXGRcXGQoPzpcXGRcXGQoPzpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoWystXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/JC8sXG4gICAgICAgIHR6UmVnZXggPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy8sXG4gICAgICAgIGlzb0RhdGVzID0gW1xuICAgICAgICAgICAgWydZWVlZWVktTU0tREQnLCAvWystXVxcZHs2fS1cXGRcXGQtXFxkXFxkL10sXG4gICAgICAgICAgICBbJ1lZWVktTU0tREQnLCAvXFxkezR9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICAgICAgICAgIFsnR0dHRy1bV11XVy1FJywgL1xcZHs0fS1XXFxkXFxkLVxcZC9dLFxuICAgICAgICAgICAgWydHR0dHLVtXXVdXJywgL1xcZHs0fS1XXFxkXFxkLywgZmFsc2VdLFxuICAgICAgICAgICAgWydZWVlZLURERCcsIC9cXGR7NH0tXFxkezN9L10sXG4gICAgICAgICAgICBbJ1lZWVktTU0nLCAvXFxkezR9LVxcZFxcZC8sIGZhbHNlXSxcbiAgICAgICAgICAgIFsnWVlZWVlZTU1ERCcsIC9bKy1dXFxkezEwfS9dLFxuICAgICAgICAgICAgWydZWVlZTU1ERCcsIC9cXGR7OH0vXSxcbiAgICAgICAgICAgIFsnR0dHR1tXXVdXRScsIC9cXGR7NH1XXFxkezN9L10sXG4gICAgICAgICAgICBbJ0dHR0dbV11XVycsIC9cXGR7NH1XXFxkezJ9LywgZmFsc2VdLFxuICAgICAgICAgICAgWydZWVlZREREJywgL1xcZHs3fS9dLFxuICAgICAgICAgICAgWydZWVlZTU0nLCAvXFxkezZ9LywgZmFsc2VdLFxuICAgICAgICAgICAgWydZWVlZJywgL1xcZHs0fS8sIGZhbHNlXSxcbiAgICAgICAgXSxcbiAgICAgICAgLy8gaXNvIHRpbWUgZm9ybWF0cyBhbmQgcmVnZXhlc1xuICAgICAgICBpc29UaW1lcyA9IFtcbiAgICAgICAgICAgIFsnSEg6bW06c3MuU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZFxcLlxcZCsvXSxcbiAgICAgICAgICAgIFsnSEg6bW06c3MsU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZCxcXGQrL10sXG4gICAgICAgICAgICBbJ0hIOm1tOnNzJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkL10sXG4gICAgICAgICAgICBbJ0hIOm1tJywgL1xcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgICAgIFsnSEhtbXNzLlNTU1MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkXFwuXFxkKy9dLFxuICAgICAgICAgICAgWydISG1tc3MsU1NTUycsIC9cXGRcXGRcXGRcXGRcXGRcXGQsXFxkKy9dLFxuICAgICAgICAgICAgWydISG1tc3MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkL10sXG4gICAgICAgICAgICBbJ0hIbW0nLCAvXFxkXFxkXFxkXFxkL10sXG4gICAgICAgICAgICBbJ0hIJywgL1xcZFxcZC9dLFxuICAgICAgICBdLFxuICAgICAgICBhc3BOZXRKc29uUmVnZXggPSAvXlxcLz9EYXRlXFwoKC0/XFxkKykvaSxcbiAgICAgICAgLy8gUkZDIDI4MjIgcmVnZXg6IEZvciBkZXRhaWxzIHNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMjgyMiNzZWN0aW9uLTMuM1xuICAgICAgICByZmMyODIyID1cbiAgICAgICAgICAgIC9eKD86KE1vbnxUdWV8V2VkfFRodXxGcml8U2F0fFN1biksP1xccyk/KFxcZHsxLDJ9KVxccyhKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYylcXHMoXFxkezIsNH0pXFxzKFxcZFxcZCk6KFxcZFxcZCkoPzo6KFxcZFxcZCkpP1xccyg/OihVVHxHTVR8W0VDTVBdW1NEXVQpfChbWnpdKXwoWystXVxcZHs0fSkpJC8sXG4gICAgICAgIG9ic09mZnNldHMgPSB7XG4gICAgICAgICAgICBVVDogMCxcbiAgICAgICAgICAgIEdNVDogMCxcbiAgICAgICAgICAgIEVEVDogLTQgKiA2MCxcbiAgICAgICAgICAgIEVTVDogLTUgKiA2MCxcbiAgICAgICAgICAgIENEVDogLTUgKiA2MCxcbiAgICAgICAgICAgIENTVDogLTYgKiA2MCxcbiAgICAgICAgICAgIE1EVDogLTYgKiA2MCxcbiAgICAgICAgICAgIE1TVDogLTcgKiA2MCxcbiAgICAgICAgICAgIFBEVDogLTcgKiA2MCxcbiAgICAgICAgICAgIFBTVDogLTggKiA2MCxcbiAgICAgICAgfTtcblxuICAgIC8vIGRhdGUgZnJvbSBpc28gZm9ybWF0XG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUlTTyhjb25maWcpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgc3RyaW5nID0gY29uZmlnLl9pLFxuICAgICAgICAgICAgbWF0Y2ggPSBleHRlbmRlZElzb1JlZ2V4LmV4ZWMoc3RyaW5nKSB8fCBiYXNpY0lzb1JlZ2V4LmV4ZWMoc3RyaW5nKSxcbiAgICAgICAgICAgIGFsbG93VGltZSxcbiAgICAgICAgICAgIGRhdGVGb3JtYXQsXG4gICAgICAgICAgICB0aW1lRm9ybWF0LFxuICAgICAgICAgICAgdHpGb3JtYXQsXG4gICAgICAgICAgICBpc29EYXRlc0xlbiA9IGlzb0RhdGVzLmxlbmd0aCxcbiAgICAgICAgICAgIGlzb1RpbWVzTGVuID0gaXNvVGltZXMubGVuZ3RoO1xuXG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaXNvID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29EYXRlc0xlbjsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpc29EYXRlc1tpXVsxXS5leGVjKG1hdGNoWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRlRm9ybWF0ID0gaXNvRGF0ZXNbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgIGFsbG93VGltZSA9IGlzb0RhdGVzW2ldWzJdICE9PSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGVGb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaFszXSkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29UaW1lc0xlbjsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNvVGltZXNbaV1bMV0uZXhlYyhtYXRjaFszXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hdGNoWzJdIHNob3VsZCBiZSAnVCcgb3Igc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVGb3JtYXQgPSAobWF0Y2hbMl0gfHwgJyAnKSArIGlzb1RpbWVzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVGb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYWxsb3dUaW1lICYmIHRpbWVGb3JtYXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaFs0XSkge1xuICAgICAgICAgICAgICAgIGlmICh0elJlZ2V4LmV4ZWMobWF0Y2hbNF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHR6Rm9ybWF0ID0gJ1onO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uZmlnLl9mID0gZGF0ZUZvcm1hdCArICh0aW1lRm9ybWF0IHx8ICcnKSArICh0ekZvcm1hdCB8fCAnJyk7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dHJhY3RGcm9tUkZDMjgyMlN0cmluZ3MoXG4gICAgICAgIHllYXJTdHIsXG4gICAgICAgIG1vbnRoU3RyLFxuICAgICAgICBkYXlTdHIsXG4gICAgICAgIGhvdXJTdHIsXG4gICAgICAgIG1pbnV0ZVN0cixcbiAgICAgICAgc2Vjb25kU3RyXG4gICAgKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXG4gICAgICAgICAgICB1bnRydW5jYXRlWWVhcih5ZWFyU3RyKSxcbiAgICAgICAgICAgIGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydC5pbmRleE9mKG1vbnRoU3RyKSxcbiAgICAgICAgICAgIHBhcnNlSW50KGRheVN0ciwgMTApLFxuICAgICAgICAgICAgcGFyc2VJbnQoaG91clN0ciwgMTApLFxuICAgICAgICAgICAgcGFyc2VJbnQobWludXRlU3RyLCAxMCksXG4gICAgICAgIF07XG5cbiAgICAgICAgaWYgKHNlY29uZFN0cikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VJbnQoc2Vjb25kU3RyLCAxMCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bnRydW5jYXRlWWVhcih5ZWFyU3RyKSB7XG4gICAgICAgIHZhciB5ZWFyID0gcGFyc2VJbnQoeWVhclN0ciwgMTApO1xuICAgICAgICBpZiAoeWVhciA8PSA0OSkge1xuICAgICAgICAgICAgcmV0dXJuIDIwMDAgKyB5ZWFyO1xuICAgICAgICB9IGVsc2UgaWYgKHllYXIgPD0gOTk5KSB7XG4gICAgICAgICAgICByZXR1cm4gMTkwMCArIHllYXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHllYXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlcHJvY2Vzc1JGQzI4MjIocykge1xuICAgICAgICAvLyBSZW1vdmUgY29tbWVudHMgYW5kIGZvbGRpbmcgd2hpdGVzcGFjZSBhbmQgcmVwbGFjZSBtdWx0aXBsZS1zcGFjZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuICAgICAgICByZXR1cm4gc1xuICAgICAgICAgICAgLnJlcGxhY2UoL1xcKFteKCldKlxcKXxbXFxuXFx0XS9nLCAnICcpXG4gICAgICAgICAgICAucmVwbGFjZSgvKFxcc1xccyspL2csICcgJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9eXFxzXFxzKi8sICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcc1xccyokLywgJycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrV2Vla2RheSh3ZWVrZGF5U3RyLCBwYXJzZWRJbnB1dCwgY29uZmlnKSB7XG4gICAgICAgIGlmICh3ZWVrZGF5U3RyKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBSZXBsYWNlIHRoZSB2YW5pbGxhIEpTIERhdGUgb2JqZWN0IHdpdGggYW4gaW5kZXBlbmRlbnQgZGF5LW9mLXdlZWsgY2hlY2suXG4gICAgICAgICAgICB2YXIgd2Vla2RheVByb3ZpZGVkID0gZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQuaW5kZXhPZih3ZWVrZGF5U3RyKSxcbiAgICAgICAgICAgICAgICB3ZWVrZGF5QWN0dWFsID0gbmV3IERhdGUoXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZElucHV0WzBdLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZWRJbnB1dFsxXSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkSW5wdXRbMl1cbiAgICAgICAgICAgICAgICApLmdldERheSgpO1xuICAgICAgICAgICAgaWYgKHdlZWtkYXlQcm92aWRlZCAhPT0gd2Vla2RheUFjdHVhbCkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLndlZWtkYXlNaXNtYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZU9mZnNldChvYnNPZmZzZXQsIG1pbGl0YXJ5T2Zmc2V0LCBudW1PZmZzZXQpIHtcbiAgICAgICAgaWYgKG9ic09mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIG9ic09mZnNldHNbb2JzT2Zmc2V0XTtcbiAgICAgICAgfSBlbHNlIGlmIChtaWxpdGFyeU9mZnNldCkge1xuICAgICAgICAgICAgLy8gdGhlIG9ubHkgYWxsb3dlZCBtaWxpdGFyeSB0eiBpcyBaXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBobSA9IHBhcnNlSW50KG51bU9mZnNldCwgMTApLFxuICAgICAgICAgICAgICAgIG0gPSBobSAlIDEwMCxcbiAgICAgICAgICAgICAgICBoID0gKGhtIC0gbSkgLyAxMDA7XG4gICAgICAgICAgICByZXR1cm4gaCAqIDYwICsgbTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgYW5kIHRpbWUgZnJvbSByZWYgMjgyMiBmb3JtYXRcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tUkZDMjgyMihjb25maWcpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gcmZjMjgyMi5leGVjKHByZXByb2Nlc3NSRkMyODIyKGNvbmZpZy5faSkpLFxuICAgICAgICAgICAgcGFyc2VkQXJyYXk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgcGFyc2VkQXJyYXkgPSBleHRyYWN0RnJvbVJGQzI4MjJTdHJpbmdzKFxuICAgICAgICAgICAgICAgIG1hdGNoWzRdLFxuICAgICAgICAgICAgICAgIG1hdGNoWzNdLFxuICAgICAgICAgICAgICAgIG1hdGNoWzJdLFxuICAgICAgICAgICAgICAgIG1hdGNoWzVdLFxuICAgICAgICAgICAgICAgIG1hdGNoWzZdLFxuICAgICAgICAgICAgICAgIG1hdGNoWzddXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCFjaGVja1dlZWtkYXkobWF0Y2hbMV0sIHBhcnNlZEFycmF5LCBjb25maWcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25maWcuX2EgPSBwYXJzZWRBcnJheTtcbiAgICAgICAgICAgIGNvbmZpZy5fdHptID0gY2FsY3VsYXRlT2Zmc2V0KG1hdGNoWzhdLCBtYXRjaFs5XSwgbWF0Y2hbMTBdKTtcblxuICAgICAgICAgICAgY29uZmlnLl9kID0gY3JlYXRlVVRDRGF0ZS5hcHBseShudWxsLCBjb25maWcuX2EpO1xuICAgICAgICAgICAgY29uZmlnLl9kLnNldFVUQ01pbnV0ZXMoY29uZmlnLl9kLmdldFVUQ01pbnV0ZXMoKSAtIGNvbmZpZy5fdHptKTtcblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykucmZjMjgyMiA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgZnJvbSAxKSBBU1AuTkVULCAyKSBJU08sIDMpIFJGQyAyODIyIGZvcm1hdHMsIG9yIDQpIG9wdGlvbmFsIGZhbGxiYWNrIGlmIHBhcnNpbmcgaXNuJ3Qgc3RyaWN0XG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZyhjb25maWcpIHtcbiAgICAgICAgdmFyIG1hdGNoZWQgPSBhc3BOZXRKc29uUmVnZXguZXhlYyhjb25maWcuX2kpO1xuICAgICAgICBpZiAobWF0Y2hlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoK21hdGNoZWRbMV0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnRnJvbUlTTyhjb25maWcpO1xuICAgICAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5faXNWYWxpZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZ0Zyb21SRkMyODIyKGNvbmZpZyk7XG4gICAgICAgIGlmIChjb25maWcuX2lzVmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBkZWxldGUgY29uZmlnLl9pc1ZhbGlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fc3RyaWN0KSB7XG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZpbmFsIGF0dGVtcHQsIHVzZSBJbnB1dCBGYWxsYmFja1xuICAgICAgICAgICAgaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrID0gZGVwcmVjYXRlKFxuICAgICAgICAndmFsdWUgcHJvdmlkZWQgaXMgbm90IGluIGEgcmVjb2duaXplZCBSRkMyODIyIG9yIElTTyBmb3JtYXQuIG1vbWVudCBjb25zdHJ1Y3Rpb24gZmFsbHMgYmFjayB0byBqcyBEYXRlKCksICcgK1xuICAgICAgICAgICAgJ3doaWNoIGlzIG5vdCByZWxpYWJsZSBhY3Jvc3MgYWxsIGJyb3dzZXJzIGFuZCB2ZXJzaW9ucy4gTm9uIFJGQzI4MjIvSVNPIGRhdGUgZm9ybWF0cyBhcmUgJyArXG4gICAgICAgICAgICAnZGlzY291cmFnZWQuIFBsZWFzZSByZWZlciB0byBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2pzLWRhdGUvIGZvciBtb3JlIGluZm8uJyxcbiAgICAgICAgZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoY29uZmlnLl9pICsgKGNvbmZpZy5fdXNlVVRDID8gJyBVVEMnIDogJycpKTtcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICAvLyBQaWNrIHRoZSBmaXJzdCBkZWZpbmVkIG9mIHR3byBvciB0aHJlZSBhcmd1bWVudHMuXG4gICAgZnVuY3Rpb24gZGVmYXVsdHMoYSwgYiwgYykge1xuICAgICAgICBpZiAoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYiAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZykge1xuICAgICAgICAvLyBob29rcyBpcyBhY3R1YWxseSB0aGUgZXhwb3J0ZWQgbW9tZW50IG9iamVjdFxuICAgICAgICB2YXIgbm93VmFsdWUgPSBuZXcgRGF0ZShob29rcy5ub3coKSk7XG4gICAgICAgIGlmIChjb25maWcuX3VzZVVUQykge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBub3dWYWx1ZS5nZXRVVENGdWxsWWVhcigpLFxuICAgICAgICAgICAgICAgIG5vd1ZhbHVlLmdldFVUQ01vbnRoKCksXG4gICAgICAgICAgICAgICAgbm93VmFsdWUuZ2V0VVRDRGF0ZSgpLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW25vd1ZhbHVlLmdldEZ1bGxZZWFyKCksIG5vd1ZhbHVlLmdldE1vbnRoKCksIG5vd1ZhbHVlLmdldERhdGUoKV07XG4gICAgfVxuXG4gICAgLy8gY29udmVydCBhbiBhcnJheSB0byBhIGRhdGUuXG4gICAgLy8gdGhlIGFycmF5IHNob3VsZCBtaXJyb3IgdGhlIHBhcmFtZXRlcnMgYmVsb3dcbiAgICAvLyBub3RlOiBhbGwgdmFsdWVzIHBhc3QgdGhlIHllYXIgYXJlIG9wdGlvbmFsIGFuZCB3aWxsIGRlZmF1bHQgdG8gdGhlIGxvd2VzdCBwb3NzaWJsZSB2YWx1ZS5cbiAgICAvLyBbeWVhciwgbW9udGgsIGRheSAsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZF1cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tQXJyYXkoY29uZmlnKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgZGF0ZSxcbiAgICAgICAgICAgIGlucHV0ID0gW10sXG4gICAgICAgICAgICBjdXJyZW50RGF0ZSxcbiAgICAgICAgICAgIGV4cGVjdGVkV2Vla2RheSxcbiAgICAgICAgICAgIHllYXJUb1VzZTtcblxuICAgICAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50RGF0ZSA9IGN1cnJlbnREYXRlQXJyYXkoY29uZmlnKTtcblxuICAgICAgICAvL2NvbXB1dGUgZGF5IG9mIHRoZSB5ZWFyIGZyb20gd2Vla3MgYW5kIHdlZWtkYXlzXG4gICAgICAgIGlmIChjb25maWcuX3cgJiYgY29uZmlnLl9hW0RBVEVdID09IG51bGwgJiYgY29uZmlnLl9hW01PTlRIXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vaWYgdGhlIGRheSBvZiB0aGUgeWVhciBpcyBzZXQsIGZpZ3VyZSBvdXQgd2hhdCBpdCBpc1xuICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgeWVhclRvVXNlID0gZGVmYXVsdHMoY29uZmlnLl9hW1lFQVJdLCBjdXJyZW50RGF0ZVtZRUFSXSk7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBjb25maWcuX2RheU9mWWVhciA+IGRheXNJblllYXIoeWVhclRvVXNlKSB8fFxuICAgICAgICAgICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID09PSAwXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dEYXlPZlllYXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZSh5ZWFyVG9Vc2UsIDAsIGNvbmZpZy5fZGF5T2ZZZWFyKTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNT05USF0gPSBkYXRlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICBjb25maWcuX2FbREFURV0gPSBkYXRlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCBkYXRlLlxuICAgICAgICAvLyAqIGlmIG5vIHllYXIsIG1vbnRoLCBkYXkgb2YgbW9udGggYXJlIGdpdmVuLCBkZWZhdWx0IHRvIHRvZGF5XG4gICAgICAgIC8vICogaWYgZGF5IG9mIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG1vbnRoIGFuZCB5ZWFyXG4gICAgICAgIC8vICogaWYgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgb25seSB5ZWFyXG4gICAgICAgIC8vICogaWYgeWVhciBpcyBnaXZlbiwgZG9uJ3QgZGVmYXVsdCBhbnl0aGluZ1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMyAmJiBjb25maWcuX2FbaV0gPT0gbnVsbDsgKytpKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IGN1cnJlbnREYXRlW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gWmVybyBvdXQgd2hhdGV2ZXIgd2FzIG5vdCBkZWZhdWx0ZWQsIGluY2x1ZGluZyB0aW1lXG4gICAgICAgIGZvciAoOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9XG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW2ldID09IG51bGwgPyAoaSA9PT0gMiA/IDEgOiAwKSA6IGNvbmZpZy5fYVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGZvciAyNDowMDowMC4wMDBcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID09PSAyNCAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW01JTlVURV0gPT09IDAgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fYVtTRUNPTkRdID09PSAwICYmXG4gICAgICAgICAgICBjb25maWcuX2FbTUlMTElTRUNPTkRdID09PSAwXG4gICAgICAgICkge1xuICAgICAgICAgICAgY29uZmlnLl9uZXh0RGF5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWcuX2QgPSAoY29uZmlnLl91c2VVVEMgPyBjcmVhdGVVVENEYXRlIDogY3JlYXRlRGF0ZSkuYXBwbHkoXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgaW5wdXRcbiAgICAgICAgKTtcbiAgICAgICAgZXhwZWN0ZWRXZWVrZGF5ID0gY29uZmlnLl91c2VVVENcbiAgICAgICAgICAgID8gY29uZmlnLl9kLmdldFVUQ0RheSgpXG4gICAgICAgICAgICA6IGNvbmZpZy5fZC5nZXREYXkoKTtcblxuICAgICAgICAvLyBBcHBseSB0aW1lem9uZSBvZmZzZXQgZnJvbSBpbnB1dC4gVGhlIGFjdHVhbCB1dGNPZmZzZXQgY2FuIGJlIGNoYW5nZWRcbiAgICAgICAgLy8gd2l0aCBwYXJzZVpvbmUuXG4gICAgICAgIGlmIChjb25maWcuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fbmV4dERheSkge1xuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMjQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBmb3IgbWlzbWF0Y2hpbmcgZGF5IG9mIHdlZWtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgY29uZmlnLl93ICYmXG4gICAgICAgICAgICB0eXBlb2YgY29uZmlnLl93LmQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICBjb25maWcuX3cuZCAhPT0gZXhwZWN0ZWRXZWVrZGF5XG4gICAgICAgICkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykud2Vla2RheU1pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpIHtcbiAgICAgICAgdmFyIHcsIHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSwgdGVtcCwgd2Vla2RheU92ZXJmbG93LCBjdXJXZWVrO1xuXG4gICAgICAgIHcgPSBjb25maWcuX3c7XG4gICAgICAgIGlmICh3LkdHICE9IG51bGwgfHwgdy5XICE9IG51bGwgfHwgdy5FICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRvdyA9IDE7XG4gICAgICAgICAgICBkb3kgPSA0O1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBXZSBuZWVkIHRvIHRha2UgdGhlIGN1cnJlbnQgaXNvV2Vla1llYXIsIGJ1dCB0aGF0IGRlcGVuZHMgb25cbiAgICAgICAgICAgIC8vIGhvdyB3ZSBpbnRlcnByZXQgbm93IChsb2NhbCwgdXRjLCBmaXhlZCBvZmZzZXQpLiBTbyBjcmVhdGVcbiAgICAgICAgICAgIC8vIGEgbm93IHZlcnNpb24gb2YgY3VycmVudCBjb25maWcgKHRha2UgbG9jYWwvdXRjL29mZnNldCBmbGFncywgYW5kXG4gICAgICAgICAgICAvLyBjcmVhdGUgbm93KS5cbiAgICAgICAgICAgIHdlZWtZZWFyID0gZGVmYXVsdHMoXG4gICAgICAgICAgICAgICAgdy5HRyxcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbWUVBUl0sXG4gICAgICAgICAgICAgICAgd2Vla09mWWVhcihjcmVhdGVMb2NhbCgpLCAxLCA0KS55ZWFyXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgd2VlayA9IGRlZmF1bHRzKHcuVywgMSk7XG4gICAgICAgICAgICB3ZWVrZGF5ID0gZGVmYXVsdHMody5FLCAxKTtcbiAgICAgICAgICAgIGlmICh3ZWVrZGF5IDwgMSB8fCB3ZWVrZGF5ID4gNykge1xuICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb3cgPSBjb25maWcuX2xvY2FsZS5fd2Vlay5kb3c7XG4gICAgICAgICAgICBkb3kgPSBjb25maWcuX2xvY2FsZS5fd2Vlay5kb3k7XG5cbiAgICAgICAgICAgIGN1cldlZWsgPSB3ZWVrT2ZZZWFyKGNyZWF0ZUxvY2FsKCksIGRvdywgZG95KTtcblxuICAgICAgICAgICAgd2Vla1llYXIgPSBkZWZhdWx0cyh3LmdnLCBjb25maWcuX2FbWUVBUl0sIGN1cldlZWsueWVhcik7XG5cbiAgICAgICAgICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCB3ZWVrLlxuICAgICAgICAgICAgd2VlayA9IGRlZmF1bHRzKHcudywgY3VyV2Vlay53ZWVrKTtcblxuICAgICAgICAgICAgaWYgKHcuZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gd2Vla2RheSAtLSBsb3cgZGF5IG51bWJlcnMgYXJlIGNvbnNpZGVyZWQgbmV4dCB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IHcuZDtcbiAgICAgICAgICAgICAgICBpZiAod2Vla2RheSA8IDAgfHwgd2Vla2RheSA+IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHcuZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gbG9jYWwgd2Vla2RheSAtLSBjb3VudGluZyBzdGFydHMgZnJvbSBiZWdpbm5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSB3LmUgKyBkb3c7XG4gICAgICAgICAgICAgICAgaWYgKHcuZSA8IDAgfHwgdy5lID4gNikge1xuICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZGVmYXVsdCB0byBiZWdpbm5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSBkb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdlZWsgPCAxIHx8IHdlZWsgPiB3ZWVrc0luWWVhcih3ZWVrWWVhciwgZG93LCBkb3kpKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dXZWVrcyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAod2Vla2RheU92ZXJmbG93ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd1dlZWtkYXkgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGVtcCA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xuICAgICAgICAgICAgY29uZmlnLl9hW1lFQVJdID0gdGVtcC55ZWFyO1xuICAgICAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0ZW1wLmRheU9mWWVhcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNvbnN0YW50IHRoYXQgcmVmZXJzIHRvIHRoZSBJU08gc3RhbmRhcmRcbiAgICBob29rcy5JU09fODYwMSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gY29uc3RhbnQgdGhhdCByZWZlcnMgdG8gdGhlIFJGQyAyODIyIGZvcm1cbiAgICBob29rcy5SRkNfMjgyMiA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgZm9ybWF0IHN0cmluZ1xuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyB0byBhbm90aGVyIHBhcnQgb2YgdGhlIGNyZWF0aW9uIGZsb3cgdG8gcHJldmVudCBjaXJjdWxhciBkZXBzXG4gICAgICAgIGlmIChjb25maWcuX2YgPT09IGhvb2tzLklTT184NjAxKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5fZiA9PT0gaG9va3MuUkZDXzI4MjIpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21SRkMyODIyKGNvbmZpZyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlnLl9hID0gW107XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gdHJ1ZTtcblxuICAgICAgICAvLyBUaGlzIGFycmF5IGlzIHVzZWQgdG8gbWFrZSBhIERhdGUsIGVpdGhlciB3aXRoIGBuZXcgRGF0ZWAgb3IgYERhdGUuVVRDYFxuICAgICAgICB2YXIgc3RyaW5nID0gJycgKyBjb25maWcuX2ksXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgcGFyc2VkSW5wdXQsXG4gICAgICAgICAgICB0b2tlbnMsXG4gICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgIHNraXBwZWQsXG4gICAgICAgICAgICBzdHJpbmdMZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCA9IDAsXG4gICAgICAgICAgICBlcmEsXG4gICAgICAgICAgICB0b2tlbkxlbjtcblxuICAgICAgICB0b2tlbnMgPVxuICAgICAgICAgICAgZXhwYW5kRm9ybWF0KGNvbmZpZy5fZiwgY29uZmlnLl9sb2NhbGUpLm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpIHx8IFtdO1xuICAgICAgICB0b2tlbkxlbiA9IHRva2Vucy5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbkxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgIHBhcnNlZElucHV0ID0gKHN0cmluZy5tYXRjaChnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykpIHx8XG4gICAgICAgICAgICAgICAgW10pWzBdO1xuICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgc2tpcHBlZCA9IHN0cmluZy5zdWJzdHIoMCwgc3RyaW5nLmluZGV4T2YocGFyc2VkSW5wdXQpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcHBlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc2tpcHBlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5zbGljZShcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nLmluZGV4T2YocGFyc2VkSW5wdXQpICsgcGFyc2VkSW5wdXQubGVuZ3RoXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoICs9IHBhcnNlZElucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRvbid0IHBhcnNlIGlmIGl0J3Mgbm90IGEga25vd24gdG9rZW5cbiAgICAgICAgICAgIGlmIChmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0pIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBwYXJzZWRJbnB1dCwgY29uZmlnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLl9zdHJpY3QgJiYgIXBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHJlbWFpbmluZyB1bnBhcnNlZCBpbnB1dCBsZW5ndGggdG8gdGhlIHN0cmluZ1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5jaGFyc0xlZnRPdmVyID1cbiAgICAgICAgICAgIHN0cmluZ0xlbmd0aCAtIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGg7XG4gICAgICAgIGlmIChzdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChzdHJpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYXIgXzEyaCBmbGFnIGlmIGhvdXIgaXMgPD0gMTJcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdIDw9IDEyICYmXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID09PSB0cnVlICYmXG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPiAwXG4gICAgICAgICkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnBhcnNlZERhdGVQYXJ0cyA9IGNvbmZpZy5fYS5zbGljZSgwKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykubWVyaWRpZW0gPSBjb25maWcuX21lcmlkaWVtO1xuICAgICAgICAvLyBoYW5kbGUgbWVyaWRpZW1cbiAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gbWVyaWRpZW1GaXhXcmFwKFxuICAgICAgICAgICAgY29uZmlnLl9sb2NhbGUsXG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0sXG4gICAgICAgICAgICBjb25maWcuX21lcmlkaWVtXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gaGFuZGxlIGVyYVxuICAgICAgICBlcmEgPSBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lcmE7XG4gICAgICAgIGlmIChlcmEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtZRUFSXSA9IGNvbmZpZy5fbG9jYWxlLmVyYXNDb252ZXJ0WWVhcihlcmEsIGNvbmZpZy5fYVtZRUFSXSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICAgICAgY2hlY2tPdmVyZmxvdyhjb25maWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lcmlkaWVtRml4V3JhcChsb2NhbGUsIGhvdXIsIG1lcmlkaWVtKSB7XG4gICAgICAgIHZhciBpc1BtO1xuXG4gICAgICAgIGlmIChtZXJpZGllbSA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBub3RoaW5nIHRvIGRvXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9jYWxlLm1lcmlkaWVtSG91ciAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLm1lcmlkaWVtSG91cihob3VyLCBtZXJpZGllbSk7XG4gICAgICAgIH0gZWxzZSBpZiAobG9jYWxlLmlzUE0gIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gRmFsbGJhY2tcbiAgICAgICAgICAgIGlzUG0gPSBsb2NhbGUuaXNQTShtZXJpZGllbSk7XG4gICAgICAgICAgICBpZiAoaXNQbSAmJiBob3VyIDwgMTIpIHtcbiAgICAgICAgICAgICAgICBob3VyICs9IDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1BtICYmIGhvdXIgPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IHN1cHBvc2VkIHRvIGhhcHBlblxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRlIGZyb20gc3RyaW5nIGFuZCBhcnJheSBvZiBmb3JtYXQgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpIHtcbiAgICAgICAgdmFyIHRlbXBDb25maWcsXG4gICAgICAgICAgICBiZXN0TW9tZW50LFxuICAgICAgICAgICAgc2NvcmVUb0JlYXQsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgY3VycmVudFNjb3JlLFxuICAgICAgICAgICAgdmFsaWRGb3JtYXRGb3VuZCxcbiAgICAgICAgICAgIGJlc3RGb3JtYXRJc1ZhbGlkID0gZmFsc2UsXG4gICAgICAgICAgICBjb25maWdmTGVuID0gY29uZmlnLl9mLmxlbmd0aDtcblxuICAgICAgICBpZiAoY29uZmlnZkxlbiA9PT0gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZEZvcm1hdCA9IHRydWU7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbmZpZ2ZMZW47IGkrKykge1xuICAgICAgICAgICAgY3VycmVudFNjb3JlID0gMDtcbiAgICAgICAgICAgIHZhbGlkRm9ybWF0Rm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRlbXBDb25maWcgPSBjb3B5Q29uZmlnKHt9LCBjb25maWcpO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0ZW1wQ29uZmlnLl91c2VVVEMgPSBjb25maWcuX3VzZVVUQztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRlbXBDb25maWcuX2YgPSBjb25maWcuX2ZbaV07XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KHRlbXBDb25maWcpO1xuXG4gICAgICAgICAgICBpZiAoaXNWYWxpZCh0ZW1wQ29uZmlnKSkge1xuICAgICAgICAgICAgICAgIHZhbGlkRm9ybWF0Rm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbnkgaW5wdXQgdGhhdCB3YXMgbm90IHBhcnNlZCBhZGQgYSBwZW5hbHR5IGZvciB0aGF0IGZvcm1hdFxuICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS5jaGFyc0xlZnRPdmVyO1xuXG4gICAgICAgICAgICAvL29yIHRva2Vuc1xuICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS51bnVzZWRUb2tlbnMubGVuZ3RoICogMTA7XG5cbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS5zY29yZSA9IGN1cnJlbnRTY29yZTtcblxuICAgICAgICAgICAgaWYgKCFiZXN0Rm9ybWF0SXNWYWxpZCkge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgc2NvcmVUb0JlYXQgPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2NvcmUgPCBzY29yZVRvQmVhdCB8fFxuICAgICAgICAgICAgICAgICAgICB2YWxpZEZvcm1hdEZvdW5kXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3JlVG9CZWF0ID0gY3VycmVudFNjb3JlO1xuICAgICAgICAgICAgICAgICAgICBiZXN0TW9tZW50ID0gdGVtcENvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkRm9ybWF0Rm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RGb3JtYXRJc1ZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTY29yZSA8IHNjb3JlVG9CZWF0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3JlVG9CZWF0ID0gY3VycmVudFNjb3JlO1xuICAgICAgICAgICAgICAgICAgICBiZXN0TW9tZW50ID0gdGVtcENvbmZpZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHRlbmQoY29uZmlnLCBiZXN0TW9tZW50IHx8IHRlbXBDb25maWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21PYmplY3QoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoY29uZmlnLl9pKSxcbiAgICAgICAgICAgIGRheU9yRGF0ZSA9IGkuZGF5ID09PSB1bmRlZmluZWQgPyBpLmRhdGUgOiBpLmRheTtcbiAgICAgICAgY29uZmlnLl9hID0gbWFwKFxuICAgICAgICAgICAgW2kueWVhciwgaS5tb250aCwgZGF5T3JEYXRlLCBpLmhvdXIsIGkubWludXRlLCBpLnNlY29uZCwgaS5taWxsaXNlY29uZF0sXG4gICAgICAgICAgICBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiBwYXJzZUludChvYmosIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVGcm9tQ29uZmlnKGNvbmZpZykge1xuICAgICAgICB2YXIgcmVzID0gbmV3IE1vbWVudChjaGVja092ZXJmbG93KHByZXBhcmVDb25maWcoY29uZmlnKSkpO1xuICAgICAgICBpZiAocmVzLl9uZXh0RGF5KSB7XG4gICAgICAgICAgICAvLyBBZGRpbmcgaXMgc21hcnQgZW5vdWdoIGFyb3VuZCBEU1RcbiAgICAgICAgICAgIHJlcy5hZGQoMSwgJ2QnKTtcbiAgICAgICAgICAgIHJlcy5fbmV4dERheSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlcGFyZUNvbmZpZyhjb25maWcpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gY29uZmlnLl9pLFxuICAgICAgICAgICAgZm9ybWF0ID0gY29uZmlnLl9mO1xuXG4gICAgICAgIGNvbmZpZy5fbG9jYWxlID0gY29uZmlnLl9sb2NhbGUgfHwgZ2V0TG9jYWxlKGNvbmZpZy5fbCk7XG5cbiAgICAgICAgaWYgKGlucHV0ID09PSBudWxsIHx8IChmb3JtYXQgPT09IHVuZGVmaW5lZCAmJiBpbnB1dCA9PT0gJycpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCh7IG51bGxJbnB1dDogdHJ1ZSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25maWcuX2kgPSBpbnB1dCA9IGNvbmZpZy5fbG9jYWxlLnByZXBhcnNlKGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc01vbWVudChpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3coaW5wdXQpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBpbnB1dDtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCkge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnRnJvbUlucHV0KGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVmFsaWQoY29uZmlnKSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUlucHV0KGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2k7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZChpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGhvb2tzLm5vdygpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dC52YWx1ZU9mKCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmcoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9hID0gbWFwKGlucHV0LnNsaWNlKDApLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG9iaiwgMTApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdChpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21PYmplY3QoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc051bWJlcihpbnB1dCkpIHtcbiAgICAgICAgICAgIC8vIGZyb20gbWlsbGlzZWNvbmRzXG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgaXNVVEMpIHtcbiAgICAgICAgdmFyIGMgPSB7fTtcblxuICAgICAgICBpZiAoZm9ybWF0ID09PSB0cnVlIHx8IGZvcm1hdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHN0cmljdCA9IGZvcm1hdDtcbiAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsb2NhbGUgPT09IHRydWUgfHwgbG9jYWxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgc3RyaWN0ID0gbG9jYWxlO1xuICAgICAgICAgICAgbG9jYWxlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgKGlzT2JqZWN0KGlucHV0KSAmJiBpc09iamVjdEVtcHR5KGlucHV0KSkgfHxcbiAgICAgICAgICAgIChpc0FycmF5KGlucHV0KSAmJiBpbnB1dC5sZW5ndGggPT09IDApXG4gICAgICAgICkge1xuICAgICAgICAgICAgaW5wdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb2JqZWN0IGNvbnN0cnVjdGlvbiBtdXN0IGJlIGRvbmUgdGhpcyB3YXkuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNDIzXG4gICAgICAgIGMuX2lzQU1vbWVudE9iamVjdCA9IHRydWU7XG4gICAgICAgIGMuX3VzZVVUQyA9IGMuX2lzVVRDID0gaXNVVEM7XG4gICAgICAgIGMuX2wgPSBsb2NhbGU7XG4gICAgICAgIGMuX2kgPSBpbnB1dDtcbiAgICAgICAgYy5fZiA9IGZvcm1hdDtcbiAgICAgICAgYy5fc3RyaWN0ID0gc3RyaWN0O1xuXG4gICAgICAgIHJldHVybiBjcmVhdGVGcm9tQ29uZmlnKGMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxvY2FsKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvdHlwZU1pbiA9IGRlcHJlY2F0ZShcbiAgICAgICAgICAgICdtb21lbnQoKS5taW4gaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5tYXggaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9taW4tbWF4LycsXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvdGhlciA8IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIHByb3RvdHlwZU1heCA9IGRlcHJlY2F0ZShcbiAgICAgICAgICAgICdtb21lbnQoKS5tYXggaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5taW4gaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9taW4tbWF4LycsXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvdGhlciA+IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAvLyBQaWNrIGEgbW9tZW50IG0gZnJvbSBtb21lbnRzIHNvIHRoYXQgbVtmbl0ob3RoZXIpIGlzIHRydWUgZm9yIGFsbFxuICAgIC8vIG90aGVyLiBUaGlzIHJlbGllcyBvbiB0aGUgZnVuY3Rpb24gZm4gdG8gYmUgdHJhbnNpdGl2ZS5cbiAgICAvL1xuICAgIC8vIG1vbWVudHMgc2hvdWxkIGVpdGhlciBiZSBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cyBvciBhbiBhcnJheSwgd2hvc2VcbiAgICAvLyBmaXJzdCBlbGVtZW50IGlzIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzLlxuICAgIGZ1bmN0aW9uIHBpY2tCeShmbiwgbW9tZW50cykge1xuICAgICAgICB2YXIgcmVzLCBpO1xuICAgICAgICBpZiAobW9tZW50cy5sZW5ndGggPT09IDEgJiYgaXNBcnJheShtb21lbnRzWzBdKSkge1xuICAgICAgICAgICAgbW9tZW50cyA9IG1vbWVudHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtb21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzID0gbW9tZW50c1swXTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IG1vbWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICghbW9tZW50c1tpXS5pc1ZhbGlkKCkgfHwgbW9tZW50c1tpXVtmbl0ocmVzKSkge1xuICAgICAgICAgICAgICAgIHJlcyA9IG1vbWVudHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBVc2UgW10uc29ydCBpbnN0ZWFkP1xuICAgIGZ1bmN0aW9uIG1pbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICAgICAgcmV0dXJuIHBpY2tCeSgnaXNCZWZvcmUnLCBhcmdzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXgoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgICAgIHJldHVybiBwaWNrQnkoJ2lzQWZ0ZXInLCBhcmdzKTtcbiAgICB9XG5cbiAgICB2YXIgbm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gRGF0ZS5ub3cgPyBEYXRlLm5vdygpIDogK25ldyBEYXRlKCk7XG4gICAgfTtcblxuICAgIHZhciBvcmRlcmluZyA9IFtcbiAgICAgICAgJ3llYXInLFxuICAgICAgICAncXVhcnRlcicsXG4gICAgICAgICdtb250aCcsXG4gICAgICAgICd3ZWVrJyxcbiAgICAgICAgJ2RheScsXG4gICAgICAgICdob3VyJyxcbiAgICAgICAgJ21pbnV0ZScsXG4gICAgICAgICdzZWNvbmQnLFxuICAgICAgICAnbWlsbGlzZWNvbmQnLFxuICAgIF07XG5cbiAgICBmdW5jdGlvbiBpc0R1cmF0aW9uVmFsaWQobSkge1xuICAgICAgICB2YXIga2V5LFxuICAgICAgICAgICAgdW5pdEhhc0RlY2ltYWwgPSBmYWxzZSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBvcmRlckxlbiA9IG9yZGVyaW5nLmxlbmd0aDtcbiAgICAgICAgZm9yIChrZXkgaW4gbSkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGhhc093blByb3AobSwga2V5KSAmJlxuICAgICAgICAgICAgICAgICEoXG4gICAgICAgICAgICAgICAgICAgIGluZGV4T2YuY2FsbChvcmRlcmluZywga2V5KSAhPT0gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgKG1ba2V5XSA9PSBudWxsIHx8ICFpc05hTihtW2tleV0pKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvcmRlckxlbjsgKytpKSB7XG4gICAgICAgICAgICBpZiAobVtvcmRlcmluZ1tpXV0pIHtcbiAgICAgICAgICAgICAgICBpZiAodW5pdEhhc0RlY2ltYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBvbmx5IGFsbG93IG5vbi1pbnRlZ2VycyBmb3Igc21hbGxlc3QgdW5pdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFyc2VGbG9hdChtW29yZGVyaW5nW2ldXSkgIT09IHRvSW50KG1bb3JkZXJpbmdbaV1dKSkge1xuICAgICAgICAgICAgICAgICAgICB1bml0SGFzRGVjaW1hbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWYWxpZCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNWYWxpZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVJbnZhbGlkJDEoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbihOYU4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIER1cmF0aW9uKGR1cmF0aW9uKSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSBub3JtYWxpemVPYmplY3RVbml0cyhkdXJhdGlvbiksXG4gICAgICAgICAgICB5ZWFycyA9IG5vcm1hbGl6ZWRJbnB1dC55ZWFyIHx8IDAsXG4gICAgICAgICAgICBxdWFydGVycyA9IG5vcm1hbGl6ZWRJbnB1dC5xdWFydGVyIHx8IDAsXG4gICAgICAgICAgICBtb250aHMgPSBub3JtYWxpemVkSW5wdXQubW9udGggfHwgMCxcbiAgICAgICAgICAgIHdlZWtzID0gbm9ybWFsaXplZElucHV0LndlZWsgfHwgbm9ybWFsaXplZElucHV0Lmlzb1dlZWsgfHwgMCxcbiAgICAgICAgICAgIGRheXMgPSBub3JtYWxpemVkSW5wdXQuZGF5IHx8IDAsXG4gICAgICAgICAgICBob3VycyA9IG5vcm1hbGl6ZWRJbnB1dC5ob3VyIHx8IDAsXG4gICAgICAgICAgICBtaW51dGVzID0gbm9ybWFsaXplZElucHV0Lm1pbnV0ZSB8fCAwLFxuICAgICAgICAgICAgc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5zZWNvbmQgfHwgMCxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5taWxsaXNlY29uZCB8fCAwO1xuXG4gICAgICAgIHRoaXMuX2lzVmFsaWQgPSBpc0R1cmF0aW9uVmFsaWQobm9ybWFsaXplZElucHV0KTtcblxuICAgICAgICAvLyByZXByZXNlbnRhdGlvbiBmb3IgZGF0ZUFkZFJlbW92ZVxuICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgPVxuICAgICAgICAgICAgK21pbGxpc2Vjb25kcyArXG4gICAgICAgICAgICBzZWNvbmRzICogMWUzICsgLy8gMTAwMFxuICAgICAgICAgICAgbWludXRlcyAqIDZlNCArIC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgaG91cnMgKiAxMDAwICogNjAgKiA2MDsgLy91c2luZyAxMDAwICogNjAgKiA2MCBpbnN0ZWFkIG9mIDM2ZTUgdG8gYXZvaWQgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yOTc4XG4gICAgICAgIC8vIEJlY2F1c2Ugb2YgZGF0ZUFkZFJlbW92ZSB0cmVhdHMgMjQgaG91cnMgYXMgZGlmZmVyZW50IGZyb20gYVxuICAgICAgICAvLyBkYXkgd2hlbiB3b3JraW5nIGFyb3VuZCBEU1QsIHdlIG5lZWQgdG8gc3RvcmUgdGhlbSBzZXBhcmF0ZWx5XG4gICAgICAgIHRoaXMuX2RheXMgPSArZGF5cyArIHdlZWtzICogNztcbiAgICAgICAgLy8gSXQgaXMgaW1wb3NzaWJsZSB0byB0cmFuc2xhdGUgbW9udGhzIGludG8gZGF5cyB3aXRob3V0IGtub3dpbmdcbiAgICAgICAgLy8gd2hpY2ggbW9udGhzIHlvdSBhcmUgYXJlIHRhbGtpbmcgYWJvdXQsIHNvIHdlIGhhdmUgdG8gc3RvcmVcbiAgICAgICAgLy8gaXQgc2VwYXJhdGVseS5cbiAgICAgICAgdGhpcy5fbW9udGhzID0gK21vbnRocyArIHF1YXJ0ZXJzICogMyArIHllYXJzICogMTI7XG5cbiAgICAgICAgdGhpcy5fZGF0YSA9IHt9O1xuXG4gICAgICAgIHRoaXMuX2xvY2FsZSA9IGdldExvY2FsZSgpO1xuXG4gICAgICAgIHRoaXMuX2J1YmJsZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRHVyYXRpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBEdXJhdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYnNSb3VuZChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKC0xICogbnVtYmVyKSAqIC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNvbXBhcmUgdHdvIGFycmF5cywgcmV0dXJuIHRoZSBudW1iZXIgb2YgZGlmZmVyZW5jZXNcbiAgICBmdW5jdGlvbiBjb21wYXJlQXJyYXlzKGFycmF5MSwgYXJyYXkyLCBkb250Q29udmVydCkge1xuICAgICAgICB2YXIgbGVuID0gTWF0aC5taW4oYXJyYXkxLmxlbmd0aCwgYXJyYXkyLmxlbmd0aCksXG4gICAgICAgICAgICBsZW5ndGhEaWZmID0gTWF0aC5hYnMoYXJyYXkxLmxlbmd0aCAtIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgZGlmZnMgPSAwLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKGRvbnRDb252ZXJ0ICYmIGFycmF5MVtpXSAhPT0gYXJyYXkyW2ldKSB8fFxuICAgICAgICAgICAgICAgICghZG9udENvbnZlcnQgJiYgdG9JbnQoYXJyYXkxW2ldKSAhPT0gdG9JbnQoYXJyYXkyW2ldKSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGRpZmZzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpZmZzICsgbGVuZ3RoRGlmZjtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBmdW5jdGlvbiBvZmZzZXQodG9rZW4sIHNlcGFyYXRvcikge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbih0b2tlbiwgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMudXRjT2Zmc2V0KCksXG4gICAgICAgICAgICAgICAgc2lnbiA9ICcrJztcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gLW9mZnNldDtcbiAgICAgICAgICAgICAgICBzaWduID0gJy0nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBzaWduICtcbiAgICAgICAgICAgICAgICB6ZXJvRmlsbCh+fihvZmZzZXQgLyA2MCksIDIpICtcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3IgK1xuICAgICAgICAgICAgICAgIHplcm9GaWxsKH5+b2Zmc2V0ICUgNjAsIDIpXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvZmZzZXQoJ1onLCAnOicpO1xuICAgIG9mZnNldCgnWlonLCAnJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdaJywgbWF0Y2hTaG9ydE9mZnNldCk7XG4gICAgYWRkUmVnZXhUb2tlbignWlonLCBtYXRjaFNob3J0T2Zmc2V0KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnWicsICdaWiddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl91c2VVVEMgPSB0cnVlO1xuICAgICAgICBjb25maWcuX3R6bSA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hTaG9ydE9mZnNldCwgaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gdGltZXpvbmUgY2h1bmtlclxuICAgIC8vICcrMTA6MDAnID4gWycxMCcsICAnMDAnXVxuICAgIC8vICctMTUzMCcgID4gWyctMTUnLCAnMzAnXVxuICAgIHZhciBjaHVua09mZnNldCA9IC8oW1xcK1xcLV18XFxkXFxkKS9naTtcblxuICAgIGZ1bmN0aW9uIG9mZnNldEZyb21TdHJpbmcobWF0Y2hlciwgc3RyaW5nKSB7XG4gICAgICAgIHZhciBtYXRjaGVzID0gKHN0cmluZyB8fCAnJykubWF0Y2gobWF0Y2hlciksXG4gICAgICAgICAgICBjaHVuayxcbiAgICAgICAgICAgIHBhcnRzLFxuICAgICAgICAgICAgbWludXRlcztcblxuICAgICAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjaHVuayA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXSB8fCBbXTtcbiAgICAgICAgcGFydHMgPSAoY2h1bmsgKyAnJykubWF0Y2goY2h1bmtPZmZzZXQpIHx8IFsnLScsIDAsIDBdO1xuICAgICAgICBtaW51dGVzID0gKyhwYXJ0c1sxXSAqIDYwKSArIHRvSW50KHBhcnRzWzJdKTtcblxuICAgICAgICByZXR1cm4gbWludXRlcyA9PT0gMCA/IDAgOiBwYXJ0c1swXSA9PT0gJysnID8gbWludXRlcyA6IC1taW51dGVzO1xuICAgIH1cblxuICAgIC8vIFJldHVybiBhIG1vbWVudCBmcm9tIGlucHV0LCB0aGF0IGlzIGxvY2FsL3V0Yy96b25lIGVxdWl2YWxlbnQgdG8gbW9kZWwuXG4gICAgZnVuY3Rpb24gY2xvbmVXaXRoT2Zmc2V0KGlucHV0LCBtb2RlbCkge1xuICAgICAgICB2YXIgcmVzLCBkaWZmO1xuICAgICAgICBpZiAobW9kZWwuX2lzVVRDKSB7XG4gICAgICAgICAgICByZXMgPSBtb2RlbC5jbG9uZSgpO1xuICAgICAgICAgICAgZGlmZiA9XG4gICAgICAgICAgICAgICAgKGlzTW9tZW50KGlucHV0KSB8fCBpc0RhdGUoaW5wdXQpXG4gICAgICAgICAgICAgICAgICAgID8gaW5wdXQudmFsdWVPZigpXG4gICAgICAgICAgICAgICAgICAgIDogY3JlYXRlTG9jYWwoaW5wdXQpLnZhbHVlT2YoKSkgLSByZXMudmFsdWVPZigpO1xuICAgICAgICAgICAgLy8gVXNlIGxvdy1sZXZlbCBhcGksIGJlY2F1c2UgdGhpcyBmbiBpcyBsb3ctbGV2ZWwgYXBpLlxuICAgICAgICAgICAgcmVzLl9kLnNldFRpbWUocmVzLl9kLnZhbHVlT2YoKSArIGRpZmYpO1xuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHJlcywgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVMb2NhbChpbnB1dCkubG9jYWwoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERhdGVPZmZzZXQobSkge1xuICAgICAgICAvLyBPbiBGaXJlZm94LjI0IERhdGUjZ2V0VGltZXpvbmVPZmZzZXQgcmV0dXJucyBhIGZsb2F0aW5nIHBvaW50LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9wdWxsLzE4NzFcbiAgICAgICAgcmV0dXJuIC1NYXRoLnJvdW5kKG0uX2QuZ2V0VGltZXpvbmVPZmZzZXQoKSk7XG4gICAgfVxuXG4gICAgLy8gSE9PS1NcblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgYSBtb21lbnQgaXMgbXV0YXRlZC5cbiAgICAvLyBJdCBpcyBpbnRlbmRlZCB0byBrZWVwIHRoZSBvZmZzZXQgaW4gc3luYyB3aXRoIHRoZSB0aW1lem9uZS5cbiAgICBob29rcy51cGRhdGVPZmZzZXQgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIC8vIGtlZXBMb2NhbFRpbWUgPSB0cnVlIG1lYW5zIG9ubHkgY2hhbmdlIHRoZSB0aW1lem9uZSwgd2l0aG91dFxuICAgIC8vIGFmZmVjdGluZyB0aGUgbG9jYWwgaG91ci4gU28gNTozMToyNiArMDMwMCAtLVt1dGNPZmZzZXQoMiwgdHJ1ZSldLS0+XG4gICAgLy8gNTozMToyNiArMDIwMCBJdCBpcyBwb3NzaWJsZSB0aGF0IDU6MzE6MjYgZG9lc24ndCBleGlzdCB3aXRoIG9mZnNldFxuICAgIC8vICswMjAwLCBzbyB3ZSBhZGp1c3QgdGhlIHRpbWUgYXMgbmVlZGVkLCB0byBiZSB2YWxpZC5cbiAgICAvL1xuICAgIC8vIEtlZXBpbmcgdGhlIHRpbWUgYWN0dWFsbHkgYWRkcy9zdWJ0cmFjdHMgKG9uZSBob3VyKVxuICAgIC8vIGZyb20gdGhlIGFjdHVhbCByZXByZXNlbnRlZCB0aW1lLiBUaGF0IGlzIHdoeSB3ZSBjYWxsIHVwZGF0ZU9mZnNldFxuICAgIC8vIGEgc2Vjb25kIHRpbWUuIEluIGNhc2UgaXQgd2FudHMgdXMgdG8gY2hhbmdlIHRoZSBvZmZzZXQgYWdhaW5cbiAgICAvLyBfY2hhbmdlSW5Qcm9ncmVzcyA9PSB0cnVlIGNhc2UsIHRoZW4gd2UgaGF2ZSB0byBhZGp1c3QsIGJlY2F1c2VcbiAgICAvLyB0aGVyZSBpcyBubyBzdWNoIHRpbWUgaW4gdGhlIGdpdmVuIHRpbWV6b25lLlxuICAgIGZ1bmN0aW9uIGdldFNldE9mZnNldChpbnB1dCwga2VlcExvY2FsVGltZSwga2VlcE1pbnV0ZXMpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX29mZnNldCB8fCAwLFxuICAgICAgICAgICAgbG9jYWxBZGp1c3Q7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hTaG9ydE9mZnNldCwgaW5wdXQpO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGlucHV0KSA8IDE2ICYmICFrZWVwTWludXRlcykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQgKiA2MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5faXNVVEMgJiYga2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgICAgIGxvY2FsQWRqdXN0ID0gZ2V0RGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX29mZnNldCA9IGlucHV0O1xuICAgICAgICAgICAgdGhpcy5faXNVVEMgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGxvY2FsQWRqdXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChsb2NhbEFkanVzdCwgJ20nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvZmZzZXQgIT09IGlucHV0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFrZWVwTG9jYWxUaW1lIHx8IHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkU3VidHJhY3QoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRHVyYXRpb24oaW5wdXQgLSBvZmZzZXQsICdtJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gb2Zmc2V0IDogZ2V0RGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldFpvbmUoaW5wdXQsIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSAtaW5wdXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KGlucHV0LCBrZWVwTG9jYWxUaW1lKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gLXRoaXMudXRjT2Zmc2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb1VUQyhrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb0xvY2FsKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzVVRDKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcbiAgICAgICAgICAgIHRoaXMuX2lzVVRDID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJ0cmFjdChnZXREYXRlT2Zmc2V0KHRoaXMpLCAnbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0KCkge1xuICAgICAgICBpZiAodGhpcy5fdHptICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KHRoaXMuX3R6bSwgZmFsc2UsIHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9pID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIHRab25lID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaE9mZnNldCwgdGhpcy5faSk7XG4gICAgICAgICAgICBpZiAodFpvbmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KHRab25lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoMCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzQWxpZ25lZEhvdXJPZmZzZXQoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0ID0gaW5wdXQgPyBjcmVhdGVMb2NhbChpbnB1dCkudXRjT2Zmc2V0KCkgOiAwO1xuXG4gICAgICAgIHJldHVybiAodGhpcy51dGNPZmZzZXQoKSAtIGlucHV0KSAlIDYwID09PSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCgwKS51dGNPZmZzZXQoKSB8fFxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCg1KS51dGNPZmZzZXQoKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZCgpIHtcbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9pc0RTVFNoaWZ0ZWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGMgPSB7fSxcbiAgICAgICAgICAgIG90aGVyO1xuXG4gICAgICAgIGNvcHlDb25maWcoYywgdGhpcyk7XG4gICAgICAgIGMgPSBwcmVwYXJlQ29uZmlnKGMpO1xuXG4gICAgICAgIGlmIChjLl9hKSB7XG4gICAgICAgICAgICBvdGhlciA9IGMuX2lzVVRDID8gY3JlYXRlVVRDKGMuX2EpIDogY3JlYXRlTG9jYWwoYy5fYSk7XG4gICAgICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPVxuICAgICAgICAgICAgICAgIHRoaXMuaXNWYWxpZCgpICYmIGNvbXBhcmVBcnJheXMoYy5fYSwgb3RoZXIudG9BcnJheSgpKSA+IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMb2NhbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gIXRoaXMuX2lzVVRDIDogZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVdGNPZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2lzVVRDIDogZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVdGMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2lzVVRDICYmIHRoaXMuX29mZnNldCA9PT0gMCA6IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEFTUC5ORVQganNvbiBkYXRlIGZvcm1hdCByZWdleFxuICAgIHZhciBhc3BOZXRSZWdleCA9IC9eKC18XFwrKT8oPzooXFxkKilbLiBdKT8oXFxkKyk6KFxcZCspKD86OihcXGQrKShcXC5cXGQqKT8pPyQvLFxuICAgICAgICAvLyBmcm9tIGh0dHA6Ly9kb2NzLmNsb3N1cmUtbGlicmFyeS5nb29nbGVjb2RlLmNvbS9naXQvY2xvc3VyZV9nb29nX2RhdGVfZGF0ZS5qcy5zb3VyY2UuaHRtbFxuICAgICAgICAvLyBzb21ld2hhdCBtb3JlIGluIGxpbmUgd2l0aCA0LjQuMy4yIDIwMDQgc3BlYywgYnV0IGFsbG93cyBkZWNpbWFsIGFueXdoZXJlXG4gICAgICAgIC8vIGFuZCBmdXJ0aGVyIG1vZGlmaWVkIHRvIGFsbG93IGZvciBzdHJpbmdzIGNvbnRhaW5pbmcgYm90aCB3ZWVrIGFuZCBkYXlcbiAgICAgICAgaXNvUmVnZXggPVxuICAgICAgICAgICAgL14oLXxcXCspP1AoPzooWy0rXT9bMC05LC5dKilZKT8oPzooWy0rXT9bMC05LC5dKilNKT8oPzooWy0rXT9bMC05LC5dKilXKT8oPzooWy0rXT9bMC05LC5dKilEKT8oPzpUKD86KFstK10/WzAtOSwuXSopSCk/KD86KFstK10/WzAtOSwuXSopTSk/KD86KFstK10/WzAtOSwuXSopUyk/KT8kLztcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUR1cmF0aW9uKGlucHV0LCBrZXkpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gaW5wdXQsXG4gICAgICAgICAgICAvLyBtYXRjaGluZyBhZ2FpbnN0IHJlZ2V4cCBpcyBleHBlbnNpdmUsIGRvIGl0IG9uIGRlbWFuZFxuICAgICAgICAgICAgbWF0Y2ggPSBudWxsLFxuICAgICAgICAgICAgc2lnbixcbiAgICAgICAgICAgIHJldCxcbiAgICAgICAgICAgIGRpZmZSZXM7XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBtczogaW5wdXQuX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgICAgICBkOiBpbnB1dC5fZGF5cyxcbiAgICAgICAgICAgICAgICBNOiBpbnB1dC5fbW9udGhzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChpc051bWJlcihpbnB1dCkgfHwgIWlzTmFOKCtpbnB1dCkpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb25ba2V5XSA9ICtpbnB1dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb24ubWlsbGlzZWNvbmRzID0gK2lucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKChtYXRjaCA9IGFzcE5ldFJlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICAgICAgc2lnbiA9IG1hdGNoWzFdID09PSAnLScgPyAtMSA6IDE7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgIGQ6IHRvSW50KG1hdGNoW0RBVEVdKSAqIHNpZ24sXG4gICAgICAgICAgICAgICAgaDogdG9JbnQobWF0Y2hbSE9VUl0pICogc2lnbixcbiAgICAgICAgICAgICAgICBtOiB0b0ludChtYXRjaFtNSU5VVEVdKSAqIHNpZ24sXG4gICAgICAgICAgICAgICAgczogdG9JbnQobWF0Y2hbU0VDT05EXSkgKiBzaWduLFxuICAgICAgICAgICAgICAgIG1zOiB0b0ludChhYnNSb3VuZChtYXRjaFtNSUxMSVNFQ09ORF0gKiAxMDAwKSkgKiBzaWduLCAvLyB0aGUgbWlsbGlzZWNvbmQgZGVjaW1hbCBwb2ludCBpcyBpbmNsdWRlZCBpbiB0aGUgbWF0Y2hcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoKG1hdGNoID0gaXNvUmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgICAgICBzaWduID0gbWF0Y2hbMV0gPT09ICctJyA/IC0xIDogMTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHk6IHBhcnNlSXNvKG1hdGNoWzJdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBNOiBwYXJzZUlzbyhtYXRjaFszXSwgc2lnbiksXG4gICAgICAgICAgICAgICAgdzogcGFyc2VJc28obWF0Y2hbNF0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIGQ6IHBhcnNlSXNvKG1hdGNoWzVdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBoOiBwYXJzZUlzbyhtYXRjaFs2XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgbTogcGFyc2VJc28obWF0Y2hbN10sIHNpZ24pLFxuICAgICAgICAgICAgICAgIHM6IHBhcnNlSXNvKG1hdGNoWzhdLCBzaWduKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZHVyYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiBkdXJhdGlvbiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICgnZnJvbScgaW4gZHVyYXRpb24gfHwgJ3RvJyBpbiBkdXJhdGlvbilcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBkaWZmUmVzID0gbW9tZW50c0RpZmZlcmVuY2UoXG4gICAgICAgICAgICAgICAgY3JlYXRlTG9jYWwoZHVyYXRpb24uZnJvbSksXG4gICAgICAgICAgICAgICAgY3JlYXRlTG9jYWwoZHVyYXRpb24udG8pXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgZHVyYXRpb24ubXMgPSBkaWZmUmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIGR1cmF0aW9uLk0gPSBkaWZmUmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldCA9IG5ldyBEdXJhdGlvbihkdXJhdGlvbik7XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpICYmIGhhc093blByb3AoaW5wdXQsICdfbG9jYWxlJykpIHtcbiAgICAgICAgICAgIHJldC5fbG9jYWxlID0gaW5wdXQuX2xvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0R1cmF0aW9uKGlucHV0KSAmJiBoYXNPd25Qcm9wKGlucHV0LCAnX2lzVmFsaWQnKSkge1xuICAgICAgICAgICAgcmV0Ll9pc1ZhbGlkID0gaW5wdXQuX2lzVmFsaWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGNyZWF0ZUR1cmF0aW9uLmZuID0gRHVyYXRpb24ucHJvdG90eXBlO1xuICAgIGNyZWF0ZUR1cmF0aW9uLmludmFsaWQgPSBjcmVhdGVJbnZhbGlkJDE7XG5cbiAgICBmdW5jdGlvbiBwYXJzZUlzbyhpbnAsIHNpZ24pIHtcbiAgICAgICAgLy8gV2UnZCBub3JtYWxseSB1c2Ugfn5pbnAgZm9yIHRoaXMsIGJ1dCB1bmZvcnR1bmF0ZWx5IGl0IGFsc29cbiAgICAgICAgLy8gY29udmVydHMgZmxvYXRzIHRvIGludHMuXG4gICAgICAgIC8vIGlucCBtYXkgYmUgdW5kZWZpbmVkLCBzbyBjYXJlZnVsIGNhbGxpbmcgcmVwbGFjZSBvbiBpdC5cbiAgICAgICAgdmFyIHJlcyA9IGlucCAmJiBwYXJzZUZsb2F0KGlucC5yZXBsYWNlKCcsJywgJy4nKSk7XG4gICAgICAgIC8vIGFwcGx5IHNpZ24gd2hpbGUgd2UncmUgYXQgaXRcbiAgICAgICAgcmV0dXJuIChpc05hTihyZXMpID8gMCA6IHJlcykgKiBzaWduO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlcyA9IHt9O1xuXG4gICAgICAgIHJlcy5tb250aHMgPVxuICAgICAgICAgICAgb3RoZXIubW9udGgoKSAtIGJhc2UubW9udGgoKSArIChvdGhlci55ZWFyKCkgLSBiYXNlLnllYXIoKSkgKiAxMjtcbiAgICAgICAgaWYgKGJhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKS5pc0FmdGVyKG90aGVyKSkge1xuICAgICAgICAgICAgLS1yZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzLm1pbGxpc2Vjb25kcyA9ICtvdGhlciAtICtiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJyk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgICAgICB2YXIgcmVzO1xuICAgICAgICBpZiAoIShiYXNlLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBtaWxsaXNlY29uZHM6IDAsIG1vbnRoczogMCB9O1xuICAgICAgICB9XG5cbiAgICAgICAgb3RoZXIgPSBjbG9uZVdpdGhPZmZzZXQob3RoZXIsIGJhc2UpO1xuICAgICAgICBpZiAoYmFzZS5pc0JlZm9yZShvdGhlcikpIHtcbiAgICAgICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShvdGhlciwgYmFzZSk7XG4gICAgICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gLXJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgICAgICByZXMubW9udGhzID0gLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IHJlbW92ZSAnbmFtZScgYXJnIGFmdGVyIGRlcHJlY2F0aW9uIGlzIHJlbW92ZWRcbiAgICBmdW5jdGlvbiBjcmVhdGVBZGRlcihkaXJlY3Rpb24sIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwsIHBlcmlvZCkge1xuICAgICAgICAgICAgdmFyIGR1ciwgdG1wO1xuICAgICAgICAgICAgLy9pbnZlcnQgdGhlIGFyZ3VtZW50cywgYnV0IGNvbXBsYWluIGFib3V0IGl0XG4gICAgICAgICAgICBpZiAocGVyaW9kICE9PSBudWxsICYmICFpc05hTigrcGVyaW9kKSkge1xuICAgICAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZShcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgJ21vbWVudCgpLicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKHBlcmlvZCwgbnVtYmVyKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIG1vbWVudCgpLicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKG51bWJlciwgcGVyaW9kKS4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvYWRkLWludmVydGVkLXBhcmFtLyBmb3IgbW9yZSBpbmZvLidcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRtcCA9IHZhbDtcbiAgICAgICAgICAgICAgICB2YWwgPSBwZXJpb2Q7XG4gICAgICAgICAgICAgICAgcGVyaW9kID0gdG1wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkdXIgPSBjcmVhdGVEdXJhdGlvbih2YWwsIHBlcmlvZCk7XG4gICAgICAgICAgICBhZGRTdWJ0cmFjdCh0aGlzLCBkdXIsIGRpcmVjdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRTdWJ0cmFjdChtb20sIGR1cmF0aW9uLCBpc0FkZGluZywgdXBkYXRlT2Zmc2V0KSB7XG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgZGF5cyA9IGFic1JvdW5kKGR1cmF0aW9uLl9kYXlzKSxcbiAgICAgICAgICAgIG1vbnRocyA9IGFic1JvdW5kKGR1cmF0aW9uLl9tb250aHMpO1xuXG4gICAgICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZU9mZnNldCA9IHVwZGF0ZU9mZnNldCA9PSBudWxsID8gdHJ1ZSA6IHVwZGF0ZU9mZnNldDtcblxuICAgICAgICBpZiAobW9udGhzKSB7XG4gICAgICAgICAgICBzZXRNb250aChtb20sIGdldChtb20sICdNb250aCcpICsgbW9udGhzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXlzKSB7XG4gICAgICAgICAgICBzZXQkMShtb20sICdEYXRlJywgZ2V0KG1vbSwgJ0RhdGUnKSArIGRheXMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbGxpc2Vjb25kcykge1xuICAgICAgICAgICAgbW9tLl9kLnNldFRpbWUobW9tLl9kLnZhbHVlT2YoKSArIG1pbGxpc2Vjb25kcyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlT2Zmc2V0KSB7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQobW9tLCBkYXlzIHx8IG1vbnRocyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYWRkID0gY3JlYXRlQWRkZXIoMSwgJ2FkZCcpLFxuICAgICAgICBzdWJ0cmFjdCA9IGNyZWF0ZUFkZGVyKC0xLCAnc3VidHJhY3QnKTtcblxuICAgIGZ1bmN0aW9uIGlzU3RyaW5nKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnIHx8IGlucHV0IGluc3RhbmNlb2YgU3RyaW5nO1xuICAgIH1cblxuICAgIC8vIHR5cGUgTW9tZW50SW5wdXQgPSBNb21lbnQgfCBEYXRlIHwgc3RyaW5nIHwgbnVtYmVyIHwgKG51bWJlciB8IHN0cmluZylbXSB8IE1vbWVudElucHV0T2JqZWN0IHwgdm9pZDsgLy8gbnVsbCB8IHVuZGVmaW5lZFxuICAgIGZ1bmN0aW9uIGlzTW9tZW50SW5wdXQoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGlzTW9tZW50KGlucHV0KSB8fFxuICAgICAgICAgICAgaXNEYXRlKGlucHV0KSB8fFxuICAgICAgICAgICAgaXNTdHJpbmcoaW5wdXQpIHx8XG4gICAgICAgICAgICBpc051bWJlcihpbnB1dCkgfHxcbiAgICAgICAgICAgIGlzTnVtYmVyT3JTdHJpbmdBcnJheShpbnB1dCkgfHxcbiAgICAgICAgICAgIGlzTW9tZW50SW5wdXRPYmplY3QoaW5wdXQpIHx8XG4gICAgICAgICAgICBpbnB1dCA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgaW5wdXQgPT09IHVuZGVmaW5lZFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTW9tZW50SW5wdXRPYmplY3QoaW5wdXQpIHtcbiAgICAgICAgdmFyIG9iamVjdFRlc3QgPSBpc09iamVjdChpbnB1dCkgJiYgIWlzT2JqZWN0RW1wdHkoaW5wdXQpLFxuICAgICAgICAgICAgcHJvcGVydHlUZXN0ID0gZmFsc2UsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzID0gW1xuICAgICAgICAgICAgICAgICd5ZWFycycsXG4gICAgICAgICAgICAgICAgJ3llYXInLFxuICAgICAgICAgICAgICAgICd5JyxcbiAgICAgICAgICAgICAgICAnbW9udGhzJyxcbiAgICAgICAgICAgICAgICAnbW9udGgnLFxuICAgICAgICAgICAgICAgICdNJyxcbiAgICAgICAgICAgICAgICAnZGF5cycsXG4gICAgICAgICAgICAgICAgJ2RheScsXG4gICAgICAgICAgICAgICAgJ2QnLFxuICAgICAgICAgICAgICAgICdkYXRlcycsXG4gICAgICAgICAgICAgICAgJ2RhdGUnLFxuICAgICAgICAgICAgICAgICdEJyxcbiAgICAgICAgICAgICAgICAnaG91cnMnLFxuICAgICAgICAgICAgICAgICdob3VyJyxcbiAgICAgICAgICAgICAgICAnaCcsXG4gICAgICAgICAgICAgICAgJ21pbnV0ZXMnLFxuICAgICAgICAgICAgICAgICdtaW51dGUnLFxuICAgICAgICAgICAgICAgICdtJyxcbiAgICAgICAgICAgICAgICAnc2Vjb25kcycsXG4gICAgICAgICAgICAgICAgJ3NlY29uZCcsXG4gICAgICAgICAgICAgICAgJ3MnLFxuICAgICAgICAgICAgICAgICdtaWxsaXNlY29uZHMnLFxuICAgICAgICAgICAgICAgICdtaWxsaXNlY29uZCcsXG4gICAgICAgICAgICAgICAgJ21zJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgICBwcm9wZXJ0eUxlbiA9IHByb3BlcnRpZXMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwcm9wZXJ0eUxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV07XG4gICAgICAgICAgICBwcm9wZXJ0eVRlc3QgPSBwcm9wZXJ0eVRlc3QgfHwgaGFzT3duUHJvcChpbnB1dCwgcHJvcGVydHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iamVjdFRlc3QgJiYgcHJvcGVydHlUZXN0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTnVtYmVyT3JTdHJpbmdBcnJheShpbnB1dCkge1xuICAgICAgICB2YXIgYXJyYXlUZXN0ID0gaXNBcnJheShpbnB1dCksXG4gICAgICAgICAgICBkYXRhVHlwZVRlc3QgPSBmYWxzZTtcbiAgICAgICAgaWYgKGFycmF5VGVzdCkge1xuICAgICAgICAgICAgZGF0YVR5cGVUZXN0ID1cbiAgICAgICAgICAgICAgICBpbnB1dC5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFpc051bWJlcihpdGVtKSAmJiBpc1N0cmluZyhpbnB1dCk7XG4gICAgICAgICAgICAgICAgfSkubGVuZ3RoID09PSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJheVRlc3QgJiYgZGF0YVR5cGVUZXN0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQ2FsZW5kYXJTcGVjKGlucHV0KSB7XG4gICAgICAgIHZhciBvYmplY3RUZXN0ID0gaXNPYmplY3QoaW5wdXQpICYmICFpc09iamVjdEVtcHR5KGlucHV0KSxcbiAgICAgICAgICAgIHByb3BlcnR5VGVzdCA9IGZhbHNlLFxuICAgICAgICAgICAgcHJvcGVydGllcyA9IFtcbiAgICAgICAgICAgICAgICAnc2FtZURheScsXG4gICAgICAgICAgICAgICAgJ25leHREYXknLFxuICAgICAgICAgICAgICAgICdsYXN0RGF5JyxcbiAgICAgICAgICAgICAgICAnbmV4dFdlZWsnLFxuICAgICAgICAgICAgICAgICdsYXN0V2VlaycsXG4gICAgICAgICAgICAgICAgJ3NhbWVFbHNlJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgcHJvcGVydHk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHByb3BlcnR5ID0gcHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgIHByb3BlcnR5VGVzdCA9IHByb3BlcnR5VGVzdCB8fCBoYXNPd25Qcm9wKGlucHV0LCBwcm9wZXJ0eSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqZWN0VGVzdCAmJiBwcm9wZXJ0eVRlc3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q2FsZW5kYXJGb3JtYXQobXlNb21lbnQsIG5vdykge1xuICAgICAgICB2YXIgZGlmZiA9IG15TW9tZW50LmRpZmYobm93LCAnZGF5cycsIHRydWUpO1xuICAgICAgICByZXR1cm4gZGlmZiA8IC02XG4gICAgICAgICAgICA/ICdzYW1lRWxzZSdcbiAgICAgICAgICAgIDogZGlmZiA8IC0xXG4gICAgICAgICAgICA/ICdsYXN0V2VlaydcbiAgICAgICAgICAgIDogZGlmZiA8IDBcbiAgICAgICAgICAgID8gJ2xhc3REYXknXG4gICAgICAgICAgICA6IGRpZmYgPCAxXG4gICAgICAgICAgICA/ICdzYW1lRGF5J1xuICAgICAgICAgICAgOiBkaWZmIDwgMlxuICAgICAgICAgICAgPyAnbmV4dERheSdcbiAgICAgICAgICAgIDogZGlmZiA8IDdcbiAgICAgICAgICAgID8gJ25leHRXZWVrJ1xuICAgICAgICAgICAgOiAnc2FtZUVsc2UnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbGVuZGFyJDEodGltZSwgZm9ybWF0cykge1xuICAgICAgICAvLyBTdXBwb3J0IGZvciBzaW5nbGUgcGFyYW1ldGVyLCBmb3JtYXRzIG9ubHkgb3ZlcmxvYWQgdG8gdGhlIGNhbGVuZGFyIGZ1bmN0aW9uXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50c1swXSkge1xuICAgICAgICAgICAgICAgIHRpbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgZm9ybWF0cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNNb21lbnRJbnB1dChhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgICAgICAgICAgdGltZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgICAgICBmb3JtYXRzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0NhbGVuZGFyU3BlYyhhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0cyA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgICAgICB0aW1lID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFdlIHdhbnQgdG8gY29tcGFyZSB0aGUgc3RhcnQgb2YgdG9kYXksIHZzIHRoaXMuXG4gICAgICAgIC8vIEdldHRpbmcgc3RhcnQtb2YtdG9kYXkgZGVwZW5kcyBvbiB3aGV0aGVyIHdlJ3JlIGxvY2FsL3V0Yy9vZmZzZXQgb3Igbm90LlxuICAgICAgICB2YXIgbm93ID0gdGltZSB8fCBjcmVhdGVMb2NhbCgpLFxuICAgICAgICAgICAgc29kID0gY2xvbmVXaXRoT2Zmc2V0KG5vdywgdGhpcykuc3RhcnRPZignZGF5JyksXG4gICAgICAgICAgICBmb3JtYXQgPSBob29rcy5jYWxlbmRhckZvcm1hdCh0aGlzLCBzb2QpIHx8ICdzYW1lRWxzZScsXG4gICAgICAgICAgICBvdXRwdXQgPVxuICAgICAgICAgICAgICAgIGZvcm1hdHMgJiZcbiAgICAgICAgICAgICAgICAoaXNGdW5jdGlvbihmb3JtYXRzW2Zvcm1hdF0pXG4gICAgICAgICAgICAgICAgICAgID8gZm9ybWF0c1tmb3JtYXRdLmNhbGwodGhpcywgbm93KVxuICAgICAgICAgICAgICAgICAgICA6IGZvcm1hdHNbZm9ybWF0XSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KFxuICAgICAgICAgICAgb3V0cHV0IHx8IHRoaXMubG9jYWxlRGF0YSgpLmNhbGVuZGFyKGZvcm1hdCwgdGhpcywgY3JlYXRlTG9jYWwobm93KSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNb21lbnQodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNBZnRlcihpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cykgfHwgJ21pbGxpc2Vjb25kJztcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPiBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbElucHV0LnZhbHVlT2YoKSA8IHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKS52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0JlZm9yZShpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cykgfHwgJ21pbGxpc2Vjb25kJztcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPCBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNCZXR3ZWVuKGZyb20sIHRvLCB1bml0cywgaW5jbHVzaXZpdHkpIHtcbiAgICAgICAgdmFyIGxvY2FsRnJvbSA9IGlzTW9tZW50KGZyb20pID8gZnJvbSA6IGNyZWF0ZUxvY2FsKGZyb20pLFxuICAgICAgICAgICAgbG9jYWxUbyA9IGlzTW9tZW50KHRvKSA/IHRvIDogY3JlYXRlTG9jYWwodG8pO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbEZyb20uaXNWYWxpZCgpICYmIGxvY2FsVG8uaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGluY2x1c2l2aXR5ID0gaW5jbHVzaXZpdHkgfHwgJygpJztcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChpbmNsdXNpdml0eVswXSA9PT0gJygnXG4gICAgICAgICAgICAgICAgPyB0aGlzLmlzQWZ0ZXIobG9jYWxGcm9tLCB1bml0cylcbiAgICAgICAgICAgICAgICA6ICF0aGlzLmlzQmVmb3JlKGxvY2FsRnJvbSwgdW5pdHMpKSAmJlxuICAgICAgICAgICAgKGluY2x1c2l2aXR5WzFdID09PSAnKSdcbiAgICAgICAgICAgICAgICA/IHRoaXMuaXNCZWZvcmUobG9jYWxUbywgdW5pdHMpXG4gICAgICAgICAgICAgICAgOiAhdGhpcy5pc0FmdGVyKGxvY2FsVG8sIHVuaXRzKSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1NhbWUoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBjcmVhdGVMb2NhbChpbnB1dCksXG4gICAgICAgICAgICBpbnB1dE1zO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB8fCAnbWlsbGlzZWNvbmQnO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA9PT0gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnB1dE1zID0gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKS52YWx1ZU9mKCkgPD0gaW5wdXRNcyAmJlxuICAgICAgICAgICAgICAgIGlucHV0TXMgPD0gdGhpcy5jbG9uZSgpLmVuZE9mKHVuaXRzKS52YWx1ZU9mKClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1NhbWVPckFmdGVyKGlucHV0LCB1bml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1NhbWUoaW5wdXQsIHVuaXRzKSB8fCB0aGlzLmlzQWZ0ZXIoaW5wdXQsIHVuaXRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1NhbWVPckJlZm9yZShpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTYW1lKGlucHV0LCB1bml0cykgfHwgdGhpcy5pc0JlZm9yZShpbnB1dCwgdW5pdHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpZmYoaW5wdXQsIHVuaXRzLCBhc0Zsb2F0KSB7XG4gICAgICAgIHZhciB0aGF0LCB6b25lRGVsdGEsIG91dHB1dDtcblxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhhdCA9IGNsb25lV2l0aE9mZnNldChpbnB1dCwgdGhpcyk7XG5cbiAgICAgICAgaWYgKCF0aGF0LmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIHpvbmVEZWx0YSA9ICh0aGF0LnV0Y09mZnNldCgpIC0gdGhpcy51dGNPZmZzZXQoKSkgKiA2ZTQ7XG5cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gbW9udGhEaWZmKHRoaXMsIHRoYXQpIC8gMTI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gbW9udGhEaWZmKHRoaXMsIHRoYXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncXVhcnRlcic6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gbW9udGhEaWZmKHRoaXMsIHRoYXQpIC8gMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDFlMztcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gMTAwMFxuICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAodGhpcyAtIHRoYXQpIC8gNmU0O1xuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyAxMDAwICogNjBcbiAgICAgICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyAzNmU1O1xuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MFxuICAgICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAodGhpcyAtIHRoYXQgLSB6b25lRGVsdGEpIC8gODY0ZTU7XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIDEwMDAgKiA2MCAqIDYwICogMjQsIG5lZ2F0ZSBkc3RcbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0aGlzIC0gdGhhdCAtIHpvbmVEZWx0YSkgLyA2MDQ4ZTU7XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIDEwMDAgKiA2MCAqIDYwICogMjQgKiA3LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIG91dHB1dCA9IHRoaXMgLSB0aGF0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFzRmxvYXQgPyBvdXRwdXQgOiBhYnNGbG9vcihvdXRwdXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbnRoRGlmZihhLCBiKSB7XG4gICAgICAgIGlmIChhLmRhdGUoKSA8IGIuZGF0ZSgpKSB7XG4gICAgICAgICAgICAvLyBlbmQtb2YtbW9udGggY2FsY3VsYXRpb25zIHdvcmsgY29ycmVjdCB3aGVuIHRoZSBzdGFydCBtb250aCBoYXMgbW9yZVxuICAgICAgICAgICAgLy8gZGF5cyB0aGFuIHRoZSBlbmQgbW9udGguXG4gICAgICAgICAgICByZXR1cm4gLW1vbnRoRGlmZihiLCBhKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkaWZmZXJlbmNlIGluIG1vbnRoc1xuICAgICAgICB2YXIgd2hvbGVNb250aERpZmYgPSAoYi55ZWFyKCkgLSBhLnllYXIoKSkgKiAxMiArIChiLm1vbnRoKCkgLSBhLm1vbnRoKCkpLFxuICAgICAgICAgICAgLy8gYiBpcyBpbiAoYW5jaG9yIC0gMSBtb250aCwgYW5jaG9yICsgMSBtb250aClcbiAgICAgICAgICAgIGFuY2hvciA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYsICdtb250aHMnKSxcbiAgICAgICAgICAgIGFuY2hvcjIsXG4gICAgICAgICAgICBhZGp1c3Q7XG5cbiAgICAgICAgaWYgKGIgLSBhbmNob3IgPCAwKSB7XG4gICAgICAgICAgICBhbmNob3IyID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiAtIDEsICdtb250aHMnKTtcbiAgICAgICAgICAgIC8vIGxpbmVhciBhY3Jvc3MgdGhlIG1vbnRoXG4gICAgICAgICAgICBhZGp1c3QgPSAoYiAtIGFuY2hvcikgLyAoYW5jaG9yIC0gYW5jaG9yMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbmNob3IyID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiArIDEsICdtb250aHMnKTtcbiAgICAgICAgICAgIC8vIGxpbmVhciBhY3Jvc3MgdGhlIG1vbnRoXG4gICAgICAgICAgICBhZGp1c3QgPSAoYiAtIGFuY2hvcikgLyAoYW5jaG9yMiAtIGFuY2hvcik7XG4gICAgICAgIH1cblxuICAgICAgICAvL2NoZWNrIGZvciBuZWdhdGl2ZSB6ZXJvLCByZXR1cm4gemVybyBpZiBuZWdhdGl2ZSB6ZXJvXG4gICAgICAgIHJldHVybiAtKHdob2xlTW9udGhEaWZmICsgYWRqdXN0KSB8fCAwO1xuICAgIH1cblxuICAgIGhvb2tzLmRlZmF1bHRGb3JtYXQgPSAnWVlZWS1NTS1ERFRISDptbTpzc1onO1xuICAgIGhvb2tzLmRlZmF1bHRGb3JtYXRVdGMgPSAnWVlZWS1NTS1ERFRISDptbTpzc1taXSc7XG5cbiAgICBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5sb2NhbGUoJ2VuJykuZm9ybWF0KCdkZGQgTU1NIEREIFlZWVkgSEg6bW06c3MgW0dNVF1aWicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSVNPU3RyaW5nKGtlZXBPZmZzZXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHV0YyA9IGtlZXBPZmZzZXQgIT09IHRydWUsXG4gICAgICAgICAgICBtID0gdXRjID8gdGhpcy5jbG9uZSgpLnV0YygpIDogdGhpcztcbiAgICAgICAgaWYgKG0ueWVhcigpIDwgMCB8fCBtLnllYXIoKSA+IDk5OTkpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQoXG4gICAgICAgICAgICAgICAgbSxcbiAgICAgICAgICAgICAgICB1dGNcbiAgICAgICAgICAgICAgICAgICAgPyAnWVlZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJ1xuICAgICAgICAgICAgICAgICAgICA6ICdZWVlZWVktTU0tRERbVF1ISDptbTpzcy5TU1NaJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNGdW5jdGlvbihEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZykpIHtcbiAgICAgICAgICAgIC8vIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBpcyB+NTB4IGZhc3RlciwgdXNlIGl0IHdoZW4gd2UgY2FuXG4gICAgICAgICAgICBpZiAodXRjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9EYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudmFsdWVPZigpICsgdGhpcy51dGNPZmZzZXQoKSAqIDYwICogMTAwMClcbiAgICAgICAgICAgICAgICAgICAgLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoJ1onLCBmb3JtYXRNb21lbnQobSwgJ1onKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChcbiAgICAgICAgICAgIG0sXG4gICAgICAgICAgICB1dGMgPyAnWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXScgOiAnWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1onXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgaHVtYW4gcmVhZGFibGUgcmVwcmVzZW50YXRpb24gb2YgYSBtb21lbnQgdGhhdCBjYW5cbiAgICAgKiBhbHNvIGJlIGV2YWx1YXRlZCB0byBnZXQgYSBuZXcgbW9tZW50IHdoaWNoIGlzIHRoZSBzYW1lXG4gICAgICpcbiAgICAgKiBAbGluayBodHRwczovL25vZGVqcy5vcmcvZGlzdC9sYXRlc3QvZG9jcy9hcGkvdXRpbC5odG1sI3V0aWxfY3VzdG9tX2luc3BlY3RfZnVuY3Rpb25fb25fb2JqZWN0c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnbW9tZW50LmludmFsaWQoLyogJyArIHRoaXMuX2kgKyAnICovKSc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZ1bmMgPSAnbW9tZW50JyxcbiAgICAgICAgICAgIHpvbmUgPSAnJyxcbiAgICAgICAgICAgIHByZWZpeCxcbiAgICAgICAgICAgIHllYXIsXG4gICAgICAgICAgICBkYXRldGltZSxcbiAgICAgICAgICAgIHN1ZmZpeDtcbiAgICAgICAgaWYgKCF0aGlzLmlzTG9jYWwoKSkge1xuICAgICAgICAgICAgZnVuYyA9IHRoaXMudXRjT2Zmc2V0KCkgPT09IDAgPyAnbW9tZW50LnV0YycgOiAnbW9tZW50LnBhcnNlWm9uZSc7XG4gICAgICAgICAgICB6b25lID0gJ1onO1xuICAgICAgICB9XG4gICAgICAgIHByZWZpeCA9ICdbJyArIGZ1bmMgKyAnKFwiXSc7XG4gICAgICAgIHllYXIgPSAwIDw9IHRoaXMueWVhcigpICYmIHRoaXMueWVhcigpIDw9IDk5OTkgPyAnWVlZWScgOiAnWVlZWVlZJztcbiAgICAgICAgZGF0ZXRpbWUgPSAnLU1NLUREW1RdSEg6bW06c3MuU1NTJztcbiAgICAgICAgc3VmZml4ID0gem9uZSArICdbXCIpXSc7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KHByZWZpeCArIHllYXIgKyBkYXRldGltZSArIHN1ZmZpeCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0KGlucHV0U3RyaW5nKSB7XG4gICAgICAgIGlmICghaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgICAgIGlucHV0U3RyaW5nID0gdGhpcy5pc1V0YygpXG4gICAgICAgICAgICAgICAgPyBob29rcy5kZWZhdWx0Rm9ybWF0VXRjXG4gICAgICAgICAgICAgICAgOiBob29rcy5kZWZhdWx0Rm9ybWF0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdXRwdXQgPSBmb3JtYXRNb21lbnQodGhpcywgaW5wdXRTdHJpbmcpO1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkucG9zdGZvcm1hdChvdXRwdXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZyb20odGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgKChpc01vbWVudCh0aW1lKSAmJiB0aW1lLmlzVmFsaWQoKSkgfHwgY3JlYXRlTG9jYWwodGltZSkuaXNWYWxpZCgpKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7IHRvOiB0aGlzLCBmcm9tOiB0aW1lIH0pXG4gICAgICAgICAgICAgICAgLmxvY2FsZSh0aGlzLmxvY2FsZSgpKVxuICAgICAgICAgICAgICAgIC5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZyb21Ob3cod2l0aG91dFN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tKGNyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvKHRpbWUsIHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICgoaXNNb21lbnQodGltZSkgJiYgdGltZS5pc1ZhbGlkKCkpIHx8IGNyZWF0ZUxvY2FsKHRpbWUpLmlzVmFsaWQoKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oeyBmcm9tOiB0aGlzLCB0bzogdGltZSB9KVxuICAgICAgICAgICAgICAgIC5sb2NhbGUodGhpcy5sb2NhbGUoKSlcbiAgICAgICAgICAgICAgICAuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b05vdyh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvKGNyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xuICAgIH1cblxuICAgIC8vIElmIHBhc3NlZCBhIGxvY2FsZSBrZXksIGl0IHdpbGwgc2V0IHRoZSBsb2NhbGUgZm9yIHRoaXNcbiAgICAvLyBpbnN0YW5jZS4gIE90aGVyd2lzZSwgaXQgd2lsbCByZXR1cm4gdGhlIGxvY2FsZSBjb25maWd1cmF0aW9uXG4gICAgLy8gdmFyaWFibGVzIGZvciB0aGlzIGluc3RhbmNlLlxuICAgIGZ1bmN0aW9uIGxvY2FsZShrZXkpIHtcbiAgICAgICAgdmFyIG5ld0xvY2FsZURhdGE7XG5cbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxlLl9hYmJyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3TG9jYWxlRGF0YSA9IGdldExvY2FsZShrZXkpO1xuICAgICAgICAgICAgaWYgKG5ld0xvY2FsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvY2FsZSA9IG5ld0xvY2FsZURhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsYW5nID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50KCkubGFuZygpIGlzIGRlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZSBtb21lbnQoKS5sb2NhbGVEYXRhKCkgdG8gZ2V0IHRoZSBsYW5ndWFnZSBjb25maWd1cmF0aW9uLiBVc2UgbW9tZW50KCkubG9jYWxlKCkgdG8gY2hhbmdlIGxhbmd1YWdlcy4nLFxuICAgICAgICBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZURhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGU7XG4gICAgfVxuXG4gICAgdmFyIE1TX1BFUl9TRUNPTkQgPSAxMDAwLFxuICAgICAgICBNU19QRVJfTUlOVVRFID0gNjAgKiBNU19QRVJfU0VDT05ELFxuICAgICAgICBNU19QRVJfSE9VUiA9IDYwICogTVNfUEVSX01JTlVURSxcbiAgICAgICAgTVNfUEVSXzQwMF9ZRUFSUyA9ICgzNjUgKiA0MDAgKyA5NykgKiAyNCAqIE1TX1BFUl9IT1VSO1xuXG4gICAgLy8gYWN0dWFsIG1vZHVsbyAtIGhhbmRsZXMgbmVnYXRpdmUgbnVtYmVycyAoZm9yIGRhdGVzIGJlZm9yZSAxOTcwKTpcbiAgICBmdW5jdGlvbiBtb2QkMShkaXZpZGVuZCwgZGl2aXNvcikge1xuICAgICAgICByZXR1cm4gKChkaXZpZGVuZCAlIGRpdmlzb3IpICsgZGl2aXNvcikgJSBkaXZpc29yO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsU3RhcnRPZkRhdGUoeSwgbSwgZCkge1xuICAgICAgICAvLyB0aGUgZGF0ZSBjb25zdHJ1Y3RvciByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwKSB7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBsZWFwIHllYXJzIHVzaW5nIGEgZnVsbCA0MDAgeWVhciBjeWNsZSwgdGhlbiByZXNldFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHkgKyA0MDAsIG0sIGQpIC0gTVNfUEVSXzQwMF9ZRUFSUztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh5LCBtLCBkKS52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1dGNTdGFydE9mRGF0ZSh5LCBtLCBkKSB7XG4gICAgICAgIC8vIERhdGUuVVRDIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDApIHtcbiAgICAgICAgICAgIC8vIHByZXNlcnZlIGxlYXAgeWVhcnMgdXNpbmcgYSBmdWxsIDQwMCB5ZWFyIGN5Y2xlLCB0aGVuIHJlc2V0XG4gICAgICAgICAgICByZXR1cm4gRGF0ZS5VVEMoeSArIDQwMCwgbSwgZCkgLSBNU19QRVJfNDAwX1lFQVJTO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIERhdGUuVVRDKHksIG0sIGQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhcnRPZih1bml0cykge1xuICAgICAgICB2YXIgdGltZSwgc3RhcnRPZkRhdGU7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICBpZiAodW5pdHMgPT09IHVuZGVmaW5lZCB8fCB1bml0cyA9PT0gJ21pbGxpc2Vjb25kJyB8fCAhdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnRPZkRhdGUgPSB0aGlzLl9pc1VUQyA/IHV0Y1N0YXJ0T2ZEYXRlIDogbG9jYWxTdGFydE9mRGF0ZTtcblxuICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIDAsIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncXVhcnRlcic6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnllYXIoKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb250aCgpIC0gKHRoaXMubW9udGgoKSAlIDMpLFxuICAgICAgICAgICAgICAgICAgICAxXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueWVhcigpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0ZSgpIC0gdGhpcy53ZWVrZGF5KClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaXNvV2Vlayc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnllYXIoKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb250aCgpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGUoKSAtICh0aGlzLmlzb1dlZWtkYXkoKSAtIDEpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgdGhpcy5kYXRlKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgLT0gbW9kJDEoXG4gICAgICAgICAgICAgICAgICAgIHRpbWUgKyAodGhpcy5faXNVVEMgPyAwIDogdGhpcy51dGNPZmZzZXQoKSAqIE1TX1BFUl9NSU5VVEUpLFxuICAgICAgICAgICAgICAgICAgICBNU19QRVJfSE9VUlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lIC09IG1vZCQxKHRpbWUsIE1TX1BFUl9NSU5VVEUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSAtPSBtb2QkMSh0aW1lLCBNU19QRVJfU0VDT05EKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2Quc2V0VGltZSh0aW1lKTtcbiAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbmRPZih1bml0cykge1xuICAgICAgICB2YXIgdGltZSwgc3RhcnRPZkRhdGU7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICBpZiAodW5pdHMgPT09IHVuZGVmaW5lZCB8fCB1bml0cyA9PT0gJ21pbGxpc2Vjb25kJyB8fCAhdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnRPZkRhdGUgPSB0aGlzLl9pc1VUQyA/IHV0Y1N0YXJ0T2ZEYXRlIDogbG9jYWxTdGFydE9mRGF0ZTtcblxuICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCkgKyAxLCAwLCAxKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgICAgICAgICB0aW1lID1cbiAgICAgICAgICAgICAgICAgICAgc3RhcnRPZkRhdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnllYXIoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9udGgoKSAtICh0aGlzLm1vbnRoKCkgJSAzKSArIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAxXG4gICAgICAgICAgICAgICAgICAgICkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpICsgMSwgMSkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICAgICAgdGltZSA9XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0T2ZEYXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55ZWFyKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGUoKSAtIHRoaXMud2Vla2RheSgpICsgN1xuICAgICAgICAgICAgICAgICAgICApIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2lzb1dlZWsnOlxuICAgICAgICAgICAgICAgIHRpbWUgPVxuICAgICAgICAgICAgICAgICAgICBzdGFydE9mRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueWVhcigpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb250aCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRlKCkgLSAodGhpcy5pc29XZWVrZGF5KCkgLSAxKSArIDdcbiAgICAgICAgICAgICAgICAgICAgKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpICsgMSkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgKz1cbiAgICAgICAgICAgICAgICAgICAgTVNfUEVSX0hPVVIgLVxuICAgICAgICAgICAgICAgICAgICBtb2QkMShcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWUgKyAodGhpcy5faXNVVEMgPyAwIDogdGhpcy51dGNPZmZzZXQoKSAqIE1TX1BFUl9NSU5VVEUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgTVNfUEVSX0hPVVJcbiAgICAgICAgICAgICAgICAgICAgKSAtXG4gICAgICAgICAgICAgICAgICAgIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lICs9IE1TX1BFUl9NSU5VVEUgLSBtb2QkMSh0aW1lLCBNU19QRVJfTUlOVVRFKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lICs9IE1TX1BFUl9TRUNPTkQgLSBtb2QkMSh0aW1lLCBNU19QRVJfU0VDT05EKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kLnNldFRpbWUodGltZSk7XG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsdWVPZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2QudmFsdWVPZigpIC0gKHRoaXMuX29mZnNldCB8fCAwKSAqIDYwMDAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuaXgoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMudmFsdWVPZigpIC8gMTAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9EYXRlKCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy52YWx1ZU9mKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvQXJyYXkoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG0ueWVhcigpLFxuICAgICAgICAgICAgbS5tb250aCgpLFxuICAgICAgICAgICAgbS5kYXRlKCksXG4gICAgICAgICAgICBtLmhvdXIoKSxcbiAgICAgICAgICAgIG0ubWludXRlKCksXG4gICAgICAgICAgICBtLnNlY29uZCgpLFxuICAgICAgICAgICAgbS5taWxsaXNlY29uZCgpLFxuICAgICAgICBdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvT2JqZWN0KCkge1xuICAgICAgICB2YXIgbSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5ZWFyczogbS55ZWFyKCksXG4gICAgICAgICAgICBtb250aHM6IG0ubW9udGgoKSxcbiAgICAgICAgICAgIGRhdGU6IG0uZGF0ZSgpLFxuICAgICAgICAgICAgaG91cnM6IG0uaG91cnMoKSxcbiAgICAgICAgICAgIG1pbnV0ZXM6IG0ubWludXRlcygpLFxuICAgICAgICAgICAgc2Vjb25kczogbS5zZWNvbmRzKCksXG4gICAgICAgICAgICBtaWxsaXNlY29uZHM6IG0ubWlsbGlzZWNvbmRzKCksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAvLyBuZXcgRGF0ZShOYU4pLnRvSlNPTigpID09PSBudWxsXG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMudG9JU09TdHJpbmcoKSA6IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWYWxpZCQyKCkge1xuICAgICAgICByZXR1cm4gaXNWYWxpZCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzaW5nRmxhZ3MoKSB7XG4gICAgICAgIHJldHVybiBleHRlbmQoe30sIGdldFBhcnNpbmdGbGFncyh0aGlzKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW52YWxpZEF0KCkge1xuICAgICAgICByZXR1cm4gZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpLm92ZXJmbG93O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0aW9uRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlucHV0OiB0aGlzLl9pLFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLl9mLFxuICAgICAgICAgICAgbG9jYWxlOiB0aGlzLl9sb2NhbGUsXG4gICAgICAgICAgICBpc1VUQzogdGhpcy5faXNVVEMsXG4gICAgICAgICAgICBzdHJpY3Q6IHRoaXMuX3N0cmljdCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhZGRGb3JtYXRUb2tlbignTicsIDAsIDAsICdlcmFBYmJyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ05OJywgMCwgMCwgJ2VyYUFiYnInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignTk5OJywgMCwgMCwgJ2VyYUFiYnInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignTk5OTicsIDAsIDAsICdlcmFOYW1lJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ05OTk5OJywgMCwgMCwgJ2VyYU5hcnJvdycpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3knLCBbJ3knLCAxXSwgJ3lvJywgJ2VyYVllYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigneScsIFsneXknLCAyXSwgMCwgJ2VyYVllYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigneScsIFsneXl5JywgM10sIDAsICdlcmFZZWFyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3knLCBbJ3l5eXknLCA0XSwgMCwgJ2VyYVllYXInKTtcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ04nLCBtYXRjaEVyYUFiYnIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ05OJywgbWF0Y2hFcmFBYmJyKTtcbiAgICBhZGRSZWdleFRva2VuKCdOTk4nLCBtYXRjaEVyYUFiYnIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ05OTk4nLCBtYXRjaEVyYU5hbWUpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ05OTk5OJywgbWF0Y2hFcmFOYXJyb3cpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihcbiAgICAgICAgWydOJywgJ05OJywgJ05OTicsICdOTk5OJywgJ05OTk5OJ10sXG4gICAgICAgIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgICAgIHZhciBlcmEgPSBjb25maWcuX2xvY2FsZS5lcmFzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgICAgICAgICBpZiAoZXJhKSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZXJhID0gZXJhO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkRXJhID0gaW5wdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgYWRkUmVnZXhUb2tlbigneScsIG1hdGNoVW5zaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3l5JywgbWF0Y2hVbnNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbigneXl5JywgbWF0Y2hVbnNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbigneXl5eScsIG1hdGNoVW5zaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3lvJywgbWF0Y2hFcmFZZWFyT3JkaW5hbCk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsneScsICd5eScsICd5eXknLCAneXl5eSddLCBZRUFSKTtcbiAgICBhZGRQYXJzZVRva2VuKFsneW8nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB2YXIgbWF0Y2g7XG4gICAgICAgIGlmIChjb25maWcuX2xvY2FsZS5fZXJhWWVhck9yZGluYWxSZWdleCkge1xuICAgICAgICAgICAgbWF0Y2ggPSBpbnB1dC5tYXRjaChjb25maWcuX2xvY2FsZS5fZXJhWWVhck9yZGluYWxSZWdleCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnLl9sb2NhbGUuZXJhWWVhck9yZGluYWxQYXJzZSkge1xuICAgICAgICAgICAgYXJyYXlbWUVBUl0gPSBjb25maWcuX2xvY2FsZS5lcmFZZWFyT3JkaW5hbFBhcnNlKGlucHV0LCBtYXRjaCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcnJheVtZRUFSXSA9IHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZUVyYXMobSwgZm9ybWF0KSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIGRhdGUsXG4gICAgICAgICAgICBlcmFzID0gdGhpcy5fZXJhcyB8fCBnZXRMb2NhbGUoJ2VuJykuX2VyYXM7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBlcmFzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgZXJhc1tpXS5zaW5jZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgICAgIC8vIHRydW5jYXRlIHRpbWVcbiAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IGhvb2tzKGVyYXNbaV0uc2luY2UpLnN0YXJ0T2YoJ2RheScpO1xuICAgICAgICAgICAgICAgICAgICBlcmFzW2ldLnNpbmNlID0gZGF0ZS52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBlcmFzW2ldLnVudGlsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgICAgICAgICAgICAgZXJhc1tpXS51bnRpbCA9ICtJbmZpbml0eTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJ1bmNhdGUgdGltZVxuICAgICAgICAgICAgICAgICAgICBkYXRlID0gaG9va3MoZXJhc1tpXS51bnRpbCkuc3RhcnRPZignZGF5JykudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgICAgICBlcmFzW2ldLnVudGlsID0gZGF0ZS52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcmFzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZUVyYXNQYXJzZShlcmFOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBlcmFzID0gdGhpcy5lcmFzKCksXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgYWJicixcbiAgICAgICAgICAgIG5hcnJvdztcbiAgICAgICAgZXJhTmFtZSA9IGVyYU5hbWUudG9VcHBlckNhc2UoKTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXJhcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIG5hbWUgPSBlcmFzW2ldLm5hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIGFiYnIgPSBlcmFzW2ldLmFiYnIudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIG5hcnJvdyA9IGVyYXNbaV0ubmFycm93LnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdOJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTk4nOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdOTk4nOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFiYnIgPT09IGVyYU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ05OTk4nOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09IGVyYU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ05OTk5OJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYXJyb3cgPT09IGVyYU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoW25hbWUsIGFiYnIsIG5hcnJvd10uaW5kZXhPZihlcmFOYW1lKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVFcmFzQ29udmVydFllYXIoZXJhLCB5ZWFyKSB7XG4gICAgICAgIHZhciBkaXIgPSBlcmEuc2luY2UgPD0gZXJhLnVudGlsID8gKzEgOiAtMTtcbiAgICAgICAgaWYgKHllYXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGhvb2tzKGVyYS5zaW5jZSkueWVhcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGhvb2tzKGVyYS5zaW5jZSkueWVhcigpICsgKHllYXIgLSBlcmEub2Zmc2V0KSAqIGRpcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEVyYU5hbWUoKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIHZhbCxcbiAgICAgICAgICAgIGVyYXMgPSB0aGlzLmxvY2FsZURhdGEoKS5lcmFzKCk7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBlcmFzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgLy8gdHJ1bmNhdGUgdGltZVxuICAgICAgICAgICAgdmFsID0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpLnZhbHVlT2YoKTtcblxuICAgICAgICAgICAgaWYgKGVyYXNbaV0uc2luY2UgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnVudGlsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV0ubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcmFzW2ldLnVudGlsIDw9IHZhbCAmJiB2YWwgPD0gZXJhc1tpXS5zaW5jZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RXJhTmFycm93KCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICBlcmFzID0gdGhpcy5sb2NhbGVEYXRhKCkuZXJhcygpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXJhcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIC8vIHRydW5jYXRlIHRpbWVcbiAgICAgICAgICAgIHZhbCA9IHRoaXMuY2xvbmUoKS5zdGFydE9mKCdkYXknKS52YWx1ZU9mKCk7XG5cbiAgICAgICAgICAgIGlmIChlcmFzW2ldLnNpbmNlIDw9IHZhbCAmJiB2YWwgPD0gZXJhc1tpXS51bnRpbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldLm5hcnJvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcmFzW2ldLnVudGlsIDw9IHZhbCAmJiB2YWwgPD0gZXJhc1tpXS5zaW5jZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldLm5hcnJvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRFcmFBYmJyKCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICBlcmFzID0gdGhpcy5sb2NhbGVEYXRhKCkuZXJhcygpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXJhcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIC8vIHRydW5jYXRlIHRpbWVcbiAgICAgICAgICAgIHZhbCA9IHRoaXMuY2xvbmUoKS5zdGFydE9mKCdkYXknKS52YWx1ZU9mKCk7XG5cbiAgICAgICAgICAgIGlmIChlcmFzW2ldLnNpbmNlIDw9IHZhbCAmJiB2YWwgPD0gZXJhc1tpXS51bnRpbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldLmFiYnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJhc1tpXS51bnRpbCA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0uc2luY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXS5hYmJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEVyYVllYXIoKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIGRpcixcbiAgICAgICAgICAgIHZhbCxcbiAgICAgICAgICAgIGVyYXMgPSB0aGlzLmxvY2FsZURhdGEoKS5lcmFzKCk7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBlcmFzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgZGlyID0gZXJhc1tpXS5zaW5jZSA8PSBlcmFzW2ldLnVudGlsID8gKzEgOiAtMTtcblxuICAgICAgICAgICAgLy8gdHJ1bmNhdGUgdGltZVxuICAgICAgICAgICAgdmFsID0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpLnZhbHVlT2YoKTtcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIChlcmFzW2ldLnNpbmNlIDw9IHZhbCAmJiB2YWwgPD0gZXJhc1tpXS51bnRpbCkgfHxcbiAgICAgICAgICAgICAgICAoZXJhc1tpXS51bnRpbCA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0uc2luY2UpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAodGhpcy55ZWFyKCkgLSBob29rcyhlcmFzW2ldLnNpbmNlKS55ZWFyKCkpICogZGlyICtcbiAgICAgICAgICAgICAgICAgICAgZXJhc1tpXS5vZmZzZXRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMueWVhcigpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVyYXNOYW1lUmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfZXJhc05hbWVSZWdleCcpKSB7XG4gICAgICAgICAgICBjb21wdXRlRXJhc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzU3RyaWN0ID8gdGhpcy5fZXJhc05hbWVSZWdleCA6IHRoaXMuX2VyYXNSZWdleDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcmFzQWJiclJlZ2V4KGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX2VyYXNBYmJyUmVnZXgnKSkge1xuICAgICAgICAgICAgY29tcHV0ZUVyYXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1N0cmljdCA/IHRoaXMuX2VyYXNBYmJyUmVnZXggOiB0aGlzLl9lcmFzUmVnZXg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXJhc05hcnJvd1JlZ2V4KGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX2VyYXNOYXJyb3dSZWdleCcpKSB7XG4gICAgICAgICAgICBjb21wdXRlRXJhc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzU3RyaWN0ID8gdGhpcy5fZXJhc05hcnJvd1JlZ2V4IDogdGhpcy5fZXJhc1JlZ2V4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hdGNoRXJhQWJicihpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUuZXJhc0FiYnJSZWdleChpc1N0cmljdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF0Y2hFcmFOYW1lKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5lcmFzTmFtZVJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXRjaEVyYU5hcnJvdyhpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUuZXJhc05hcnJvd1JlZ2V4KGlzU3RyaWN0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXRjaEVyYVllYXJPcmRpbmFsKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5fZXJhWWVhck9yZGluYWxSZWdleCB8fCBtYXRjaFVuc2lnbmVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVFcmFzUGFyc2UoKSB7XG4gICAgICAgIHZhciBhYmJyUGllY2VzID0gW10sXG4gICAgICAgICAgICBuYW1lUGllY2VzID0gW10sXG4gICAgICAgICAgICBuYXJyb3dQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIG1peGVkUGllY2VzID0gW10sXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIGVyYXMgPSB0aGlzLmVyYXMoKTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXJhcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIG5hbWVQaWVjZXMucHVzaChyZWdleEVzY2FwZShlcmFzW2ldLm5hbWUpKTtcbiAgICAgICAgICAgIGFiYnJQaWVjZXMucHVzaChyZWdleEVzY2FwZShlcmFzW2ldLmFiYnIpKTtcbiAgICAgICAgICAgIG5hcnJvd1BpZWNlcy5wdXNoKHJlZ2V4RXNjYXBlKGVyYXNbaV0ubmFycm93KSk7XG5cbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2gocmVnZXhFc2NhcGUoZXJhc1tpXS5uYW1lKSk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHJlZ2V4RXNjYXBlKGVyYXNbaV0uYWJicikpO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChyZWdleEVzY2FwZShlcmFzW2ldLm5hcnJvdykpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZXJhc1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWl4ZWRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl9lcmFzTmFtZVJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbmFtZVBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX2VyYXNBYmJyUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBhYmJyUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fZXJhc05hcnJvd1JlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICdeKCcgKyBuYXJyb3dQaWVjZXMuam9pbignfCcpICsgJyknLFxuICAgICAgICAgICAgJ2knXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydnZycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndlZWtZZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ0dHJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNvV2Vla1llYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4odG9rZW4sIGdldHRlcikge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbigwLCBbdG9rZW4sIHRva2VuLmxlbmd0aF0sIDAsIGdldHRlcik7XG4gICAgfVxuXG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZycsICd3ZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2dnJywgJ3dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignR0dHRycsICdpc29XZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0dHJywgJ2lzb1dlZWtZZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3dlZWtZZWFyJywgJ2dnJyk7XG4gICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrWWVhcicsICdHRycpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnd2Vla1llYXInLCAxKTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWtZZWFyJywgMSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdHJywgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2cnLCBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignR0cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignZ2cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignR0dHRycsIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdnZ2dnJywgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHR0dHJywgbWF0Y2gxdG82LCBtYXRjaDYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnZ2dnJywgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oXG4gICAgICAgIFsnZ2dnZycsICdnZ2dnZycsICdHR0dHJywgJ0dHR0dHJ10sXG4gICAgICAgIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICAgICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMildID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICB9XG4gICAgKTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZ2cnLCAnR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW5dID0gaG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXIoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGdldFNldFdlZWtZZWFySGVscGVyLmNhbGwoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICB0aGlzLndlZWsoKSxcbiAgICAgICAgICAgIHRoaXMud2Vla2RheSgpLFxuICAgICAgICAgICAgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93LFxuICAgICAgICAgICAgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG95XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPV2Vla1llYXIoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGdldFNldFdlZWtZZWFySGVscGVyLmNhbGwoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICB0aGlzLmlzb1dlZWsoKSxcbiAgICAgICAgICAgIHRoaXMuaXNvV2Vla2RheSgpLFxuICAgICAgICAgICAgMSxcbiAgICAgICAgICAgIDRcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJU09XZWVrc0luWWVhcigpIHtcbiAgICAgICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMueWVhcigpLCAxLCA0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJU09XZWVrc0luSVNPV2Vla1llYXIoKSB7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLmlzb1dlZWtZZWFyKCksIDEsIDQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFdlZWtzSW5ZZWFyKCkge1xuICAgICAgICB2YXIgd2Vla0luZm8gPSB0aGlzLmxvY2FsZURhdGEoKS5fd2VlaztcbiAgICAgICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMueWVhcigpLCB3ZWVrSW5mby5kb3csIHdlZWtJbmZvLmRveSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2Vla3NJbldlZWtZZWFyKCkge1xuICAgICAgICB2YXIgd2Vla0luZm8gPSB0aGlzLmxvY2FsZURhdGEoKS5fd2VlaztcbiAgICAgICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMud2Vla1llYXIoKSwgd2Vla0luZm8uZG93LCB3ZWVrSW5mby5kb3kpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWtZZWFySGVscGVyKGlucHV0LCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICB2YXIgd2Vla3NUYXJnZXQ7XG4gICAgICAgIGlmIChpbnB1dCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gd2Vla09mWWVhcih0aGlzLCBkb3csIGRveSkueWVhcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdlZWtzVGFyZ2V0ID0gd2Vla3NJblllYXIoaW5wdXQsIGRvdywgZG95KTtcbiAgICAgICAgICAgIGlmICh3ZWVrID4gd2Vla3NUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICB3ZWVrID0gd2Vla3NUYXJnZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2V0V2Vla0FsbC5jYWxsKHRoaXMsIGlucHV0LCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRXZWVrQWxsKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICB2YXIgZGF5T2ZZZWFyRGF0YSA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpLFxuICAgICAgICAgICAgZGF0ZSA9IGNyZWF0ZVVUQ0RhdGUoZGF5T2ZZZWFyRGF0YS55ZWFyLCAwLCBkYXlPZlllYXJEYXRhLmRheU9mWWVhcik7XG5cbiAgICAgICAgdGhpcy55ZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSk7XG4gICAgICAgIHRoaXMubW9udGgoZGF0ZS5nZXRVVENNb250aCgpKTtcbiAgICAgICAgdGhpcy5kYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1EnLCAwLCAnUW8nLCAncXVhcnRlcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdxdWFydGVyJywgJ1EnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3F1YXJ0ZXInLCA3KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1EnLCBtYXRjaDEpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1EnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9ICh0b0ludChpbnB1dCkgLSAxKSAqIDM7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRRdWFydGVyKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsXG4gICAgICAgICAgICA/IE1hdGguY2VpbCgodGhpcy5tb250aCgpICsgMSkgLyAzKVxuICAgICAgICAgICAgOiB0aGlzLm1vbnRoKChpbnB1dCAtIDEpICogMyArICh0aGlzLm1vbnRoKCkgJSAzKSk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0QnLCBbJ0REJywgMl0sICdEbycsICdkYXRlJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RhdGUnLCAnRCcpO1xuXG4gICAgLy8gUFJJT1JJVFlcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2RhdGUnLCA5KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0QnLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0REJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgLy8gVE9ETzogUmVtb3ZlIFwib3JkaW5hbFBhcnNlXCIgZmFsbGJhY2sgaW4gbmV4dCBtYWpvciByZWxlYXNlLlxuICAgICAgICByZXR1cm4gaXNTdHJpY3RcbiAgICAgICAgICAgID8gbG9jYWxlLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlIHx8IGxvY2FsZS5fb3JkaW5hbFBhcnNlXG4gICAgICAgICAgICA6IGxvY2FsZS5fZGF5T2ZNb250aE9yZGluYWxQYXJzZUxlbmllbnQ7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnRCcsICdERCddLCBEQVRFKTtcbiAgICBhZGRQYXJzZVRva2VuKCdEbycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbREFURV0gPSB0b0ludChpbnB1dC5tYXRjaChtYXRjaDF0bzIpWzBdKTtcbiAgICB9KTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXREYXlPZk1vbnRoID0gbWFrZUdldFNldCgnRGF0ZScsIHRydWUpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0RERCcsIFsnRERERCcsIDNdLCAnREREbycsICdkYXlPZlllYXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF5T2ZZZWFyJywgJ0RERCcpO1xuXG4gICAgLy8gUFJJT1JJVFlcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2RheU9mWWVhcicsIDQpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignREREJywgbWF0Y2gxdG8zKTtcbiAgICBhZGRSZWdleFRva2VuKCdEREREJywgbWF0Y2gzKTtcbiAgICBhZGRQYXJzZVRva2VuKFsnREREJywgJ0REREQnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0RGF5T2ZZZWFyKGlucHV0KSB7XG4gICAgICAgIHZhciBkYXlPZlllYXIgPVxuICAgICAgICAgICAgTWF0aC5yb3VuZChcbiAgICAgICAgICAgICAgICAodGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpIC0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ3llYXInKSkgLyA4NjRlNVxuICAgICAgICAgICAgKSArIDE7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gZGF5T2ZZZWFyIDogdGhpcy5hZGQoaW5wdXQgLSBkYXlPZlllYXIsICdkJyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ20nLCBbJ21tJywgMl0sIDAsICdtaW51dGUnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnbWludXRlJywgJ20nKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ21pbnV0ZScsIDE0KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ20nLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ21tJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydtJywgJ21tJ10sIE1JTlVURSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0TWludXRlID0gbWFrZUdldFNldCgnTWludXRlcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdzJywgWydzcycsIDJdLCAwLCAnc2Vjb25kJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3NlY29uZCcsICdzJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdzZWNvbmQnLCAxNSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdzJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdzcycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRQYXJzZVRva2VuKFsncycsICdzcyddLCBTRUNPTkQpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldFNlY29uZCA9IG1ha2VHZXRTZXQoJ1NlY29uZHMnLCBmYWxzZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignUycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIH5+KHRoaXMubWlsbGlzZWNvbmQoKSAvIDEwMCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIH5+KHRoaXMubWlsbGlzZWNvbmQoKSAvIDEwKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTJywgM10sIDAsICdtaWxsaXNlY29uZCcpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTUycsIDRdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTJywgNV0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTUycsIDZdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTUycsIDddLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1NTJywgOF0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1NTUycsIDldLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDAwO1xuICAgIH0pO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtaWxsaXNlY29uZCcsICdtcycpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnbWlsbGlzZWNvbmQnLCAxNik7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdTJywgbWF0Y2gxdG8zLCBtYXRjaDEpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1NTJywgbWF0Y2gxdG8zLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1NTUycsIG1hdGNoMXRvMywgbWF0Y2gzKTtcblxuICAgIHZhciB0b2tlbiwgZ2V0U2V0TWlsbGlzZWNvbmQ7XG4gICAgZm9yICh0b2tlbiA9ICdTU1NTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgICAgICBhZGRSZWdleFRva2VuKHRva2VuLCBtYXRjaFVuc2lnbmVkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU1zKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNSUxMSVNFQ09ORF0gPSB0b0ludCgoJzAuJyArIGlucHV0KSAqIDEwMDApO1xuICAgIH1cblxuICAgIGZvciAodG9rZW4gPSAnUyc7IHRva2VuLmxlbmd0aCA8PSA5OyB0b2tlbiArPSAnUycpIHtcbiAgICAgICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgcGFyc2VNcyk7XG4gICAgfVxuXG4gICAgZ2V0U2V0TWlsbGlzZWNvbmQgPSBtYWtlR2V0U2V0KCdNaWxsaXNlY29uZHMnLCBmYWxzZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbigneicsIDAsIDAsICd6b25lQWJicicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd6eicsIDAsIDAsICd6b25lTmFtZScpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0Wm9uZUFiYnIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdVVEMnIDogJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Wm9uZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdDb29yZGluYXRlZCBVbml2ZXJzYWwgVGltZScgOiAnJztcbiAgICB9XG5cbiAgICB2YXIgcHJvdG8gPSBNb21lbnQucHJvdG90eXBlO1xuXG4gICAgcHJvdG8uYWRkID0gYWRkO1xuICAgIHByb3RvLmNhbGVuZGFyID0gY2FsZW5kYXIkMTtcbiAgICBwcm90by5jbG9uZSA9IGNsb25lO1xuICAgIHByb3RvLmRpZmYgPSBkaWZmO1xuICAgIHByb3RvLmVuZE9mID0gZW5kT2Y7XG4gICAgcHJvdG8uZm9ybWF0ID0gZm9ybWF0O1xuICAgIHByb3RvLmZyb20gPSBmcm9tO1xuICAgIHByb3RvLmZyb21Ob3cgPSBmcm9tTm93O1xuICAgIHByb3RvLnRvID0gdG87XG4gICAgcHJvdG8udG9Ob3cgPSB0b05vdztcbiAgICBwcm90by5nZXQgPSBzdHJpbmdHZXQ7XG4gICAgcHJvdG8uaW52YWxpZEF0ID0gaW52YWxpZEF0O1xuICAgIHByb3RvLmlzQWZ0ZXIgPSBpc0FmdGVyO1xuICAgIHByb3RvLmlzQmVmb3JlID0gaXNCZWZvcmU7XG4gICAgcHJvdG8uaXNCZXR3ZWVuID0gaXNCZXR3ZWVuO1xuICAgIHByb3RvLmlzU2FtZSA9IGlzU2FtZTtcbiAgICBwcm90by5pc1NhbWVPckFmdGVyID0gaXNTYW1lT3JBZnRlcjtcbiAgICBwcm90by5pc1NhbWVPckJlZm9yZSA9IGlzU2FtZU9yQmVmb3JlO1xuICAgIHByb3RvLmlzVmFsaWQgPSBpc1ZhbGlkJDI7XG4gICAgcHJvdG8ubGFuZyA9IGxhbmc7XG4gICAgcHJvdG8ubG9jYWxlID0gbG9jYWxlO1xuICAgIHByb3RvLmxvY2FsZURhdGEgPSBsb2NhbGVEYXRhO1xuICAgIHByb3RvLm1heCA9IHByb3RvdHlwZU1heDtcbiAgICBwcm90by5taW4gPSBwcm90b3R5cGVNaW47XG4gICAgcHJvdG8ucGFyc2luZ0ZsYWdzID0gcGFyc2luZ0ZsYWdzO1xuICAgIHByb3RvLnNldCA9IHN0cmluZ1NldDtcbiAgICBwcm90by5zdGFydE9mID0gc3RhcnRPZjtcbiAgICBwcm90by5zdWJ0cmFjdCA9IHN1YnRyYWN0O1xuICAgIHByb3RvLnRvQXJyYXkgPSB0b0FycmF5O1xuICAgIHByb3RvLnRvT2JqZWN0ID0gdG9PYmplY3Q7XG4gICAgcHJvdG8udG9EYXRlID0gdG9EYXRlO1xuICAgIHByb3RvLnRvSVNPU3RyaW5nID0gdG9JU09TdHJpbmc7XG4gICAgcHJvdG8uaW5zcGVjdCA9IGluc3BlY3Q7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5mb3IgIT0gbnVsbCkge1xuICAgICAgICBwcm90b1tTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnTW9tZW50PCcgKyB0aGlzLmZvcm1hdCgpICsgJz4nO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBwcm90by50b0pTT04gPSB0b0pTT047XG4gICAgcHJvdG8udG9TdHJpbmcgPSB0b1N0cmluZztcbiAgICBwcm90by51bml4ID0gdW5peDtcbiAgICBwcm90by52YWx1ZU9mID0gdmFsdWVPZjtcbiAgICBwcm90by5jcmVhdGlvbkRhdGEgPSBjcmVhdGlvbkRhdGE7XG4gICAgcHJvdG8uZXJhTmFtZSA9IGdldEVyYU5hbWU7XG4gICAgcHJvdG8uZXJhTmFycm93ID0gZ2V0RXJhTmFycm93O1xuICAgIHByb3RvLmVyYUFiYnIgPSBnZXRFcmFBYmJyO1xuICAgIHByb3RvLmVyYVllYXIgPSBnZXRFcmFZZWFyO1xuICAgIHByb3RvLnllYXIgPSBnZXRTZXRZZWFyO1xuICAgIHByb3RvLmlzTGVhcFllYXIgPSBnZXRJc0xlYXBZZWFyO1xuICAgIHByb3RvLndlZWtZZWFyID0gZ2V0U2V0V2Vla1llYXI7XG4gICAgcHJvdG8uaXNvV2Vla1llYXIgPSBnZXRTZXRJU09XZWVrWWVhcjtcbiAgICBwcm90by5xdWFydGVyID0gcHJvdG8ucXVhcnRlcnMgPSBnZXRTZXRRdWFydGVyO1xuICAgIHByb3RvLm1vbnRoID0gZ2V0U2V0TW9udGg7XG4gICAgcHJvdG8uZGF5c0luTW9udGggPSBnZXREYXlzSW5Nb250aDtcbiAgICBwcm90by53ZWVrID0gcHJvdG8ud2Vla3MgPSBnZXRTZXRXZWVrO1xuICAgIHByb3RvLmlzb1dlZWsgPSBwcm90by5pc29XZWVrcyA9IGdldFNldElTT1dlZWs7XG4gICAgcHJvdG8ud2Vla3NJblllYXIgPSBnZXRXZWVrc0luWWVhcjtcbiAgICBwcm90by53ZWVrc0luV2Vla1llYXIgPSBnZXRXZWVrc0luV2Vla1llYXI7XG4gICAgcHJvdG8uaXNvV2Vla3NJblllYXIgPSBnZXRJU09XZWVrc0luWWVhcjtcbiAgICBwcm90by5pc29XZWVrc0luSVNPV2Vla1llYXIgPSBnZXRJU09XZWVrc0luSVNPV2Vla1llYXI7XG4gICAgcHJvdG8uZGF0ZSA9IGdldFNldERheU9mTW9udGg7XG4gICAgcHJvdG8uZGF5ID0gcHJvdG8uZGF5cyA9IGdldFNldERheU9mV2VlaztcbiAgICBwcm90by53ZWVrZGF5ID0gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrO1xuICAgIHByb3RvLmlzb1dlZWtkYXkgPSBnZXRTZXRJU09EYXlPZldlZWs7XG4gICAgcHJvdG8uZGF5T2ZZZWFyID0gZ2V0U2V0RGF5T2ZZZWFyO1xuICAgIHByb3RvLmhvdXIgPSBwcm90by5ob3VycyA9IGdldFNldEhvdXI7XG4gICAgcHJvdG8ubWludXRlID0gcHJvdG8ubWludXRlcyA9IGdldFNldE1pbnV0ZTtcbiAgICBwcm90by5zZWNvbmQgPSBwcm90by5zZWNvbmRzID0gZ2V0U2V0U2Vjb25kO1xuICAgIHByb3RvLm1pbGxpc2Vjb25kID0gcHJvdG8ubWlsbGlzZWNvbmRzID0gZ2V0U2V0TWlsbGlzZWNvbmQ7XG4gICAgcHJvdG8udXRjT2Zmc2V0ID0gZ2V0U2V0T2Zmc2V0O1xuICAgIHByb3RvLnV0YyA9IHNldE9mZnNldFRvVVRDO1xuICAgIHByb3RvLmxvY2FsID0gc2V0T2Zmc2V0VG9Mb2NhbDtcbiAgICBwcm90by5wYXJzZVpvbmUgPSBzZXRPZmZzZXRUb1BhcnNlZE9mZnNldDtcbiAgICBwcm90by5oYXNBbGlnbmVkSG91ck9mZnNldCA9IGhhc0FsaWduZWRIb3VyT2Zmc2V0O1xuICAgIHByb3RvLmlzRFNUID0gaXNEYXlsaWdodFNhdmluZ1RpbWU7XG4gICAgcHJvdG8uaXNMb2NhbCA9IGlzTG9jYWw7XG4gICAgcHJvdG8uaXNVdGNPZmZzZXQgPSBpc1V0Y09mZnNldDtcbiAgICBwcm90by5pc1V0YyA9IGlzVXRjO1xuICAgIHByb3RvLmlzVVRDID0gaXNVdGM7XG4gICAgcHJvdG8uem9uZUFiYnIgPSBnZXRab25lQWJicjtcbiAgICBwcm90by56b25lTmFtZSA9IGdldFpvbmVOYW1lO1xuICAgIHByb3RvLmRhdGVzID0gZGVwcmVjYXRlKFxuICAgICAgICAnZGF0ZXMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIGRhdGUgaW5zdGVhZC4nLFxuICAgICAgICBnZXRTZXREYXlPZk1vbnRoXG4gICAgKTtcbiAgICBwcm90by5tb250aHMgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb250aHMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbnRoIGluc3RlYWQnLFxuICAgICAgICBnZXRTZXRNb250aFxuICAgICk7XG4gICAgcHJvdG8ueWVhcnMgPSBkZXByZWNhdGUoXG4gICAgICAgICd5ZWFycyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgeWVhciBpbnN0ZWFkJyxcbiAgICAgICAgZ2V0U2V0WWVhclxuICAgICk7XG4gICAgcHJvdG8uem9uZSA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudCgpLnpvbmUgaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudCgpLnV0Y09mZnNldCBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL3pvbmUvJyxcbiAgICAgICAgZ2V0U2V0Wm9uZVxuICAgICk7XG4gICAgcHJvdG8uaXNEU1RTaGlmdGVkID0gZGVwcmVjYXRlKFxuICAgICAgICAnaXNEU1RTaGlmdGVkIGlzIGRlcHJlY2F0ZWQuIFNlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2RzdC1zaGlmdGVkLyBmb3IgbW9yZSBpbmZvcm1hdGlvbicsXG4gICAgICAgIGlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZFxuICAgICk7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVVbml4KGlucHV0KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbChpbnB1dCAqIDEwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUluWm9uZSgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cykucGFyc2Vab25lKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlUGFyc2VQb3N0Rm9ybWF0KHN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH1cblxuICAgIHZhciBwcm90byQxID0gTG9jYWxlLnByb3RvdHlwZTtcblxuICAgIHByb3RvJDEuY2FsZW5kYXIgPSBjYWxlbmRhcjtcbiAgICBwcm90byQxLmxvbmdEYXRlRm9ybWF0ID0gbG9uZ0RhdGVGb3JtYXQ7XG4gICAgcHJvdG8kMS5pbnZhbGlkRGF0ZSA9IGludmFsaWREYXRlO1xuICAgIHByb3RvJDEub3JkaW5hbCA9IG9yZGluYWw7XG4gICAgcHJvdG8kMS5wcmVwYXJzZSA9IHByZVBhcnNlUG9zdEZvcm1hdDtcbiAgICBwcm90byQxLnBvc3Rmb3JtYXQgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG4gICAgcHJvdG8kMS5yZWxhdGl2ZVRpbWUgPSByZWxhdGl2ZVRpbWU7XG4gICAgcHJvdG8kMS5wYXN0RnV0dXJlID0gcGFzdEZ1dHVyZTtcbiAgICBwcm90byQxLnNldCA9IHNldDtcbiAgICBwcm90byQxLmVyYXMgPSBsb2NhbGVFcmFzO1xuICAgIHByb3RvJDEuZXJhc1BhcnNlID0gbG9jYWxlRXJhc1BhcnNlO1xuICAgIHByb3RvJDEuZXJhc0NvbnZlcnRZZWFyID0gbG9jYWxlRXJhc0NvbnZlcnRZZWFyO1xuICAgIHByb3RvJDEuZXJhc0FiYnJSZWdleCA9IGVyYXNBYmJyUmVnZXg7XG4gICAgcHJvdG8kMS5lcmFzTmFtZVJlZ2V4ID0gZXJhc05hbWVSZWdleDtcbiAgICBwcm90byQxLmVyYXNOYXJyb3dSZWdleCA9IGVyYXNOYXJyb3dSZWdleDtcblxuICAgIHByb3RvJDEubW9udGhzID0gbG9jYWxlTW9udGhzO1xuICAgIHByb3RvJDEubW9udGhzU2hvcnQgPSBsb2NhbGVNb250aHNTaG9ydDtcbiAgICBwcm90byQxLm1vbnRoc1BhcnNlID0gbG9jYWxlTW9udGhzUGFyc2U7XG4gICAgcHJvdG8kMS5tb250aHNSZWdleCA9IG1vbnRoc1JlZ2V4O1xuICAgIHByb3RvJDEubW9udGhzU2hvcnRSZWdleCA9IG1vbnRoc1Nob3J0UmVnZXg7XG4gICAgcHJvdG8kMS53ZWVrID0gbG9jYWxlV2VlaztcbiAgICBwcm90byQxLmZpcnN0RGF5T2ZZZWFyID0gbG9jYWxlRmlyc3REYXlPZlllYXI7XG4gICAgcHJvdG8kMS5maXJzdERheU9mV2VlayA9IGxvY2FsZUZpcnN0RGF5T2ZXZWVrO1xuXG4gICAgcHJvdG8kMS53ZWVrZGF5cyA9IGxvY2FsZVdlZWtkYXlzO1xuICAgIHByb3RvJDEud2Vla2RheXNNaW4gPSBsb2NhbGVXZWVrZGF5c01pbjtcbiAgICBwcm90byQxLndlZWtkYXlzU2hvcnQgPSBsb2NhbGVXZWVrZGF5c1Nob3J0O1xuICAgIHByb3RvJDEud2Vla2RheXNQYXJzZSA9IGxvY2FsZVdlZWtkYXlzUGFyc2U7XG5cbiAgICBwcm90byQxLndlZWtkYXlzUmVnZXggPSB3ZWVrZGF5c1JlZ2V4O1xuICAgIHByb3RvJDEud2Vla2RheXNTaG9ydFJlZ2V4ID0gd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgIHByb3RvJDEud2Vla2RheXNNaW5SZWdleCA9IHdlZWtkYXlzTWluUmVnZXg7XG5cbiAgICBwcm90byQxLmlzUE0gPSBsb2NhbGVJc1BNO1xuICAgIHByb3RvJDEubWVyaWRpZW0gPSBsb2NhbGVNZXJpZGllbTtcblxuICAgIGZ1bmN0aW9uIGdldCQxKGZvcm1hdCwgaW5kZXgsIGZpZWxkLCBzZXR0ZXIpIHtcbiAgICAgICAgdmFyIGxvY2FsZSA9IGdldExvY2FsZSgpLFxuICAgICAgICAgICAgdXRjID0gY3JlYXRlVVRDKCkuc2V0KHNldHRlciwgaW5kZXgpO1xuICAgICAgICByZXR1cm4gbG9jYWxlW2ZpZWxkXSh1dGMsIGZvcm1hdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdE1vbnRoc0ltcGwoZm9ybWF0LCBpbmRleCwgZmllbGQpIHtcbiAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuXG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0JDEoZm9ybWF0LCBpbmRleCwgZmllbGQsICdtb250aCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBvdXQgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIG91dFtpXSA9IGdldCQxKGZvcm1hdCwgaSwgZmllbGQsICdtb250aCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgLy8gKClcbiAgICAvLyAoNSlcbiAgICAvLyAoZm10LCA1KVxuICAgIC8vIChmbXQpXG4gICAgLy8gKHRydWUpXG4gICAgLy8gKHRydWUsIDUpXG4gICAgLy8gKHRydWUsIGZtdCwgNSlcbiAgICAvLyAodHJ1ZSwgZm10KVxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xuICAgICAgICBpZiAodHlwZW9mIGxvY2FsZVNvcnRlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9ybWF0ID0gbG9jYWxlU29ydGVkO1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBsb2NhbGVTb3J0ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2NhbGUgPSBnZXRMb2NhbGUoKSxcbiAgICAgICAgICAgIHNoaWZ0ID0gbG9jYWxlU29ydGVkID8gbG9jYWxlLl93ZWVrLmRvdyA6IDAsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgb3V0ID0gW107XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQkMShmb3JtYXQsIChpbmRleCArIHNoaWZ0KSAlIDcsIGZpZWxkLCAnZGF5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBvdXRbaV0gPSBnZXQkMShmb3JtYXQsIChpICsgc2hpZnQpICUgNywgZmllbGQsICdkYXknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RNb250aHMoZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdE1vbnRoc0ltcGwoZm9ybWF0LCBpbmRleCwgJ21vbnRocycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RNb250aHNTaG9ydChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzU2hvcnQnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0V2Vla2RheXMobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzU2hvcnQobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzU2hvcnQnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0V2Vla2RheXNNaW4obG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzTWluJyk7XG4gICAgfVxuXG4gICAgZ2V0U2V0R2xvYmFsTG9jYWxlKCdlbicsIHtcbiAgICAgICAgZXJhczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNpbmNlOiAnMDAwMS0wMS0wMScsXG4gICAgICAgICAgICAgICAgdW50aWw6ICtJbmZpbml0eSxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDEsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0Fubm8gRG9taW5pJyxcbiAgICAgICAgICAgICAgICBuYXJyb3c6ICdBRCcsXG4gICAgICAgICAgICAgICAgYWJicjogJ0FEJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2luY2U6ICcwMDAwLTEyLTMxJyxcbiAgICAgICAgICAgICAgICB1bnRpbDogLUluZmluaXR5LFxuICAgICAgICAgICAgICAgIG9mZnNldDogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnQmVmb3JlIENocmlzdCcsXG4gICAgICAgICAgICAgICAgbmFycm93OiAnQkMnLFxuICAgICAgICAgICAgICAgIGFiYnI6ICdCQycsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0odGh8c3R8bmR8cmQpLyxcbiAgICAgICAgb3JkaW5hbDogZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICAgICAgdmFyIGIgPSBudW1iZXIgJSAxMCxcbiAgICAgICAgICAgICAgICBvdXRwdXQgPVxuICAgICAgICAgICAgICAgICAgICB0b0ludCgobnVtYmVyICUgMTAwKSAvIDEwKSA9PT0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAndGgnXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGIgPT09IDFcbiAgICAgICAgICAgICAgICAgICAgICAgID8gJ3N0J1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBiID09PSAyXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICduZCdcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYiA9PT0gM1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAncmQnXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICd0aCc7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuXG4gICAgaG9va3MubGFuZyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudC5sYW5nIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlIGluc3RlYWQuJyxcbiAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlXG4gICAgKTtcbiAgICBob29rcy5sYW5nRGF0YSA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudC5sYW5nRGF0YSBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZURhdGEgaW5zdGVhZC4nLFxuICAgICAgICBnZXRMb2NhbGVcbiAgICApO1xuXG4gICAgdmFyIG1hdGhBYnMgPSBNYXRoLmFicztcblxuICAgIGZ1bmN0aW9uIGFicygpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9IG1hdGhBYnModGhpcy5fbWlsbGlzZWNvbmRzKTtcbiAgICAgICAgdGhpcy5fZGF5cyA9IG1hdGhBYnModGhpcy5fZGF5cyk7XG4gICAgICAgIHRoaXMuX21vbnRocyA9IG1hdGhBYnModGhpcy5fbW9udGhzKTtcblxuICAgICAgICBkYXRhLm1pbGxpc2Vjb25kcyA9IG1hdGhBYnMoZGF0YS5taWxsaXNlY29uZHMpO1xuICAgICAgICBkYXRhLnNlY29uZHMgPSBtYXRoQWJzKGRhdGEuc2Vjb25kcyk7XG4gICAgICAgIGRhdGEubWludXRlcyA9IG1hdGhBYnMoZGF0YS5taW51dGVzKTtcbiAgICAgICAgZGF0YS5ob3VycyA9IG1hdGhBYnMoZGF0YS5ob3Vycyk7XG4gICAgICAgIGRhdGEubW9udGhzID0gbWF0aEFicyhkYXRhLm1vbnRocyk7XG4gICAgICAgIGRhdGEueWVhcnMgPSBtYXRoQWJzKGRhdGEueWVhcnMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFN1YnRyYWN0JDEoZHVyYXRpb24sIGlucHV0LCB2YWx1ZSwgZGlyZWN0aW9uKSB7XG4gICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZUR1cmF0aW9uKGlucHV0LCB2YWx1ZSk7XG5cbiAgICAgICAgZHVyYXRpb24uX21pbGxpc2Vjb25kcyArPSBkaXJlY3Rpb24gKiBvdGhlci5fbWlsbGlzZWNvbmRzO1xuICAgICAgICBkdXJhdGlvbi5fZGF5cyArPSBkaXJlY3Rpb24gKiBvdGhlci5fZGF5cztcbiAgICAgICAgZHVyYXRpb24uX21vbnRocyArPSBkaXJlY3Rpb24gKiBvdGhlci5fbW9udGhzO1xuXG4gICAgICAgIHJldHVybiBkdXJhdGlvbi5fYnViYmxlKCk7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgYWRkKDEsICdzJykgb3IgYWRkKGR1cmF0aW9uKVxuICAgIGZ1bmN0aW9uIGFkZCQxKGlucHV0LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYWRkU3VidHJhY3QkMSh0aGlzLCBpbnB1dCwgdmFsdWUsIDEpO1xuICAgIH1cblxuICAgIC8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIHN1YnRyYWN0KDEsICdzJykgb3Igc3VidHJhY3QoZHVyYXRpb24pXG4gICAgZnVuY3Rpb24gc3VidHJhY3QkMShpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFkZFN1YnRyYWN0JDEodGhpcywgaW5wdXQsIHZhbHVlLCAtMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzQ2VpbChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWJibGUoKSB7XG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICBkYXlzID0gdGhpcy5fZGF5cyxcbiAgICAgICAgICAgIG1vbnRocyA9IHRoaXMuX21vbnRocyxcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9kYXRhLFxuICAgICAgICAgICAgc2Vjb25kcyxcbiAgICAgICAgICAgIG1pbnV0ZXMsXG4gICAgICAgICAgICBob3VycyxcbiAgICAgICAgICAgIHllYXJzLFxuICAgICAgICAgICAgbW9udGhzRnJvbURheXM7XG5cbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIG1peCBvZiBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgdmFsdWVzLCBidWJibGUgZG93biBmaXJzdFxuICAgICAgICAvLyBjaGVjazogaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzIxNjZcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgIShcbiAgICAgICAgICAgICAgICAobWlsbGlzZWNvbmRzID49IDAgJiYgZGF5cyA+PSAwICYmIG1vbnRocyA+PSAwKSB8fFxuICAgICAgICAgICAgICAgIChtaWxsaXNlY29uZHMgPD0gMCAmJiBkYXlzIDw9IDAgJiYgbW9udGhzIDw9IDApXG4gICAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgICAgbWlsbGlzZWNvbmRzICs9IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRocykgKyBkYXlzKSAqIDg2NGU1O1xuICAgICAgICAgICAgZGF5cyA9IDA7XG4gICAgICAgICAgICBtb250aHMgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBjb2RlIGJ1YmJsZXMgdXAgdmFsdWVzLCBzZWUgdGhlIHRlc3RzIGZvclxuICAgICAgICAvLyBleGFtcGxlcyBvZiB3aGF0IHRoYXQgbWVhbnMuXG4gICAgICAgIGRhdGEubWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzICUgMTAwMDtcblxuICAgICAgICBzZWNvbmRzID0gYWJzRmxvb3IobWlsbGlzZWNvbmRzIC8gMTAwMCk7XG4gICAgICAgIGRhdGEuc2Vjb25kcyA9IHNlY29uZHMgJSA2MDtcblxuICAgICAgICBtaW51dGVzID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgZGF0YS5taW51dGVzID0gbWludXRlcyAlIDYwO1xuXG4gICAgICAgIGhvdXJzID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICAgICAgZGF0YS5ob3VycyA9IGhvdXJzICUgMjQ7XG5cbiAgICAgICAgZGF5cyArPSBhYnNGbG9vcihob3VycyAvIDI0KTtcblxuICAgICAgICAvLyBjb252ZXJ0IGRheXMgdG8gbW9udGhzXG4gICAgICAgIG1vbnRoc0Zyb21EYXlzID0gYWJzRmxvb3IoZGF5c1RvTW9udGhzKGRheXMpKTtcbiAgICAgICAgbW9udGhzICs9IG1vbnRoc0Zyb21EYXlzO1xuICAgICAgICBkYXlzIC09IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRoc0Zyb21EYXlzKSk7XG5cbiAgICAgICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgICAgICB5ZWFycyA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICAgICAgbW9udGhzICU9IDEyO1xuXG4gICAgICAgIGRhdGEuZGF5cyA9IGRheXM7XG4gICAgICAgIGRhdGEubW9udGhzID0gbW9udGhzO1xuICAgICAgICBkYXRhLnllYXJzID0geWVhcnM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5c1RvTW9udGhzKGRheXMpIHtcbiAgICAgICAgLy8gNDAwIHllYXJzIGhhdmUgMTQ2MDk3IGRheXMgKHRha2luZyBpbnRvIGFjY291bnQgbGVhcCB5ZWFyIHJ1bGVzKVxuICAgICAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxMiBtb250aHMgPT09IDQ4MDBcbiAgICAgICAgcmV0dXJuIChkYXlzICogNDgwMCkgLyAxNDYwOTc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhzVG9EYXlzKG1vbnRocykge1xuICAgICAgICAvLyB0aGUgcmV2ZXJzZSBvZiBkYXlzVG9Nb250aHNcbiAgICAgICAgcmV0dXJuIChtb250aHMgKiAxNDYwOTcpIC8gNDgwMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcyh1bml0cykge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXlzLFxuICAgICAgICAgICAgbW9udGhzLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzO1xuXG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuXG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21vbnRoJyB8fCB1bml0cyA9PT0gJ3F1YXJ0ZXInIHx8IHVuaXRzID09PSAneWVhcicpIHtcbiAgICAgICAgICAgIGRheXMgPSB0aGlzLl9kYXlzICsgbWlsbGlzZWNvbmRzIC8gODY0ZTU7XG4gICAgICAgICAgICBtb250aHMgPSB0aGlzLl9tb250aHMgKyBkYXlzVG9Nb250aHMoZGF5cyk7XG4gICAgICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9udGhzO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9udGhzIC8gMztcbiAgICAgICAgICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vbnRocyAvIDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaGFuZGxlIG1pbGxpc2Vjb25kcyBzZXBhcmF0ZWx5IGJlY2F1c2Ugb2YgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgKGlzc3VlICMxODY3KVxuICAgICAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMgKyBNYXRoLnJvdW5kKG1vbnRoc1RvRGF5cyh0aGlzLl9tb250aHMpKTtcbiAgICAgICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRheXMgLyA3ICsgbWlsbGlzZWNvbmRzIC8gNjA0OGU1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXlzICsgbWlsbGlzZWNvbmRzIC8gODY0ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXlzICogMjQgKyBtaWxsaXNlY29uZHMgLyAzNmU1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXlzICogMTQ0MCArIG1pbGxpc2Vjb25kcyAvIDZlNDtcbiAgICAgICAgICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF5cyAqIDg2NDAwICsgbWlsbGlzZWNvbmRzIC8gMTAwMDtcbiAgICAgICAgICAgICAgICAvLyBNYXRoLmZsb29yIHByZXZlbnRzIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIGhlcmVcbiAgICAgICAgICAgICAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKGRheXMgKiA4NjRlNSkgKyBtaWxsaXNlY29uZHM7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHVuaXQgJyArIHVuaXRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IFVzZSB0aGlzLmFzKCdtcycpP1xuICAgIGZ1bmN0aW9uIHZhbHVlT2YkMSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzICtcbiAgICAgICAgICAgIHRoaXMuX2RheXMgKiA4NjRlNSArXG4gICAgICAgICAgICAodGhpcy5fbW9udGhzICUgMTIpICogMjU5MmU2ICtcbiAgICAgICAgICAgIHRvSW50KHRoaXMuX21vbnRocyAvIDEyKSAqIDMxNTM2ZTZcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlQXMoYWxpYXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFzKGFsaWFzKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgYXNNaWxsaXNlY29uZHMgPSBtYWtlQXMoJ21zJyksXG4gICAgICAgIGFzU2Vjb25kcyA9IG1ha2VBcygncycpLFxuICAgICAgICBhc01pbnV0ZXMgPSBtYWtlQXMoJ20nKSxcbiAgICAgICAgYXNIb3VycyA9IG1ha2VBcygnaCcpLFxuICAgICAgICBhc0RheXMgPSBtYWtlQXMoJ2QnKSxcbiAgICAgICAgYXNXZWVrcyA9IG1ha2VBcygndycpLFxuICAgICAgICBhc01vbnRocyA9IG1ha2VBcygnTScpLFxuICAgICAgICBhc1F1YXJ0ZXJzID0gbWFrZUFzKCdRJyksXG4gICAgICAgIGFzWWVhcnMgPSBtYWtlQXMoJ3knKTtcblxuICAgIGZ1bmN0aW9uIGNsb25lJDEoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXQkMih1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpc1t1bml0cyArICdzJ10oKSA6IE5hTjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlR2V0dGVyKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2RhdGFbbmFtZV0gOiBOYU47XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIG1pbGxpc2Vjb25kcyA9IG1ha2VHZXR0ZXIoJ21pbGxpc2Vjb25kcycpLFxuICAgICAgICBzZWNvbmRzID0gbWFrZUdldHRlcignc2Vjb25kcycpLFxuICAgICAgICBtaW51dGVzID0gbWFrZUdldHRlcignbWludXRlcycpLFxuICAgICAgICBob3VycyA9IG1ha2VHZXR0ZXIoJ2hvdXJzJyksXG4gICAgICAgIGRheXMgPSBtYWtlR2V0dGVyKCdkYXlzJyksXG4gICAgICAgIG1vbnRocyA9IG1ha2VHZXR0ZXIoJ21vbnRocycpLFxuICAgICAgICB5ZWFycyA9IG1ha2VHZXR0ZXIoJ3llYXJzJyk7XG5cbiAgICBmdW5jdGlvbiB3ZWVrcygpIHtcbiAgICAgICAgcmV0dXJuIGFic0Zsb29yKHRoaXMuZGF5cygpIC8gNyk7XG4gICAgfVxuXG4gICAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZCxcbiAgICAgICAgdGhyZXNob2xkcyA9IHtcbiAgICAgICAgICAgIHNzOiA0NCwgLy8gYSBmZXcgc2Vjb25kcyB0byBzZWNvbmRzXG4gICAgICAgICAgICBzOiA0NSwgLy8gc2Vjb25kcyB0byBtaW51dGVcbiAgICAgICAgICAgIG06IDQ1LCAvLyBtaW51dGVzIHRvIGhvdXJcbiAgICAgICAgICAgIGg6IDIyLCAvLyBob3VycyB0byBkYXlcbiAgICAgICAgICAgIGQ6IDI2LCAvLyBkYXlzIHRvIG1vbnRoL3dlZWtcbiAgICAgICAgICAgIHc6IG51bGwsIC8vIHdlZWtzIHRvIG1vbnRoXG4gICAgICAgICAgICBNOiAxMSwgLy8gbW9udGhzIHRvIHllYXJcbiAgICAgICAgfTtcblxuICAgIC8vIGhlbHBlciBmdW5jdGlvbiBmb3IgbW9tZW50LmZuLmZyb20sIG1vbWVudC5mbi5mcm9tTm93LCBhbmQgbW9tZW50LmR1cmF0aW9uLmZuLmh1bWFuaXplXG4gICAgZnVuY3Rpb24gc3Vic3RpdHV0ZVRpbWVBZ28oc3RyaW5nLCBudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGlzRnV0dXJlLCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5yZWxhdGl2ZVRpbWUobnVtYmVyIHx8IDEsICEhd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVsYXRpdmVUaW1lJDEocG9zTmVnRHVyYXRpb24sIHdpdGhvdXRTdWZmaXgsIHRocmVzaG9sZHMsIGxvY2FsZSkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBjcmVhdGVEdXJhdGlvbihwb3NOZWdEdXJhdGlvbikuYWJzKCksXG4gICAgICAgICAgICBzZWNvbmRzID0gcm91bmQoZHVyYXRpb24uYXMoJ3MnKSksXG4gICAgICAgICAgICBtaW51dGVzID0gcm91bmQoZHVyYXRpb24uYXMoJ20nKSksXG4gICAgICAgICAgICBob3VycyA9IHJvdW5kKGR1cmF0aW9uLmFzKCdoJykpLFxuICAgICAgICAgICAgZGF5cyA9IHJvdW5kKGR1cmF0aW9uLmFzKCdkJykpLFxuICAgICAgICAgICAgbW9udGhzID0gcm91bmQoZHVyYXRpb24uYXMoJ00nKSksXG4gICAgICAgICAgICB3ZWVrcyA9IHJvdW5kKGR1cmF0aW9uLmFzKCd3JykpLFxuICAgICAgICAgICAgeWVhcnMgPSByb3VuZChkdXJhdGlvbi5hcygneScpKSxcbiAgICAgICAgICAgIGEgPVxuICAgICAgICAgICAgICAgIChzZWNvbmRzIDw9IHRocmVzaG9sZHMuc3MgJiYgWydzJywgc2Vjb25kc10pIHx8XG4gICAgICAgICAgICAgICAgKHNlY29uZHMgPCB0aHJlc2hvbGRzLnMgJiYgWydzcycsIHNlY29uZHNdKSB8fFxuICAgICAgICAgICAgICAgIChtaW51dGVzIDw9IDEgJiYgWydtJ10pIHx8XG4gICAgICAgICAgICAgICAgKG1pbnV0ZXMgPCB0aHJlc2hvbGRzLm0gJiYgWydtbScsIG1pbnV0ZXNdKSB8fFxuICAgICAgICAgICAgICAgIChob3VycyA8PSAxICYmIFsnaCddKSB8fFxuICAgICAgICAgICAgICAgIChob3VycyA8IHRocmVzaG9sZHMuaCAmJiBbJ2hoJywgaG91cnNdKSB8fFxuICAgICAgICAgICAgICAgIChkYXlzIDw9IDEgJiYgWydkJ10pIHx8XG4gICAgICAgICAgICAgICAgKGRheXMgPCB0aHJlc2hvbGRzLmQgJiYgWydkZCcsIGRheXNdKTtcblxuICAgICAgICBpZiAodGhyZXNob2xkcy53ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGEgPVxuICAgICAgICAgICAgICAgIGEgfHxcbiAgICAgICAgICAgICAgICAod2Vla3MgPD0gMSAmJiBbJ3cnXSkgfHxcbiAgICAgICAgICAgICAgICAod2Vla3MgPCB0aHJlc2hvbGRzLncgJiYgWyd3dycsIHdlZWtzXSk7XG4gICAgICAgIH1cbiAgICAgICAgYSA9IGEgfHxcbiAgICAgICAgICAgIChtb250aHMgPD0gMSAmJiBbJ00nXSkgfHxcbiAgICAgICAgICAgIChtb250aHMgPCB0aHJlc2hvbGRzLk0gJiYgWydNTScsIG1vbnRoc10pIHx8XG4gICAgICAgICAgICAoeWVhcnMgPD0gMSAmJiBbJ3knXSkgfHwgWyd5eScsIHllYXJzXTtcblxuICAgICAgICBhWzJdID0gd2l0aG91dFN1ZmZpeDtcbiAgICAgICAgYVszXSA9ICtwb3NOZWdEdXJhdGlvbiA+IDA7XG4gICAgICAgIGFbNF0gPSBsb2NhbGU7XG4gICAgICAgIHJldHVybiBzdWJzdGl0dXRlVGltZUFnby5hcHBseShudWxsLCBhKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gc2V0IHRoZSByb3VuZGluZyBmdW5jdGlvbiBmb3IgcmVsYXRpdmUgdGltZSBzdHJpbmdzXG4gICAgZnVuY3Rpb24gZ2V0U2V0UmVsYXRpdmVUaW1lUm91bmRpbmcocm91bmRpbmdGdW5jdGlvbikge1xuICAgICAgICBpZiAocm91bmRpbmdGdW5jdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcm91bmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByb3VuZGluZ0Z1bmN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByb3VuZCA9IHJvdW5kaW5nRnVuY3Rpb247XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCBhIHRocmVzaG9sZCBmb3IgcmVsYXRpdmUgdGltZSBzdHJpbmdzXG4gICAgZnVuY3Rpb24gZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkKHRocmVzaG9sZCwgbGltaXQpIHtcbiAgICAgICAgaWYgKHRocmVzaG9sZHNbdGhyZXNob2xkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aHJlc2hvbGRzW3RocmVzaG9sZF07XG4gICAgICAgIH1cbiAgICAgICAgdGhyZXNob2xkc1t0aHJlc2hvbGRdID0gbGltaXQ7XG4gICAgICAgIGlmICh0aHJlc2hvbGQgPT09ICdzJykge1xuICAgICAgICAgICAgdGhyZXNob2xkcy5zcyA9IGxpbWl0IC0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBodW1hbml6ZShhcmdXaXRoU3VmZml4LCBhcmdUaHJlc2hvbGRzKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHdpdGhTdWZmaXggPSBmYWxzZSxcbiAgICAgICAgICAgIHRoID0gdGhyZXNob2xkcyxcbiAgICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgICAgIG91dHB1dDtcblxuICAgICAgICBpZiAodHlwZW9mIGFyZ1dpdGhTdWZmaXggPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBhcmdUaHJlc2hvbGRzID0gYXJnV2l0aFN1ZmZpeDtcbiAgICAgICAgICAgIGFyZ1dpdGhTdWZmaXggPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGFyZ1dpdGhTdWZmaXggPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgd2l0aFN1ZmZpeCA9IGFyZ1dpdGhTdWZmaXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBhcmdUaHJlc2hvbGRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGggPSBPYmplY3QuYXNzaWduKHt9LCB0aHJlc2hvbGRzLCBhcmdUaHJlc2hvbGRzKTtcbiAgICAgICAgICAgIGlmIChhcmdUaHJlc2hvbGRzLnMgIT0gbnVsbCAmJiBhcmdUaHJlc2hvbGRzLnNzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aC5zcyA9IGFyZ1RocmVzaG9sZHMucyAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsb2NhbGUgPSB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgb3V0cHV0ID0gcmVsYXRpdmVUaW1lJDEodGhpcywgIXdpdGhTdWZmaXgsIHRoLCBsb2NhbGUpO1xuXG4gICAgICAgIGlmICh3aXRoU3VmZml4KSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBsb2NhbGUucGFzdEZ1dHVyZSgrdGhpcywgb3V0cHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsb2NhbGUucG9zdGZvcm1hdChvdXRwdXQpO1xuICAgIH1cblxuICAgIHZhciBhYnMkMSA9IE1hdGguYWJzO1xuXG4gICAgZnVuY3Rpb24gc2lnbih4KSB7XG4gICAgICAgIHJldHVybiAoeCA+IDApIC0gKHggPCAwKSB8fCAreDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0lTT1N0cmluZyQxKCkge1xuICAgICAgICAvLyBmb3IgSVNPIHN0cmluZ3Mgd2UgZG8gbm90IHVzZSB0aGUgbm9ybWFsIGJ1YmJsaW5nIHJ1bGVzOlxuICAgICAgICAvLyAgKiBtaWxsaXNlY29uZHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIGhvdXJzXG4gICAgICAgIC8vICAqIGRheXMgZG8gbm90IGJ1YmJsZSBhdCBhbGxcbiAgICAgICAgLy8gICogbW9udGhzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSB5ZWFyc1xuICAgICAgICAvLyBUaGlzIGlzIGJlY2F1c2UgdGhlcmUgaXMgbm8gY29udGV4dC1mcmVlIGNvbnZlcnNpb24gYmV0d2VlbiBob3VycyBhbmQgZGF5c1xuICAgICAgICAvLyAodGhpbmsgb2YgY2xvY2sgY2hhbmdlcylcbiAgICAgICAgLy8gYW5kIGFsc28gbm90IGJldHdlZW4gZGF5cyBhbmQgbW9udGhzICgyOC0zMSBkYXlzIHBlciBtb250aClcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2Vjb25kcyA9IGFicyQxKHRoaXMuX21pbGxpc2Vjb25kcykgLyAxMDAwLFxuICAgICAgICAgICAgZGF5cyA9IGFicyQxKHRoaXMuX2RheXMpLFxuICAgICAgICAgICAgbW9udGhzID0gYWJzJDEodGhpcy5fbW9udGhzKSxcbiAgICAgICAgICAgIG1pbnV0ZXMsXG4gICAgICAgICAgICBob3VycyxcbiAgICAgICAgICAgIHllYXJzLFxuICAgICAgICAgICAgcyxcbiAgICAgICAgICAgIHRvdGFsID0gdGhpcy5hc1NlY29uZHMoKSxcbiAgICAgICAgICAgIHRvdGFsU2lnbixcbiAgICAgICAgICAgIHltU2lnbixcbiAgICAgICAgICAgIGRheXNTaWduLFxuICAgICAgICAgICAgaG1zU2lnbjtcblxuICAgICAgICBpZiAoIXRvdGFsKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBzYW1lIGFzIEMjJ3MgKE5vZGEpIGFuZCBweXRob24gKGlzb2RhdGUpLi4uXG4gICAgICAgICAgICAvLyBidXQgbm90IG90aGVyIEpTIChnb29nLmRhdGUpXG4gICAgICAgICAgICByZXR1cm4gJ1AwRCc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAzNjAwIHNlY29uZHMgLT4gNjAgbWludXRlcyAtPiAxIGhvdXJcbiAgICAgICAgbWludXRlcyA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgICAgIGhvdXJzID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICAgICAgc2Vjb25kcyAlPSA2MDtcbiAgICAgICAgbWludXRlcyAlPSA2MDtcblxuICAgICAgICAvLyAxMiBtb250aHMgLT4gMSB5ZWFyXG4gICAgICAgIHllYXJzID0gYWJzRmxvb3IobW9udGhzIC8gMTIpO1xuICAgICAgICBtb250aHMgJT0gMTI7XG5cbiAgICAgICAgLy8gaW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL2RvcmRpbGxlL21vbWVudC1pc29kdXJhdGlvbi9ibG9iL21hc3Rlci9tb21lbnQuaXNvZHVyYXRpb24uanNcbiAgICAgICAgcyA9IHNlY29uZHMgPyBzZWNvbmRzLnRvRml4ZWQoMykucmVwbGFjZSgvXFwuPzArJC8sICcnKSA6ICcnO1xuXG4gICAgICAgIHRvdGFsU2lnbiA9IHRvdGFsIDwgMCA/ICctJyA6ICcnO1xuICAgICAgICB5bVNpZ24gPSBzaWduKHRoaXMuX21vbnRocykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG4gICAgICAgIGRheXNTaWduID0gc2lnbih0aGlzLl9kYXlzKSAhPT0gc2lnbih0b3RhbCkgPyAnLScgOiAnJztcbiAgICAgICAgaG1zU2lnbiA9IHNpZ24odGhpcy5fbWlsbGlzZWNvbmRzKSAhPT0gc2lnbih0b3RhbCkgPyAnLScgOiAnJztcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdG90YWxTaWduICtcbiAgICAgICAgICAgICdQJyArXG4gICAgICAgICAgICAoeWVhcnMgPyB5bVNpZ24gKyB5ZWFycyArICdZJyA6ICcnKSArXG4gICAgICAgICAgICAobW9udGhzID8geW1TaWduICsgbW9udGhzICsgJ00nIDogJycpICtcbiAgICAgICAgICAgIChkYXlzID8gZGF5c1NpZ24gKyBkYXlzICsgJ0QnIDogJycpICtcbiAgICAgICAgICAgIChob3VycyB8fCBtaW51dGVzIHx8IHNlY29uZHMgPyAnVCcgOiAnJykgK1xuICAgICAgICAgICAgKGhvdXJzID8gaG1zU2lnbiArIGhvdXJzICsgJ0gnIDogJycpICtcbiAgICAgICAgICAgIChtaW51dGVzID8gaG1zU2lnbiArIG1pbnV0ZXMgKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgKHNlY29uZHMgPyBobXNTaWduICsgcyArICdTJyA6ICcnKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHZhciBwcm90byQyID0gRHVyYXRpb24ucHJvdG90eXBlO1xuXG4gICAgcHJvdG8kMi5pc1ZhbGlkID0gaXNWYWxpZCQxO1xuICAgIHByb3RvJDIuYWJzID0gYWJzO1xuICAgIHByb3RvJDIuYWRkID0gYWRkJDE7XG4gICAgcHJvdG8kMi5zdWJ0cmFjdCA9IHN1YnRyYWN0JDE7XG4gICAgcHJvdG8kMi5hcyA9IGFzO1xuICAgIHByb3RvJDIuYXNNaWxsaXNlY29uZHMgPSBhc01pbGxpc2Vjb25kcztcbiAgICBwcm90byQyLmFzU2Vjb25kcyA9IGFzU2Vjb25kcztcbiAgICBwcm90byQyLmFzTWludXRlcyA9IGFzTWludXRlcztcbiAgICBwcm90byQyLmFzSG91cnMgPSBhc0hvdXJzO1xuICAgIHByb3RvJDIuYXNEYXlzID0gYXNEYXlzO1xuICAgIHByb3RvJDIuYXNXZWVrcyA9IGFzV2Vla3M7XG4gICAgcHJvdG8kMi5hc01vbnRocyA9IGFzTW9udGhzO1xuICAgIHByb3RvJDIuYXNRdWFydGVycyA9IGFzUXVhcnRlcnM7XG4gICAgcHJvdG8kMi5hc1llYXJzID0gYXNZZWFycztcbiAgICBwcm90byQyLnZhbHVlT2YgPSB2YWx1ZU9mJDE7XG4gICAgcHJvdG8kMi5fYnViYmxlID0gYnViYmxlO1xuICAgIHByb3RvJDIuY2xvbmUgPSBjbG9uZSQxO1xuICAgIHByb3RvJDIuZ2V0ID0gZ2V0JDI7XG4gICAgcHJvdG8kMi5taWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHM7XG4gICAgcHJvdG8kMi5zZWNvbmRzID0gc2Vjb25kcztcbiAgICBwcm90byQyLm1pbnV0ZXMgPSBtaW51dGVzO1xuICAgIHByb3RvJDIuaG91cnMgPSBob3VycztcbiAgICBwcm90byQyLmRheXMgPSBkYXlzO1xuICAgIHByb3RvJDIud2Vla3MgPSB3ZWVrcztcbiAgICBwcm90byQyLm1vbnRocyA9IG1vbnRocztcbiAgICBwcm90byQyLnllYXJzID0geWVhcnM7XG4gICAgcHJvdG8kMi5odW1hbml6ZSA9IGh1bWFuaXplO1xuICAgIHByb3RvJDIudG9JU09TdHJpbmcgPSB0b0lTT1N0cmluZyQxO1xuICAgIHByb3RvJDIudG9TdHJpbmcgPSB0b0lTT1N0cmluZyQxO1xuICAgIHByb3RvJDIudG9KU09OID0gdG9JU09TdHJpbmckMTtcbiAgICBwcm90byQyLmxvY2FsZSA9IGxvY2FsZTtcbiAgICBwcm90byQyLmxvY2FsZURhdGEgPSBsb2NhbGVEYXRhO1xuXG4gICAgcHJvdG8kMi50b0lzb1N0cmluZyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ3RvSXNvU3RyaW5nKCkgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSB0b0lTT1N0cmluZygpIGluc3RlYWQgKG5vdGljZSB0aGUgY2FwaXRhbHMpJyxcbiAgICAgICAgdG9JU09TdHJpbmckMVxuICAgICk7XG4gICAgcHJvdG8kMi5sYW5nID0gbGFuZztcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdYJywgMCwgMCwgJ3VuaXgnKTtcbiAgICBhZGRGb3JtYXRUb2tlbigneCcsIDAsIDAsICd2YWx1ZU9mJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCd4JywgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1gnLCBtYXRjaFRpbWVzdGFtcCk7XG4gICAgYWRkUGFyc2VUb2tlbignWCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShwYXJzZUZsb2F0KGlucHV0KSAqIDEwMDApO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ3gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUodG9JbnQoaW5wdXQpKTtcbiAgICB9KTtcblxuICAgIC8vISBtb21lbnQuanNcblxuICAgIGhvb2tzLnZlcnNpb24gPSAnMi4yOS40JztcblxuICAgIHNldEhvb2tDYWxsYmFjayhjcmVhdGVMb2NhbCk7XG5cbiAgICBob29rcy5mbiA9IHByb3RvO1xuICAgIGhvb2tzLm1pbiA9IG1pbjtcbiAgICBob29rcy5tYXggPSBtYXg7XG4gICAgaG9va3Mubm93ID0gbm93O1xuICAgIGhvb2tzLnV0YyA9IGNyZWF0ZVVUQztcbiAgICBob29rcy51bml4ID0gY3JlYXRlVW5peDtcbiAgICBob29rcy5tb250aHMgPSBsaXN0TW9udGhzO1xuICAgIGhvb2tzLmlzRGF0ZSA9IGlzRGF0ZTtcbiAgICBob29rcy5sb2NhbGUgPSBnZXRTZXRHbG9iYWxMb2NhbGU7XG4gICAgaG9va3MuaW52YWxpZCA9IGNyZWF0ZUludmFsaWQ7XG4gICAgaG9va3MuZHVyYXRpb24gPSBjcmVhdGVEdXJhdGlvbjtcbiAgICBob29rcy5pc01vbWVudCA9IGlzTW9tZW50O1xuICAgIGhvb2tzLndlZWtkYXlzID0gbGlzdFdlZWtkYXlzO1xuICAgIGhvb2tzLnBhcnNlWm9uZSA9IGNyZWF0ZUluWm9uZTtcbiAgICBob29rcy5sb2NhbGVEYXRhID0gZ2V0TG9jYWxlO1xuICAgIGhvb2tzLmlzRHVyYXRpb24gPSBpc0R1cmF0aW9uO1xuICAgIGhvb2tzLm1vbnRoc1Nob3J0ID0gbGlzdE1vbnRoc1Nob3J0O1xuICAgIGhvb2tzLndlZWtkYXlzTWluID0gbGlzdFdlZWtkYXlzTWluO1xuICAgIGhvb2tzLmRlZmluZUxvY2FsZSA9IGRlZmluZUxvY2FsZTtcbiAgICBob29rcy51cGRhdGVMb2NhbGUgPSB1cGRhdGVMb2NhbGU7XG4gICAgaG9va3MubG9jYWxlcyA9IGxpc3RMb2NhbGVzO1xuICAgIGhvb2tzLndlZWtkYXlzU2hvcnQgPSBsaXN0V2Vla2RheXNTaG9ydDtcbiAgICBob29rcy5ub3JtYWxpemVVbml0cyA9IG5vcm1hbGl6ZVVuaXRzO1xuICAgIGhvb2tzLnJlbGF0aXZlVGltZVJvdW5kaW5nID0gZ2V0U2V0UmVsYXRpdmVUaW1lUm91bmRpbmc7XG4gICAgaG9va3MucmVsYXRpdmVUaW1lVGhyZXNob2xkID0gZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkO1xuICAgIGhvb2tzLmNhbGVuZGFyRm9ybWF0ID0gZ2V0Q2FsZW5kYXJGb3JtYXQ7XG4gICAgaG9va3MucHJvdG90eXBlID0gcHJvdG87XG5cbiAgICAvLyBjdXJyZW50bHkgSFRNTDUgaW5wdXQgdHlwZSBvbmx5IHN1cHBvcnRzIDI0LWhvdXIgZm9ybWF0c1xuICAgIGhvb2tzLkhUTUw1X0ZNVCA9IHtcbiAgICAgICAgREFURVRJTUVfTE9DQUw6ICdZWVlZLU1NLUREVEhIOm1tJywgLy8gPGlucHV0IHR5cGU9XCJkYXRldGltZS1sb2NhbFwiIC8+XG4gICAgICAgIERBVEVUSU1FX0xPQ0FMX1NFQ09ORFM6ICdZWVlZLU1NLUREVEhIOm1tOnNzJywgLy8gPGlucHV0IHR5cGU9XCJkYXRldGltZS1sb2NhbFwiIHN0ZXA9XCIxXCIgLz5cbiAgICAgICAgREFURVRJTUVfTE9DQUxfTVM6ICdZWVlZLU1NLUREVEhIOm1tOnNzLlNTUycsIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZXRpbWUtbG9jYWxcIiBzdGVwPVwiMC4wMDFcIiAvPlxuICAgICAgICBEQVRFOiAnWVlZWS1NTS1ERCcsIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZVwiIC8+XG4gICAgICAgIFRJTUU6ICdISDptbScsIC8vIDxpbnB1dCB0eXBlPVwidGltZVwiIC8+XG4gICAgICAgIFRJTUVfU0VDT05EUzogJ0hIOm1tOnNzJywgLy8gPGlucHV0IHR5cGU9XCJ0aW1lXCIgc3RlcD1cIjFcIiAvPlxuICAgICAgICBUSU1FX01TOiAnSEg6bW06c3MuU1NTJywgLy8gPGlucHV0IHR5cGU9XCJ0aW1lXCIgc3RlcD1cIjAuMDAxXCIgLz5cbiAgICAgICAgV0VFSzogJ0dHR0ctW1ddV1cnLCAvLyA8aW5wdXQgdHlwZT1cIndlZWtcIiAvPlxuICAgICAgICBNT05USDogJ1lZWVktTU0nLCAvLyA8aW5wdXQgdHlwZT1cIm1vbnRoXCIgLz5cbiAgICB9O1xuXG4gICAgcmV0dXJuIGhvb2tzO1xuXG59KSkpO1xuIl0sIm5hbWVzIjpbImdsb2JhbCIsImZhY3RvcnkiLCJleHBvcnRzIiwibW9kdWxlIiwiZGVmaW5lIiwiYW1kIiwibW9tZW50IiwiaG9va0NhbGxiYWNrIiwiaG9va3MiLCJhcHBseSIsImFyZ3VtZW50cyIsInNldEhvb2tDYWxsYmFjayIsImNhbGxiYWNrIiwiaXNBcnJheSIsImlucHV0IiwiQXJyYXkiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJpc09iamVjdCIsImhhc093blByb3AiLCJhIiwiYiIsImhhc093blByb3BlcnR5IiwiaXNPYmplY3RFbXB0eSIsIm9iaiIsImdldE93blByb3BlcnR5TmFtZXMiLCJsZW5ndGgiLCJrIiwiaXNVbmRlZmluZWQiLCJpc051bWJlciIsImlzRGF0ZSIsIkRhdGUiLCJtYXAiLCJhcnIiLCJmbiIsInJlcyIsImkiLCJhcnJMZW4iLCJwdXNoIiwiZXh0ZW5kIiwidmFsdWVPZiIsImNyZWF0ZVVUQyIsImZvcm1hdCIsImxvY2FsZSIsInN0cmljdCIsImNyZWF0ZUxvY2FsT3JVVEMiLCJ1dGMiLCJkZWZhdWx0UGFyc2luZ0ZsYWdzIiwiZW1wdHkiLCJ1bnVzZWRUb2tlbnMiLCJ1bnVzZWRJbnB1dCIsIm92ZXJmbG93IiwiY2hhcnNMZWZ0T3ZlciIsIm51bGxJbnB1dCIsImludmFsaWRFcmEiLCJpbnZhbGlkTW9udGgiLCJpbnZhbGlkRm9ybWF0IiwidXNlckludmFsaWRhdGVkIiwiaXNvIiwicGFyc2VkRGF0ZVBhcnRzIiwiZXJhIiwibWVyaWRpZW0iLCJyZmMyODIyIiwid2Vla2RheU1pc21hdGNoIiwiZ2V0UGFyc2luZ0ZsYWdzIiwibSIsIl9wZiIsInNvbWUiLCJmdW4iLCJ0IiwibGVuIiwiaXNWYWxpZCIsIl9pc1ZhbGlkIiwiZmxhZ3MiLCJwYXJzZWRQYXJ0cyIsImlzTm93VmFsaWQiLCJpc05hTiIsIl9kIiwiZ2V0VGltZSIsImludmFsaWRXZWVrZGF5IiwiX3N0cmljdCIsImJpZ0hvdXIiLCJ1bmRlZmluZWQiLCJpc0Zyb3plbiIsImNyZWF0ZUludmFsaWQiLCJOYU4iLCJtb21lbnRQcm9wZXJ0aWVzIiwidXBkYXRlSW5Qcm9ncmVzcyIsImNvcHlDb25maWciLCJ0byIsImZyb20iLCJwcm9wIiwidmFsIiwibW9tZW50UHJvcGVydGllc0xlbiIsIl9pc0FNb21lbnRPYmplY3QiLCJfaSIsIl9mIiwiX2wiLCJfdHptIiwiX2lzVVRDIiwiX29mZnNldCIsIl9sb2NhbGUiLCJNb21lbnQiLCJjb25maWciLCJ1cGRhdGVPZmZzZXQiLCJpc01vbWVudCIsIndhcm4iLCJtc2ciLCJzdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MiLCJjb25zb2xlIiwiZGVwcmVjYXRlIiwiZmlyc3RUaW1lIiwiZGVwcmVjYXRpb25IYW5kbGVyIiwiYXJncyIsImFyZyIsImtleSIsImFyZ0xlbiIsInNsaWNlIiwiam9pbiIsIkVycm9yIiwic3RhY2siLCJkZXByZWNhdGlvbnMiLCJkZXByZWNhdGVTaW1wbGUiLCJuYW1lIiwiaXNGdW5jdGlvbiIsIkZ1bmN0aW9uIiwic2V0IiwiX2NvbmZpZyIsIl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudCIsIlJlZ0V4cCIsIl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlIiwic291cmNlIiwiX29yZGluYWxQYXJzZSIsIm1lcmdlQ29uZmlncyIsInBhcmVudENvbmZpZyIsImNoaWxkQ29uZmlnIiwiTG9jYWxlIiwia2V5cyIsImRlZmF1bHRDYWxlbmRhciIsInNhbWVEYXkiLCJuZXh0RGF5IiwibmV4dFdlZWsiLCJsYXN0RGF5IiwibGFzdFdlZWsiLCJzYW1lRWxzZSIsImNhbGVuZGFyIiwibW9tIiwibm93Iiwib3V0cHV0IiwiX2NhbGVuZGFyIiwiemVyb0ZpbGwiLCJudW1iZXIiLCJ0YXJnZXRMZW5ndGgiLCJmb3JjZVNpZ24iLCJhYnNOdW1iZXIiLCJNYXRoIiwiYWJzIiwiemVyb3NUb0ZpbGwiLCJzaWduIiwicG93IiwibWF4Iiwic3Vic3RyIiwiZm9ybWF0dGluZ1Rva2VucyIsImxvY2FsRm9ybWF0dGluZ1Rva2VucyIsImZvcm1hdEZ1bmN0aW9ucyIsImZvcm1hdFRva2VuRnVuY3Rpb25zIiwiYWRkRm9ybWF0VG9rZW4iLCJ0b2tlbiIsInBhZGRlZCIsIm9yZGluYWwiLCJmdW5jIiwibG9jYWxlRGF0YSIsInJlbW92ZUZvcm1hdHRpbmdUb2tlbnMiLCJtYXRjaCIsInJlcGxhY2UiLCJtYWtlRm9ybWF0RnVuY3Rpb24iLCJhcnJheSIsImZvcm1hdE1vbWVudCIsImludmFsaWREYXRlIiwiZXhwYW5kRm9ybWF0IiwicmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zIiwibG9uZ0RhdGVGb3JtYXQiLCJsYXN0SW5kZXgiLCJ0ZXN0IiwiZGVmYXVsdExvbmdEYXRlRm9ybWF0IiwiTFRTIiwiTFQiLCJMIiwiTEwiLCJMTEwiLCJMTExMIiwiX2xvbmdEYXRlRm9ybWF0IiwiZm9ybWF0VXBwZXIiLCJ0b1VwcGVyQ2FzZSIsInRvayIsImRlZmF1bHRJbnZhbGlkRGF0ZSIsIl9pbnZhbGlkRGF0ZSIsImRlZmF1bHRPcmRpbmFsIiwiZGVmYXVsdERheU9mTW9udGhPcmRpbmFsUGFyc2UiLCJfb3JkaW5hbCIsImRlZmF1bHRSZWxhdGl2ZVRpbWUiLCJmdXR1cmUiLCJwYXN0IiwicyIsInNzIiwibW0iLCJoIiwiaGgiLCJkIiwiZGQiLCJ3Iiwid3ciLCJNIiwiTU0iLCJ5IiwieXkiLCJyZWxhdGl2ZVRpbWUiLCJ3aXRob3V0U3VmZml4Iiwic3RyaW5nIiwiaXNGdXR1cmUiLCJfcmVsYXRpdmVUaW1lIiwicGFzdEZ1dHVyZSIsImRpZmYiLCJhbGlhc2VzIiwiYWRkVW5pdEFsaWFzIiwidW5pdCIsInNob3J0aGFuZCIsImxvd2VyQ2FzZSIsInRvTG93ZXJDYXNlIiwibm9ybWFsaXplVW5pdHMiLCJ1bml0cyIsIm5vcm1hbGl6ZU9iamVjdFVuaXRzIiwiaW5wdXRPYmplY3QiLCJub3JtYWxpemVkSW5wdXQiLCJub3JtYWxpemVkUHJvcCIsInByaW9yaXRpZXMiLCJhZGRVbml0UHJpb3JpdHkiLCJwcmlvcml0eSIsImdldFByaW9yaXRpemVkVW5pdHMiLCJ1bml0c09iaiIsInUiLCJzb3J0IiwiaXNMZWFwWWVhciIsInllYXIiLCJhYnNGbG9vciIsImNlaWwiLCJmbG9vciIsInRvSW50IiwiYXJndW1lbnRGb3JDb2VyY2lvbiIsImNvZXJjZWROdW1iZXIiLCJ2YWx1ZSIsImlzRmluaXRlIiwibWFrZUdldFNldCIsImtlZXBUaW1lIiwic2V0JDEiLCJnZXQiLCJtb250aCIsImRhdGUiLCJkYXlzSW5Nb250aCIsInN0cmluZ0dldCIsInN0cmluZ1NldCIsInByaW9yaXRpemVkIiwicHJpb3JpdGl6ZWRMZW4iLCJtYXRjaDEiLCJtYXRjaDIiLCJtYXRjaDMiLCJtYXRjaDQiLCJtYXRjaDYiLCJtYXRjaDF0bzIiLCJtYXRjaDN0bzQiLCJtYXRjaDV0bzYiLCJtYXRjaDF0bzMiLCJtYXRjaDF0bzQiLCJtYXRjaDF0bzYiLCJtYXRjaFVuc2lnbmVkIiwibWF0Y2hTaWduZWQiLCJtYXRjaE9mZnNldCIsIm1hdGNoU2hvcnRPZmZzZXQiLCJtYXRjaFRpbWVzdGFtcCIsIm1hdGNoV29yZCIsInJlZ2V4ZXMiLCJhZGRSZWdleFRva2VuIiwicmVnZXgiLCJzdHJpY3RSZWdleCIsImlzU3RyaWN0IiwiZ2V0UGFyc2VSZWdleEZvclRva2VuIiwidW5lc2NhcGVGb3JtYXQiLCJyZWdleEVzY2FwZSIsIm1hdGNoZWQiLCJwMSIsInAyIiwicDMiLCJwNCIsInRva2VucyIsImFkZFBhcnNlVG9rZW4iLCJ0b2tlbkxlbiIsImFkZFdlZWtQYXJzZVRva2VuIiwiX3ciLCJhZGRUaW1lVG9BcnJheUZyb21Ub2tlbiIsIl9hIiwiWUVBUiIsIk1PTlRIIiwiREFURSIsIkhPVVIiLCJNSU5VVEUiLCJTRUNPTkQiLCJNSUxMSVNFQ09ORCIsIldFRUsiLCJXRUVLREFZIiwibW9kIiwibiIsIngiLCJpbmRleE9mIiwibyIsIm1vZE1vbnRoIiwibW9udGhzU2hvcnQiLCJtb250aHMiLCJtb250aHNTaG9ydFJlZ2V4IiwibW9udGhzUmVnZXgiLCJtb250aHNQYXJzZSIsImRlZmF1bHRMb2NhbGVNb250aHMiLCJzcGxpdCIsImRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCIsIk1PTlRIU19JTl9GT1JNQVQiLCJkZWZhdWx0TW9udGhzU2hvcnRSZWdleCIsImRlZmF1bHRNb250aHNSZWdleCIsImxvY2FsZU1vbnRocyIsIl9tb250aHMiLCJpc0Zvcm1hdCIsImxvY2FsZU1vbnRoc1Nob3J0IiwiX21vbnRoc1Nob3J0IiwiaGFuZGxlU3RyaWN0UGFyc2UiLCJtb250aE5hbWUiLCJpaSIsImxsYyIsInRvTG9jYWxlTG93ZXJDYXNlIiwiX21vbnRoc1BhcnNlIiwiX2xvbmdNb250aHNQYXJzZSIsIl9zaG9ydE1vbnRoc1BhcnNlIiwibG9jYWxlTW9udGhzUGFyc2UiLCJfbW9udGhzUGFyc2VFeGFjdCIsInNldE1vbnRoIiwiZGF5T2ZNb250aCIsIm1pbiIsImdldFNldE1vbnRoIiwiZ2V0RGF5c0luTW9udGgiLCJjb21wdXRlTW9udGhzUGFyc2UiLCJfbW9udGhzU2hvcnRTdHJpY3RSZWdleCIsIl9tb250aHNTaG9ydFJlZ2V4IiwiX21vbnRoc1N0cmljdFJlZ2V4IiwiX21vbnRoc1JlZ2V4IiwiY21wTGVuUmV2Iiwic2hvcnRQaWVjZXMiLCJsb25nUGllY2VzIiwibWl4ZWRQaWVjZXMiLCJwYXJzZVR3b0RpZ2l0WWVhciIsInBhcnNlSW50IiwiZGF5c0luWWVhciIsImdldFNldFllYXIiLCJnZXRJc0xlYXBZZWFyIiwiY3JlYXRlRGF0ZSIsIm1zIiwiZ2V0RnVsbFllYXIiLCJzZXRGdWxsWWVhciIsImNyZWF0ZVVUQ0RhdGUiLCJVVEMiLCJnZXRVVENGdWxsWWVhciIsInNldFVUQ0Z1bGxZZWFyIiwiZmlyc3RXZWVrT2Zmc2V0IiwiZG93IiwiZG95IiwiZndkIiwiZndkbHciLCJnZXRVVENEYXkiLCJkYXlPZlllYXJGcm9tV2Vla3MiLCJ3ZWVrIiwid2Vla2RheSIsImxvY2FsV2Vla2RheSIsIndlZWtPZmZzZXQiLCJkYXlPZlllYXIiLCJyZXNZZWFyIiwicmVzRGF5T2ZZZWFyIiwid2Vla09mWWVhciIsInJlc1dlZWsiLCJ3ZWVrc0luWWVhciIsIndlZWtPZmZzZXROZXh0IiwibG9jYWxlV2VlayIsIl93ZWVrIiwiZGVmYXVsdExvY2FsZVdlZWsiLCJsb2NhbGVGaXJzdERheU9mV2VlayIsImxvY2FsZUZpcnN0RGF5T2ZZZWFyIiwiZ2V0U2V0V2VlayIsImFkZCIsImdldFNldElTT1dlZWsiLCJ3ZWVrZGF5c01pbiIsIndlZWtkYXlzU2hvcnQiLCJ3ZWVrZGF5cyIsIndlZWtkYXlzTWluUmVnZXgiLCJ3ZWVrZGF5c1Nob3J0UmVnZXgiLCJ3ZWVrZGF5c1JlZ2V4Iiwid2Vla2RheXNQYXJzZSIsInBhcnNlV2Vla2RheSIsInBhcnNlSXNvV2Vla2RheSIsInNoaWZ0V2Vla2RheXMiLCJ3cyIsImNvbmNhdCIsImRlZmF1bHRMb2NhbGVXZWVrZGF5cyIsImRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0IiwiZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluIiwiZGVmYXVsdFdlZWtkYXlzUmVnZXgiLCJkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4IiwiZGVmYXVsdFdlZWtkYXlzTWluUmVnZXgiLCJsb2NhbGVXZWVrZGF5cyIsIl93ZWVrZGF5cyIsImRheSIsImxvY2FsZVdlZWtkYXlzU2hvcnQiLCJfd2Vla2RheXNTaG9ydCIsImxvY2FsZVdlZWtkYXlzTWluIiwiX3dlZWtkYXlzTWluIiwiaGFuZGxlU3RyaWN0UGFyc2UkMSIsIndlZWtkYXlOYW1lIiwiX3dlZWtkYXlzUGFyc2UiLCJfc2hvcnRXZWVrZGF5c1BhcnNlIiwiX21pbldlZWtkYXlzUGFyc2UiLCJsb2NhbGVXZWVrZGF5c1BhcnNlIiwiX3dlZWtkYXlzUGFyc2VFeGFjdCIsIl9mdWxsV2Vla2RheXNQYXJzZSIsImdldFNldERheU9mV2VlayIsImdldERheSIsImdldFNldExvY2FsZURheU9mV2VlayIsImdldFNldElTT0RheU9mV2VlayIsImNvbXB1dGVXZWVrZGF5c1BhcnNlIiwiX3dlZWtkYXlzU3RyaWN0UmVnZXgiLCJfd2Vla2RheXNSZWdleCIsIl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXgiLCJfd2Vla2RheXNTaG9ydFJlZ2V4IiwiX3dlZWtkYXlzTWluU3RyaWN0UmVnZXgiLCJfd2Vla2RheXNNaW5SZWdleCIsIm1pblBpZWNlcyIsIm1pbnAiLCJzaG9ydHAiLCJsb25ncCIsImhGb3JtYXQiLCJob3VycyIsImtGb3JtYXQiLCJtaW51dGVzIiwic2Vjb25kcyIsImxvd2VyY2FzZSIsIm1hdGNoTWVyaWRpZW0iLCJfbWVyaWRpZW1QYXJzZSIsImtJbnB1dCIsIl9pc1BtIiwiaXNQTSIsIl9tZXJpZGllbSIsInBvcyIsInBvczEiLCJwb3MyIiwibG9jYWxlSXNQTSIsImNoYXJBdCIsImRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlIiwiZ2V0U2V0SG91ciIsImxvY2FsZU1lcmlkaWVtIiwiaXNMb3dlciIsImJhc2VDb25maWciLCJkYXlPZk1vbnRoT3JkaW5hbFBhcnNlIiwibWVyaWRpZW1QYXJzZSIsImxvY2FsZXMiLCJsb2NhbGVGYW1pbGllcyIsImdsb2JhbExvY2FsZSIsImNvbW1vblByZWZpeCIsImFycjEiLCJhcnIyIiwibWlubCIsIm5vcm1hbGl6ZUxvY2FsZSIsImNob29zZUxvY2FsZSIsIm5hbWVzIiwiaiIsIm5leHQiLCJsb2FkTG9jYWxlIiwiaXNMb2NhbGVOYW1lU2FuZSIsIm9sZExvY2FsZSIsImFsaWFzZWRSZXF1aXJlIiwiX2FiYnIiLCJyZXF1aXJlIiwiZ2V0U2V0R2xvYmFsTG9jYWxlIiwiZSIsInZhbHVlcyIsImRhdGEiLCJnZXRMb2NhbGUiLCJkZWZpbmVMb2NhbGUiLCJhYmJyIiwicGFyZW50TG9jYWxlIiwiZm9yRWFjaCIsInVwZGF0ZUxvY2FsZSIsInRtcExvY2FsZSIsImxpc3RMb2NhbGVzIiwiY2hlY2tPdmVyZmxvdyIsIl9vdmVyZmxvd0RheU9mWWVhciIsIl9vdmVyZmxvd1dlZWtzIiwiX292ZXJmbG93V2Vla2RheSIsImV4dGVuZGVkSXNvUmVnZXgiLCJiYXNpY0lzb1JlZ2V4IiwidHpSZWdleCIsImlzb0RhdGVzIiwiaXNvVGltZXMiLCJhc3BOZXRKc29uUmVnZXgiLCJvYnNPZmZzZXRzIiwiVVQiLCJHTVQiLCJFRFQiLCJFU1QiLCJDRFQiLCJDU1QiLCJNRFQiLCJNU1QiLCJQRFQiLCJQU1QiLCJjb25maWdGcm9tSVNPIiwibCIsImV4ZWMiLCJhbGxvd1RpbWUiLCJkYXRlRm9ybWF0IiwidGltZUZvcm1hdCIsInR6Rm9ybWF0IiwiaXNvRGF0ZXNMZW4iLCJpc29UaW1lc0xlbiIsImNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQiLCJleHRyYWN0RnJvbVJGQzI4MjJTdHJpbmdzIiwieWVhclN0ciIsIm1vbnRoU3RyIiwiZGF5U3RyIiwiaG91clN0ciIsIm1pbnV0ZVN0ciIsInNlY29uZFN0ciIsInJlc3VsdCIsInVudHJ1bmNhdGVZZWFyIiwicHJlcHJvY2Vzc1JGQzI4MjIiLCJjaGVja1dlZWtkYXkiLCJ3ZWVrZGF5U3RyIiwicGFyc2VkSW5wdXQiLCJ3ZWVrZGF5UHJvdmlkZWQiLCJ3ZWVrZGF5QWN0dWFsIiwiY2FsY3VsYXRlT2Zmc2V0Iiwib2JzT2Zmc2V0IiwibWlsaXRhcnlPZmZzZXQiLCJudW1PZmZzZXQiLCJobSIsImNvbmZpZ0Zyb21SRkMyODIyIiwicGFyc2VkQXJyYXkiLCJzZXRVVENNaW51dGVzIiwiZ2V0VVRDTWludXRlcyIsImNvbmZpZ0Zyb21TdHJpbmciLCJjcmVhdGVGcm9tSW5wdXRGYWxsYmFjayIsIl91c2VVVEMiLCJkZWZhdWx0cyIsImMiLCJjdXJyZW50RGF0ZUFycmF5Iiwibm93VmFsdWUiLCJnZXRVVENNb250aCIsImdldFVUQ0RhdGUiLCJnZXRNb250aCIsImdldERhdGUiLCJjb25maWdGcm9tQXJyYXkiLCJjdXJyZW50RGF0ZSIsImV4cGVjdGVkV2Vla2RheSIsInllYXJUb1VzZSIsImRheU9mWWVhckZyb21XZWVrSW5mbyIsIl9kYXlPZlllYXIiLCJfbmV4dERheSIsIndlZWtZZWFyIiwidGVtcCIsIndlZWtkYXlPdmVyZmxvdyIsImN1cldlZWsiLCJHRyIsIlciLCJFIiwiY3JlYXRlTG9jYWwiLCJnZyIsIklTT184NjAxIiwiUkZDXzI4MjIiLCJza2lwcGVkIiwic3RyaW5nTGVuZ3RoIiwidG90YWxQYXJzZWRJbnB1dExlbmd0aCIsIm1lcmlkaWVtRml4V3JhcCIsImVyYXNDb252ZXJ0WWVhciIsImhvdXIiLCJpc1BtIiwibWVyaWRpZW1Ib3VyIiwiY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5IiwidGVtcENvbmZpZyIsImJlc3RNb21lbnQiLCJzY29yZVRvQmVhdCIsImN1cnJlbnRTY29yZSIsInZhbGlkRm9ybWF0Rm91bmQiLCJiZXN0Rm9ybWF0SXNWYWxpZCIsImNvbmZpZ2ZMZW4iLCJzY29yZSIsImNvbmZpZ0Zyb21PYmplY3QiLCJkYXlPckRhdGUiLCJtaW51dGUiLCJzZWNvbmQiLCJtaWxsaXNlY29uZCIsImNyZWF0ZUZyb21Db25maWciLCJwcmVwYXJlQ29uZmlnIiwicHJlcGFyc2UiLCJjb25maWdGcm9tSW5wdXQiLCJpc1VUQyIsInByb3RvdHlwZU1pbiIsIm90aGVyIiwicHJvdG90eXBlTWF4IiwicGlja0J5IiwibW9tZW50cyIsIm9yZGVyaW5nIiwiaXNEdXJhdGlvblZhbGlkIiwidW5pdEhhc0RlY2ltYWwiLCJvcmRlckxlbiIsInBhcnNlRmxvYXQiLCJpc1ZhbGlkJDEiLCJjcmVhdGVJbnZhbGlkJDEiLCJjcmVhdGVEdXJhdGlvbiIsIkR1cmF0aW9uIiwiZHVyYXRpb24iLCJ5ZWFycyIsInF1YXJ0ZXJzIiwicXVhcnRlciIsIndlZWtzIiwiaXNvV2VlayIsImRheXMiLCJtaWxsaXNlY29uZHMiLCJfbWlsbGlzZWNvbmRzIiwiX2RheXMiLCJfZGF0YSIsIl9idWJibGUiLCJpc0R1cmF0aW9uIiwiYWJzUm91bmQiLCJyb3VuZCIsImNvbXBhcmVBcnJheXMiLCJhcnJheTEiLCJhcnJheTIiLCJkb250Q29udmVydCIsImxlbmd0aERpZmYiLCJkaWZmcyIsIm9mZnNldCIsInNlcGFyYXRvciIsInV0Y09mZnNldCIsIm9mZnNldEZyb21TdHJpbmciLCJjaHVua09mZnNldCIsIm1hdGNoZXIiLCJtYXRjaGVzIiwiY2h1bmsiLCJwYXJ0cyIsImNsb25lV2l0aE9mZnNldCIsIm1vZGVsIiwiY2xvbmUiLCJzZXRUaW1lIiwibG9jYWwiLCJnZXREYXRlT2Zmc2V0IiwiZ2V0VGltZXpvbmVPZmZzZXQiLCJnZXRTZXRPZmZzZXQiLCJrZWVwTG9jYWxUaW1lIiwia2VlcE1pbnV0ZXMiLCJsb2NhbEFkanVzdCIsIl9jaGFuZ2VJblByb2dyZXNzIiwiYWRkU3VidHJhY3QiLCJnZXRTZXRab25lIiwic2V0T2Zmc2V0VG9VVEMiLCJzZXRPZmZzZXRUb0xvY2FsIiwic3VidHJhY3QiLCJzZXRPZmZzZXRUb1BhcnNlZE9mZnNldCIsInRab25lIiwiaGFzQWxpZ25lZEhvdXJPZmZzZXQiLCJpc0RheWxpZ2h0U2F2aW5nVGltZSIsImlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZCIsIl9pc0RTVFNoaWZ0ZWQiLCJ0b0FycmF5IiwiaXNMb2NhbCIsImlzVXRjT2Zmc2V0IiwiaXNVdGMiLCJhc3BOZXRSZWdleCIsImlzb1JlZ2V4IiwicmV0IiwiZGlmZlJlcyIsInBhcnNlSXNvIiwibW9tZW50c0RpZmZlcmVuY2UiLCJpbnZhbGlkIiwiaW5wIiwicG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZSIsImJhc2UiLCJpc0FmdGVyIiwiaXNCZWZvcmUiLCJjcmVhdGVBZGRlciIsImRpcmVjdGlvbiIsInBlcmlvZCIsImR1ciIsInRtcCIsImlzQWRkaW5nIiwiaXNTdHJpbmciLCJTdHJpbmciLCJpc01vbWVudElucHV0IiwiaXNOdW1iZXJPclN0cmluZ0FycmF5IiwiaXNNb21lbnRJbnB1dE9iamVjdCIsIm9iamVjdFRlc3QiLCJwcm9wZXJ0eVRlc3QiLCJwcm9wZXJ0aWVzIiwicHJvcGVydHkiLCJwcm9wZXJ0eUxlbiIsImFycmF5VGVzdCIsImRhdGFUeXBlVGVzdCIsImZpbHRlciIsIml0ZW0iLCJpc0NhbGVuZGFyU3BlYyIsImdldENhbGVuZGFyRm9ybWF0IiwibXlNb21lbnQiLCJjYWxlbmRhciQxIiwidGltZSIsImZvcm1hdHMiLCJzb2QiLCJzdGFydE9mIiwiY2FsZW5kYXJGb3JtYXQiLCJsb2NhbElucHV0IiwiZW5kT2YiLCJpc0JldHdlZW4iLCJpbmNsdXNpdml0eSIsImxvY2FsRnJvbSIsImxvY2FsVG8iLCJpc1NhbWUiLCJpbnB1dE1zIiwiaXNTYW1lT3JBZnRlciIsImlzU2FtZU9yQmVmb3JlIiwiYXNGbG9hdCIsInRoYXQiLCJ6b25lRGVsdGEiLCJtb250aERpZmYiLCJ3aG9sZU1vbnRoRGlmZiIsImFuY2hvciIsImFuY2hvcjIiLCJhZGp1c3QiLCJkZWZhdWx0Rm9ybWF0IiwiZGVmYXVsdEZvcm1hdFV0YyIsInRvSVNPU3RyaW5nIiwia2VlcE9mZnNldCIsInRvRGF0ZSIsImluc3BlY3QiLCJ6b25lIiwicHJlZml4IiwiZGF0ZXRpbWUiLCJzdWZmaXgiLCJpbnB1dFN0cmluZyIsInBvc3Rmb3JtYXQiLCJodW1hbml6ZSIsImZyb21Ob3ciLCJ0b05vdyIsIm5ld0xvY2FsZURhdGEiLCJsYW5nIiwiTVNfUEVSX1NFQ09ORCIsIk1TX1BFUl9NSU5VVEUiLCJNU19QRVJfSE9VUiIsIk1TX1BFUl80MDBfWUVBUlMiLCJtb2QkMSIsImRpdmlkZW5kIiwiZGl2aXNvciIsImxvY2FsU3RhcnRPZkRhdGUiLCJ1dGNTdGFydE9mRGF0ZSIsInN0YXJ0T2ZEYXRlIiwiaXNvV2Vla2RheSIsInVuaXgiLCJ0b09iamVjdCIsInRvSlNPTiIsImlzVmFsaWQkMiIsInBhcnNpbmdGbGFncyIsImludmFsaWRBdCIsImNyZWF0aW9uRGF0YSIsIm1hdGNoRXJhQWJiciIsIm1hdGNoRXJhTmFtZSIsIm1hdGNoRXJhTmFycm93IiwiZXJhc1BhcnNlIiwibWF0Y2hFcmFZZWFyT3JkaW5hbCIsIl9lcmFZZWFyT3JkaW5hbFJlZ2V4IiwiZXJhWWVhck9yZGluYWxQYXJzZSIsImxvY2FsZUVyYXMiLCJlcmFzIiwiX2VyYXMiLCJzaW5jZSIsInVudGlsIiwiSW5maW5pdHkiLCJsb2NhbGVFcmFzUGFyc2UiLCJlcmFOYW1lIiwibmFycm93IiwibG9jYWxlRXJhc0NvbnZlcnRZZWFyIiwiZGlyIiwiZ2V0RXJhTmFtZSIsImdldEVyYU5hcnJvdyIsImdldEVyYUFiYnIiLCJnZXRFcmFZZWFyIiwiZXJhc05hbWVSZWdleCIsImNvbXB1dGVFcmFzUGFyc2UiLCJfZXJhc05hbWVSZWdleCIsIl9lcmFzUmVnZXgiLCJlcmFzQWJiclJlZ2V4IiwiX2VyYXNBYmJyUmVnZXgiLCJlcmFzTmFycm93UmVnZXgiLCJfZXJhc05hcnJvd1JlZ2V4IiwiYWJiclBpZWNlcyIsIm5hbWVQaWVjZXMiLCJuYXJyb3dQaWVjZXMiLCJpc29XZWVrWWVhciIsImFkZFdlZWtZZWFyRm9ybWF0VG9rZW4iLCJnZXR0ZXIiLCJnZXRTZXRXZWVrWWVhciIsImdldFNldFdlZWtZZWFySGVscGVyIiwiZ2V0U2V0SVNPV2Vla1llYXIiLCJnZXRJU09XZWVrc0luWWVhciIsImdldElTT1dlZWtzSW5JU09XZWVrWWVhciIsImdldFdlZWtzSW5ZZWFyIiwid2Vla0luZm8iLCJnZXRXZWVrc0luV2Vla1llYXIiLCJ3ZWVrc1RhcmdldCIsInNldFdlZWtBbGwiLCJkYXlPZlllYXJEYXRhIiwiZ2V0U2V0UXVhcnRlciIsImdldFNldERheU9mTW9udGgiLCJnZXRTZXREYXlPZlllYXIiLCJnZXRTZXRNaW51dGUiLCJnZXRTZXRTZWNvbmQiLCJnZXRTZXRNaWxsaXNlY29uZCIsInBhcnNlTXMiLCJnZXRab25lQWJiciIsImdldFpvbmVOYW1lIiwicHJvdG8iLCJTeW1ib2wiLCJmb3IiLCJlcmFOYXJyb3ciLCJlcmFBYmJyIiwiZXJhWWVhciIsImlzb1dlZWtzIiwid2Vla3NJbldlZWtZZWFyIiwiaXNvV2Vla3NJblllYXIiLCJpc29XZWVrc0luSVNPV2Vla1llYXIiLCJwYXJzZVpvbmUiLCJpc0RTVCIsInpvbmVBYmJyIiwiem9uZU5hbWUiLCJkYXRlcyIsImlzRFNUU2hpZnRlZCIsImNyZWF0ZVVuaXgiLCJjcmVhdGVJblpvbmUiLCJwcmVQYXJzZVBvc3RGb3JtYXQiLCJwcm90byQxIiwiZmlyc3REYXlPZlllYXIiLCJmaXJzdERheU9mV2VlayIsImdldCQxIiwiaW5kZXgiLCJmaWVsZCIsInNldHRlciIsImxpc3RNb250aHNJbXBsIiwib3V0IiwibGlzdFdlZWtkYXlzSW1wbCIsImxvY2FsZVNvcnRlZCIsInNoaWZ0IiwibGlzdE1vbnRocyIsImxpc3RNb250aHNTaG9ydCIsImxpc3RXZWVrZGF5cyIsImxpc3RXZWVrZGF5c1Nob3J0IiwibGlzdFdlZWtkYXlzTWluIiwibGFuZ0RhdGEiLCJtYXRoQWJzIiwiYWRkU3VidHJhY3QkMSIsImFkZCQxIiwic3VidHJhY3QkMSIsImFic0NlaWwiLCJidWJibGUiLCJtb250aHNGcm9tRGF5cyIsIm1vbnRoc1RvRGF5cyIsImRheXNUb01vbnRocyIsImFzIiwidmFsdWVPZiQxIiwibWFrZUFzIiwiYWxpYXMiLCJhc01pbGxpc2Vjb25kcyIsImFzU2Vjb25kcyIsImFzTWludXRlcyIsImFzSG91cnMiLCJhc0RheXMiLCJhc1dlZWtzIiwiYXNNb250aHMiLCJhc1F1YXJ0ZXJzIiwiYXNZZWFycyIsImNsb25lJDEiLCJnZXQkMiIsIm1ha2VHZXR0ZXIiLCJ0aHJlc2hvbGRzIiwic3Vic3RpdHV0ZVRpbWVBZ28iLCJyZWxhdGl2ZVRpbWUkMSIsInBvc05lZ0R1cmF0aW9uIiwiZ2V0U2V0UmVsYXRpdmVUaW1lUm91bmRpbmciLCJyb3VuZGluZ0Z1bmN0aW9uIiwiZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkIiwidGhyZXNob2xkIiwibGltaXQiLCJhcmdXaXRoU3VmZml4IiwiYXJnVGhyZXNob2xkcyIsIndpdGhTdWZmaXgiLCJ0aCIsImFzc2lnbiIsImFicyQxIiwidG9JU09TdHJpbmckMSIsInRvdGFsIiwidG90YWxTaWduIiwieW1TaWduIiwiZGF5c1NpZ24iLCJobXNTaWduIiwidG9GaXhlZCIsInByb3RvJDIiLCJ0b0lzb1N0cmluZyIsInZlcnNpb24iLCJyZWxhdGl2ZVRpbWVSb3VuZGluZyIsInJlbGF0aXZlVGltZVRocmVzaG9sZCIsIkhUTUw1X0ZNVCIsIkRBVEVUSU1FX0xPQ0FMIiwiREFURVRJTUVfTE9DQUxfU0VDT05EUyIsIkRBVEVUSU1FX0xPQ0FMX01TIiwiVElNRSIsIlRJTUVfU0VDT05EUyIsIlRJTUVfTVMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/moment/moment.js\n");

/***/ })

};
;